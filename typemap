TYPEMAP
UA_Boolean				T_PACKED
UA_SByte				T_PACKED
UA_Byte					T_PACKED
UA_Int16				T_PACKED
UA_UInt16				T_PACKED
UA_Int32				T_PACKED
UA_UInt32				T_PACKED
# XXX this only works for Perl on 64 bit platforms
UA_Int64				T_PACKED
UA_UInt64				T_PACKED
UA_Float				T_PACKED
UA_Double				T_PACKED
UA_StatusCode				T_PACKED
UA_String				T_PACKED
UA_ByteString				T_PACKED
OPCUA_Open62541_NodeIdType		T_ENUM
UA_NodeId				T_PACKED
OPCUA_Open62541_NodeId			T_UA_PTR
OPCUA_Open62541_QualifiedName		T_UA_QUALIFIEDNAME
OPCUA_Open62541_DataType		T_UA_DATATYPE
OPCUA_Open62541_Variant			T_PTROBJ_SPECIAL
OPCUA_Open62541_VariableAttributes	T_UA_VARIABLEATTRIBUTES
OPCUA_Open62541_Server			T_PTROBJ_SPECIAL
OPCUA_Open62541_ServerConfig		T_PTROBJ_SPECIAL
OPCUA_Open62541_Client			T_PTROBJ_SPECIAL
OPCUA_Open62541_ClientConfig		T_PTROBJ_SPECIAL
OPCUA_Open62541_ClientState		T_ENUM

#############################################################################
INPUT
T_UA_DATATYPE
	{
		UV index = SvUV($arg);
		if (index < UA_TYPES_COUNT) {
			$var = &UA_TYPES[index];
		} else {
			croak(\"unsigned value %lu not below UA_TYPES_COUNT\",
			    index);
		}
	}
T_UA_PTR
	if (!SvOK($arg)) {
		/* Argument is optional, do not output anything if undef. */
		$var = NULL;
	} else if (SvROK($arg) && sv_derived_from($arg,
	    \"${(my $ntt=${ntype})=~s/_/::/g;\$ntt}\")) {
		/* Already an object pointer. */
		$var = INT2PTR($type, SvIV(SvRV($arg)));
	} else if (SvROK($arg) && SvTYPE(SvRV($arg)) < SVt_PVAV) {
		/* Scalar reference, set referenced variable to pointer. */
		$var = UA_${(my $ntt=${ntype})=~s/.*_//g;\$ntt}_new();
		if ($var == NULL)
			croak(\"UA_${(my $ntt=${ntype})=~s/.*_//g;\$ntt}_new\");
		DPRINTF(\"${(my $ntt=lc(${ntype}))=~s/.*_//g;\$ntt} %p\", $var);
		sv_setref_pv(SvRV($arg),
		    \"${(my $ntt=${ntype})=~s/_/::/g;\$ntt}\", $var);
	} else {
		croak(\"%s: %s is not a scalar reference\",
		    ${$ALIAS?\q[GvNAME(CvGV(cv))]:\qq[\"$pname\"]}, \"$var\");
	}
T_UA_QUALIFIEDNAME
	STMT_START {
		SV* const xsub_tmp_sv = $arg;
		SV **value;
		HV *hv;

		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) &&
		    SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
			hv = (HV*)SvRV(xsub_tmp_sv);
		} else {
		    croak(\"%s: %s is not a HASH reference\",
			${$ALIAS?\q[GvNAME(CvGV(cv))]:\qq[\"$pname\"]},
			\"$var\");
		}
		value = hv_fetch(hv, \"QualifiedName_namespaceIndex\", 28, 0);
		if (value == NULL)
			croak(\"%s: no QualifiedName_namespaceIndex in HASH\",
			    __func__);
		$var.namespaceIndex = XS_unpack_UA_UInt16(*value);
		value = hv_fetch(hv, \"QualifiedName_name\", 18, 0);
		if (value == NULL)
			croak(\"%s: no QualifiedName_name in HASH\", __func__);
		$var.name = XS_unpack_UA_String(*value);
	} STMT_END
T_UA_VARIABLEATTRIBUTES
	STMT_START {
		SV* const xsub_tmp_sv = $arg;
		SV **value;
		HV *hv;

		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) &&
		    SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
			hv = (HV*)SvRV(xsub_tmp_sv);
		} else {
		    croak(\"%s: %s is not a HASH reference\",
			${$ALIAS?\q[GvNAME(CvGV(cv))]:\qq[\"$pname\"]},
			\"$var\");
		}
		/* XXX only implement some rudimentary fields */
		$var = UA_VariableAttributes_default;
		/* XXX locale not set */
		value = hv_fetch(hv, \"VariableAttributes_displayName\", 30, 0);
		if (value != NULL)
			$var.displayName.text = XS_unpack_UA_String(*value);
		value = hv_fetch(hv, \"VariableAttributes_description\", 30, 0);
		if (value != NULL)
			$var.description.text = XS_unpack_UA_String(*value);
		value = hv_fetch(hv, \"VariableAttributes_dataType\", 27, 0);
		if (value != NULL) {
			UV index = SvUV(*value);
			if (index >= UA_TYPES_COUNT) {
				croak(\"unsigned value %lu not below \"
				    \"UA_TYPES_COUNT\", index);
			}
			$var.dataType = UA_TYPES[index].typeId;
		}
		value = hv_fetch(hv, \"VariableAttributes_value\", 24, 0);
		if (value != NULL) {
			if (!SvROK(*value) || sv_derived_from(SvRV(*value),
			    \"OPCUA::Open62541::Variant\"))
				croak(\"VariableAttributes_value is not \"
				    \"a OPCUA::Open62541::Variant\");
			$var.value = *INT2PTR(OPCUA_Open62541_Variant,
			    SvIV(SvRV(*value)));
		}
	} STMT_END
T_PTROBJ_SPECIAL
	if (SvROK($arg) && sv_derived_from($arg,
	    \"${(my $ntt=${ntype})=~s/_/::/g;\$ntt}\")) {
		IV tmp = SvIV((SV*)SvRV($arg));
		$var = INT2PTR($type,tmp);
	} else {
		croak(\"%s: %s is not of type %s\",
		    ${$ALIAS?\q[GvNAME(CvGV(cv))]:\qq[\"$pname\"]},
		    \"$var\", \"${(my $ntt=${ntype})=~s/_/::/g;\$ntt}\");
	}

#############################################################################
OUTPUT
T_UA_DATATYPE
	sv_setuv($arg, $var.typeIndex);
T_UA_QUALIFIEDNAME
	warn("%s: OUTPUT T_UA_QUALIFIEDNAME not implemented", __func__);
	sv_set_undef($arg);
T_UA_VARIABLEATTRIBUTES
	warn("%s: OUTPUT T_UA_VARIABLEATTRIBUTES not implemented", __func__);
	sv_set_undef($arg);
T_PTROBJ_SPECIAL
	sv_setref_pv($arg, \"${(my $ntt=${ntype})=~s/_/::/g;\$ntt}\", $var);

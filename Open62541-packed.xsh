/* Generated at 2020-02-19 04:53:51 */

/* Boolean */
static void XS_pack_UA_Boolean(SV *out, UA_Boolean in)  __attribute__((unused));
static UA_Boolean XS_unpack_UA_Boolean(SV *in)  __attribute__((unused));
/* implemented in Open62541.xs */

/* SByte */
static void XS_pack_UA_SByte(SV *out, UA_SByte in)  __attribute__((unused));
static UA_SByte XS_unpack_UA_SByte(SV *in)  __attribute__((unused));
/* implemented in Open62541.xs */

/* Byte */
static void XS_pack_UA_Byte(SV *out, UA_Byte in)  __attribute__((unused));
static UA_Byte XS_unpack_UA_Byte(SV *in)  __attribute__((unused));
/* implemented in Open62541.xs */

/* Int16 */
static void XS_pack_UA_Int16(SV *out, UA_Int16 in)  __attribute__((unused));
static UA_Int16 XS_unpack_UA_Int16(SV *in)  __attribute__((unused));
/* implemented in Open62541.xs */

/* UInt16 */
static void XS_pack_UA_UInt16(SV *out, UA_UInt16 in)  __attribute__((unused));
static UA_UInt16 XS_unpack_UA_UInt16(SV *in)  __attribute__((unused));
/* implemented in Open62541.xs */

/* Int32 */
static void XS_pack_UA_Int32(SV *out, UA_Int32 in)  __attribute__((unused));
static UA_Int32 XS_unpack_UA_Int32(SV *in)  __attribute__((unused));
/* implemented in Open62541.xs */

/* UInt32 */
static void XS_pack_UA_UInt32(SV *out, UA_UInt32 in)  __attribute__((unused));
static UA_UInt32 XS_unpack_UA_UInt32(SV *in)  __attribute__((unused));
/* implemented in Open62541.xs */

/* Int64 */
static void XS_pack_UA_Int64(SV *out, UA_Int64 in)  __attribute__((unused));
static UA_Int64 XS_unpack_UA_Int64(SV *in)  __attribute__((unused));
/* implemented in Open62541.xs */

/* UInt64 */
static void XS_pack_UA_UInt64(SV *out, UA_UInt64 in)  __attribute__((unused));
static UA_UInt64 XS_unpack_UA_UInt64(SV *in)  __attribute__((unused));
/* implemented in Open62541.xs */

/* Float */
static void XS_pack_UA_Float(SV *out, UA_Float in)  __attribute__((unused));
static UA_Float XS_unpack_UA_Float(SV *in)  __attribute__((unused));
static void XS_pack_UA_Float(SV *out, UA_Float in)
{
	/* TODO Implement builtin type conversion */
}
static UA_Float
XS_unpack_UA_Float(SV *in)
{
	/* TODO Implement builtin type conversion */
}

/* Double */
static void XS_pack_UA_Double(SV *out, UA_Double in)  __attribute__((unused));
static UA_Double XS_unpack_UA_Double(SV *in)  __attribute__((unused));
static void XS_pack_UA_Double(SV *out, UA_Double in)
{
	/* TODO Implement builtin type conversion */
}
static UA_Double
XS_unpack_UA_Double(SV *in)
{
	/* TODO Implement builtin type conversion */
}

/* String */
static void XS_pack_UA_String(SV *out, UA_String in)  __attribute__((unused));
static UA_String XS_unpack_UA_String(SV *in)  __attribute__((unused));
/* implemented in Open62541.xs */

/* DateTime */
static void XS_pack_UA_DateTime(SV *out, UA_DateTime in)  __attribute__((unused));
static UA_DateTime XS_unpack_UA_DateTime(SV *in)  __attribute__((unused));
static void XS_pack_UA_DateTime(SV *out, UA_DateTime in)
{
	/* TODO Implement builtin type conversion */
}
static UA_DateTime
XS_unpack_UA_DateTime(SV *in)
{
	/* TODO Implement builtin type conversion */
}

/* Guid */
static void XS_pack_UA_Guid(SV *out, UA_Guid in)  __attribute__((unused));
static UA_Guid XS_unpack_UA_Guid(SV *in)  __attribute__((unused));
static void XS_pack_UA_Guid(SV *out, UA_Guid in)
{
	/* TODO Implement builtin type conversion */
}
static UA_Guid
XS_unpack_UA_Guid(SV *in)
{
	/* TODO Implement builtin type conversion */
}

/* ByteString */
static void XS_pack_UA_ByteString(SV *out, UA_ByteString in)  __attribute__((unused));
static UA_ByteString XS_unpack_UA_ByteString(SV *in)  __attribute__((unused));
/* implemented in Open62541.xs */

/* XmlElement */
static void XS_pack_UA_XmlElement(SV *out, UA_XmlElement in)  __attribute__((unused));
static UA_XmlElement XS_unpack_UA_XmlElement(SV *in)  __attribute__((unused));
static void XS_pack_UA_XmlElement(SV *out, UA_XmlElement in)
{
	/* TODO Implement builtin type conversion */
}
static UA_XmlElement
XS_unpack_UA_XmlElement(SV *in)
{
	/* TODO Implement builtin type conversion */
}

/* NodeId */
static void XS_pack_UA_NodeId(SV *out, UA_NodeId in)  __attribute__((unused));
static UA_NodeId XS_unpack_UA_NodeId(SV *in)  __attribute__((unused));
/* implemented in Open62541.xs */

/* ExpandedNodeId */
static void XS_pack_UA_ExpandedNodeId(SV *out, UA_ExpandedNodeId in)  __attribute__((unused));
static UA_ExpandedNodeId XS_unpack_UA_ExpandedNodeId(SV *in)  __attribute__((unused));
static void XS_pack_UA_ExpandedNodeId(SV *out, UA_ExpandedNodeId in)
{
	/* TODO Implement builtin type conversion */
}
static UA_ExpandedNodeId
XS_unpack_UA_ExpandedNodeId(SV *in)
{
	/* TODO Implement builtin type conversion */
}

/* StatusCode */
static void XS_pack_UA_StatusCode(SV *out, UA_StatusCode in)  __attribute__((unused));
static UA_StatusCode XS_unpack_UA_StatusCode(SV *in)  __attribute__((unused));
static void XS_pack_UA_StatusCode(SV *out, UA_StatusCode in)
{
	/* TODO Implement builtin type conversion */
}
static UA_StatusCode
XS_unpack_UA_StatusCode(SV *in)
{
	/* TODO Implement builtin type conversion */
}

/* QualifiedName */
static void XS_pack_UA_QualifiedName(SV *out, UA_QualifiedName in)  __attribute__((unused));
static UA_QualifiedName XS_unpack_UA_QualifiedName(SV *in)  __attribute__((unused));
/* implemented in Open62541.xs */

/* LocalizedText */
static void XS_pack_UA_LocalizedText(SV *out, UA_LocalizedText in)  __attribute__((unused));
static UA_LocalizedText XS_unpack_UA_LocalizedText(SV *in)  __attribute__((unused));
/* implemented in Open62541.xs */

/* ExtensionObject */
static void XS_pack_UA_ExtensionObject(SV *out, UA_ExtensionObject in)  __attribute__((unused));
static UA_ExtensionObject XS_unpack_UA_ExtensionObject(SV *in)  __attribute__((unused));
static void XS_pack_UA_ExtensionObject(SV *out, UA_ExtensionObject in)
{
	/* TODO Implement builtin type conversion */
}
static UA_ExtensionObject
XS_unpack_UA_ExtensionObject(SV *in)
{
	/* TODO Implement builtin type conversion */
}

/* DataValue */
static void XS_pack_UA_DataValue(SV *out, UA_DataValue in)  __attribute__((unused));
static UA_DataValue XS_unpack_UA_DataValue(SV *in)  __attribute__((unused));
static void XS_pack_UA_DataValue(SV *out, UA_DataValue in)
{
	/* TODO Implement builtin type conversion */
}
static UA_DataValue
XS_unpack_UA_DataValue(SV *in)
{
	/* TODO Implement builtin type conversion */
}

/* Variant */
static void XS_pack_UA_Variant(SV *out, UA_Variant in)  __attribute__((unused));
static UA_Variant XS_unpack_UA_Variant(SV *in)  __attribute__((unused));
static void XS_pack_UA_Variant(SV *out, UA_Variant in)
{
	/* TODO Implement builtin type conversion */
}
static UA_Variant
XS_unpack_UA_Variant(SV *in)
{
	/* TODO Implement builtin type conversion */
}

/* DiagnosticInfo */
static void XS_pack_UA_DiagnosticInfo(SV *out, UA_DiagnosticInfo in)  __attribute__((unused));
static UA_DiagnosticInfo XS_unpack_UA_DiagnosticInfo(SV *in)  __attribute__((unused));
static void XS_pack_UA_DiagnosticInfo(SV *out, UA_DiagnosticInfo in)
{
	/* TODO Implement builtin type conversion */
}
static UA_DiagnosticInfo
XS_unpack_UA_DiagnosticInfo(SV *in)
{
	/* TODO Implement builtin type conversion */
}

/* NodeClass */
static void XS_pack_UA_NodeClass(SV *out, UA_NodeClass in)  __attribute__((unused));
static void
XS_pack_UA_NodeClass(SV *out, UA_NodeClass in)
{
	/* TODO implement EnumerationType conversion */

}

static UA_NodeClass XS_unpack_UA_NodeClass(SV *in)  __attribute__((unused));
static UA_NodeClass
XS_unpack_UA_NodeClass(SV *in)
{
	/* TODO implement EnumerationType conversion */
}

/* Argument */
static void XS_pack_UA_Argument(SV *out, UA_Argument in)  __attribute__((unused));
static void
XS_pack_UA_Argument(SV *out, UA_Argument in)
{
	HV *hash = newHV();

	SV *nameSV = newSV(0);
	XS_pack_UA_String(nameSV, in.name);
	hv_stores(hash, "Argument_name", nameSV);

	SV *dataTypeSV = newSV(0);
	XS_pack_UA_NodeId(dataTypeSV, in.dataType);
	hv_stores(hash, "Argument_dataType", dataTypeSV);

	SV *valueRankSV = newSV(0);
	XS_pack_UA_Int32(valueRankSV, in.valueRank);
	hv_stores(hash, "Argument_valueRank", valueRankSV);

	AV *arrayDimensionsArray = (AV*) sv_2mortal((SV*)newAV());
	size_t arrayDimensionsI;
	for(arrayDimensionsI = 0; arrayDimensionsI < in.arrayDimensionsSize; arrayDimensionsI++) {
		SV *element = newSV(0);
		XS_pack_UA_UInt32(element, in.arrayDimensions[arrayDimensionsI]);
		av_push(arrayDimensionsArray, element);
	}
	hv_stores(hash, "Argument_arrayDimensions", newRV_inc((SV*)arrayDimensionsArray));

	SV *descriptionSV = newSV(0);
	XS_pack_UA_LocalizedText(descriptionSV, in.description);
	hv_stores(hash, "Argument_description", descriptionSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_Argument XS_unpack_UA_Argument(SV *in)  __attribute__((unused));
static UA_Argument
XS_unpack_UA_Argument(SV *in)
{
	UA_Argument out;
	SV **value;
	HV *hv;

	UA_Argument_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "Argument_name", 0);
	if (value != NULL)
		out.name = XS_unpack_UA_String(*value);

	value = hv_fetchs(hv, "Argument_dataType", 0);
	if (value != NULL)
		out.dataType = XS_unpack_UA_NodeId(*value);

	value = hv_fetchs(hv, "Argument_valueRank", 0);
	if (value != NULL)
		out.valueRank = XS_unpack_UA_Int32(*value);

	/* TODO Implement array conversion for field arrayDimensions */

	value = hv_fetchs(hv, "Argument_description", 0);
	if (value != NULL)
		out.description = XS_unpack_UA_LocalizedText(*value);

	return out;
}

/* EnumValueType */
static void XS_pack_UA_EnumValueType(SV *out, UA_EnumValueType in)  __attribute__((unused));
static void
XS_pack_UA_EnumValueType(SV *out, UA_EnumValueType in)
{
	HV *hash = newHV();

	SV *valueSV = newSV(0);
	XS_pack_UA_Int64(valueSV, in.value);
	hv_stores(hash, "EnumValueType_value", valueSV);

	SV *displayNameSV = newSV(0);
	XS_pack_UA_LocalizedText(displayNameSV, in.displayName);
	hv_stores(hash, "EnumValueType_displayName", displayNameSV);

	SV *descriptionSV = newSV(0);
	XS_pack_UA_LocalizedText(descriptionSV, in.description);
	hv_stores(hash, "EnumValueType_description", descriptionSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_EnumValueType XS_unpack_UA_EnumValueType(SV *in)  __attribute__((unused));
static UA_EnumValueType
XS_unpack_UA_EnumValueType(SV *in)
{
	UA_EnumValueType out;
	SV **value;
	HV *hv;

	UA_EnumValueType_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "EnumValueType_value", 0);
	if (value != NULL)
		out.value = XS_unpack_UA_Int64(*value);

	value = hv_fetchs(hv, "EnumValueType_displayName", 0);
	if (value != NULL)
		out.displayName = XS_unpack_UA_LocalizedText(*value);

	value = hv_fetchs(hv, "EnumValueType_description", 0);
	if (value != NULL)
		out.description = XS_unpack_UA_LocalizedText(*value);

	return out;
}

/* Duration */
static void XS_pack_UA_Duration(SV *out, UA_Duration in)  __attribute__((unused));
static void
XS_pack_UA_Duration(SV *out, UA_Duration in)
{
	/* TODO implement OpaqueType conversion */

}

static UA_Duration XS_unpack_UA_Duration(SV *in)  __attribute__((unused));
static UA_Duration
XS_unpack_UA_Duration(SV *in)
{
	/* TODO implement OpaqueType conversion */
}

/* UtcTime */
static void XS_pack_UA_UtcTime(SV *out, UA_UtcTime in)  __attribute__((unused));
static void
XS_pack_UA_UtcTime(SV *out, UA_UtcTime in)
{
	/* TODO implement OpaqueType conversion */

}

static UA_UtcTime XS_unpack_UA_UtcTime(SV *in)  __attribute__((unused));
static UA_UtcTime
XS_unpack_UA_UtcTime(SV *in)
{
	/* TODO implement OpaqueType conversion */
}

/* LocaleId */
static void XS_pack_UA_LocaleId(SV *out, UA_LocaleId in)  __attribute__((unused));
static void
XS_pack_UA_LocaleId(SV *out, UA_LocaleId in)
{
	/* TODO implement OpaqueType conversion */

}

static UA_LocaleId XS_unpack_UA_LocaleId(SV *in)  __attribute__((unused));
static UA_LocaleId
XS_unpack_UA_LocaleId(SV *in)
{
	/* TODO implement OpaqueType conversion */
}

/* ApplicationType */
static void XS_pack_UA_ApplicationType(SV *out, UA_ApplicationType in)  __attribute__((unused));
static void
XS_pack_UA_ApplicationType(SV *out, UA_ApplicationType in)
{
	/* TODO implement EnumerationType conversion */

}

static UA_ApplicationType XS_unpack_UA_ApplicationType(SV *in)  __attribute__((unused));
static UA_ApplicationType
XS_unpack_UA_ApplicationType(SV *in)
{
	/* TODO implement EnumerationType conversion */
}

/* ApplicationDescription */
static void XS_pack_UA_ApplicationDescription(SV *out, UA_ApplicationDescription in)  __attribute__((unused));
static void
XS_pack_UA_ApplicationDescription(SV *out, UA_ApplicationDescription in)
{
	HV *hash = newHV();

	SV *applicationUriSV = newSV(0);
	XS_pack_UA_String(applicationUriSV, in.applicationUri);
	hv_stores(hash, "ApplicationDescription_applicationUri", applicationUriSV);

	SV *productUriSV = newSV(0);
	XS_pack_UA_String(productUriSV, in.productUri);
	hv_stores(hash, "ApplicationDescription_productUri", productUriSV);

	SV *applicationNameSV = newSV(0);
	XS_pack_UA_LocalizedText(applicationNameSV, in.applicationName);
	hv_stores(hash, "ApplicationDescription_applicationName", applicationNameSV);

	SV *applicationTypeSV = newSV(0);
	XS_pack_UA_ApplicationType(applicationTypeSV, in.applicationType);
	hv_stores(hash, "ApplicationDescription_applicationType", applicationTypeSV);

	SV *gatewayServerUriSV = newSV(0);
	XS_pack_UA_String(gatewayServerUriSV, in.gatewayServerUri);
	hv_stores(hash, "ApplicationDescription_gatewayServerUri", gatewayServerUriSV);

	SV *discoveryProfileUriSV = newSV(0);
	XS_pack_UA_String(discoveryProfileUriSV, in.discoveryProfileUri);
	hv_stores(hash, "ApplicationDescription_discoveryProfileUri", discoveryProfileUriSV);

	AV *discoveryUrlsArray = (AV*) sv_2mortal((SV*)newAV());
	size_t discoveryUrlsI;
	for(discoveryUrlsI = 0; discoveryUrlsI < in.discoveryUrlsSize; discoveryUrlsI++) {
		SV *element = newSV(0);
		XS_pack_UA_String(element, in.discoveryUrls[discoveryUrlsI]);
		av_push(discoveryUrlsArray, element);
	}
	hv_stores(hash, "ApplicationDescription_discoveryUrls", newRV_inc((SV*)discoveryUrlsArray));

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_ApplicationDescription XS_unpack_UA_ApplicationDescription(SV *in)  __attribute__((unused));
static UA_ApplicationDescription
XS_unpack_UA_ApplicationDescription(SV *in)
{
	UA_ApplicationDescription out;
	SV **value;
	HV *hv;

	UA_ApplicationDescription_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "ApplicationDescription_applicationUri", 0);
	if (value != NULL)
		out.applicationUri = XS_unpack_UA_String(*value);

	value = hv_fetchs(hv, "ApplicationDescription_productUri", 0);
	if (value != NULL)
		out.productUri = XS_unpack_UA_String(*value);

	value = hv_fetchs(hv, "ApplicationDescription_applicationName", 0);
	if (value != NULL)
		out.applicationName = XS_unpack_UA_LocalizedText(*value);

	value = hv_fetchs(hv, "ApplicationDescription_applicationType", 0);
	if (value != NULL)
		out.applicationType = XS_unpack_UA_ApplicationType(*value);

	value = hv_fetchs(hv, "ApplicationDescription_gatewayServerUri", 0);
	if (value != NULL)
		out.gatewayServerUri = XS_unpack_UA_String(*value);

	value = hv_fetchs(hv, "ApplicationDescription_discoveryProfileUri", 0);
	if (value != NULL)
		out.discoveryProfileUri = XS_unpack_UA_String(*value);

	/* TODO Implement array conversion for field discoveryUrls */

	return out;
}

/* RequestHeader */
static void XS_pack_UA_RequestHeader(SV *out, UA_RequestHeader in)  __attribute__((unused));
static void
XS_pack_UA_RequestHeader(SV *out, UA_RequestHeader in)
{
	HV *hash = newHV();

	SV *authenticationTokenSV = newSV(0);
	XS_pack_UA_NodeId(authenticationTokenSV, in.authenticationToken);
	hv_stores(hash, "RequestHeader_authenticationToken", authenticationTokenSV);

	SV *timestampSV = newSV(0);
	XS_pack_UA_DateTime(timestampSV, in.timestamp);
	hv_stores(hash, "RequestHeader_timestamp", timestampSV);

	SV *requestHandleSV = newSV(0);
	XS_pack_UA_UInt32(requestHandleSV, in.requestHandle);
	hv_stores(hash, "RequestHeader_requestHandle", requestHandleSV);

	SV *returnDiagnosticsSV = newSV(0);
	XS_pack_UA_UInt32(returnDiagnosticsSV, in.returnDiagnostics);
	hv_stores(hash, "RequestHeader_returnDiagnostics", returnDiagnosticsSV);

	SV *auditEntryIdSV = newSV(0);
	XS_pack_UA_String(auditEntryIdSV, in.auditEntryId);
	hv_stores(hash, "RequestHeader_auditEntryId", auditEntryIdSV);

	SV *timeoutHintSV = newSV(0);
	XS_pack_UA_UInt32(timeoutHintSV, in.timeoutHint);
	hv_stores(hash, "RequestHeader_timeoutHint", timeoutHintSV);

	SV *additionalHeaderSV = newSV(0);
	XS_pack_UA_ExtensionObject(additionalHeaderSV, in.additionalHeader);
	hv_stores(hash, "RequestHeader_additionalHeader", additionalHeaderSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_RequestHeader XS_unpack_UA_RequestHeader(SV *in)  __attribute__((unused));
static UA_RequestHeader
XS_unpack_UA_RequestHeader(SV *in)
{
	UA_RequestHeader out;
	SV **value;
	HV *hv;

	UA_RequestHeader_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "RequestHeader_authenticationToken", 0);
	if (value != NULL)
		out.authenticationToken = XS_unpack_UA_NodeId(*value);

	value = hv_fetchs(hv, "RequestHeader_timestamp", 0);
	if (value != NULL)
		out.timestamp = XS_unpack_UA_DateTime(*value);

	value = hv_fetchs(hv, "RequestHeader_requestHandle", 0);
	if (value != NULL)
		out.requestHandle = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "RequestHeader_returnDiagnostics", 0);
	if (value != NULL)
		out.returnDiagnostics = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "RequestHeader_auditEntryId", 0);
	if (value != NULL)
		out.auditEntryId = XS_unpack_UA_String(*value);

	value = hv_fetchs(hv, "RequestHeader_timeoutHint", 0);
	if (value != NULL)
		out.timeoutHint = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "RequestHeader_additionalHeader", 0);
	if (value != NULL)
		out.additionalHeader = XS_unpack_UA_ExtensionObject(*value);

	return out;
}

/* ResponseHeader */
static void XS_pack_UA_ResponseHeader(SV *out, UA_ResponseHeader in)  __attribute__((unused));
static void
XS_pack_UA_ResponseHeader(SV *out, UA_ResponseHeader in)
{
	HV *hash = newHV();

	SV *timestampSV = newSV(0);
	XS_pack_UA_DateTime(timestampSV, in.timestamp);
	hv_stores(hash, "ResponseHeader_timestamp", timestampSV);

	SV *requestHandleSV = newSV(0);
	XS_pack_UA_UInt32(requestHandleSV, in.requestHandle);
	hv_stores(hash, "ResponseHeader_requestHandle", requestHandleSV);

	SV *serviceResultSV = newSV(0);
	XS_pack_UA_StatusCode(serviceResultSV, in.serviceResult);
	hv_stores(hash, "ResponseHeader_serviceResult", serviceResultSV);

	SV *serviceDiagnosticsSV = newSV(0);
	XS_pack_UA_DiagnosticInfo(serviceDiagnosticsSV, in.serviceDiagnostics);
	hv_stores(hash, "ResponseHeader_serviceDiagnostics", serviceDiagnosticsSV);

	AV *stringTableArray = (AV*) sv_2mortal((SV*)newAV());
	size_t stringTableI;
	for(stringTableI = 0; stringTableI < in.stringTableSize; stringTableI++) {
		SV *element = newSV(0);
		XS_pack_UA_String(element, in.stringTable[stringTableI]);
		av_push(stringTableArray, element);
	}
	hv_stores(hash, "ResponseHeader_stringTable", newRV_inc((SV*)stringTableArray));

	SV *additionalHeaderSV = newSV(0);
	XS_pack_UA_ExtensionObject(additionalHeaderSV, in.additionalHeader);
	hv_stores(hash, "ResponseHeader_additionalHeader", additionalHeaderSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_ResponseHeader XS_unpack_UA_ResponseHeader(SV *in)  __attribute__((unused));
static UA_ResponseHeader
XS_unpack_UA_ResponseHeader(SV *in)
{
	UA_ResponseHeader out;
	SV **value;
	HV *hv;

	UA_ResponseHeader_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "ResponseHeader_timestamp", 0);
	if (value != NULL)
		out.timestamp = XS_unpack_UA_DateTime(*value);

	value = hv_fetchs(hv, "ResponseHeader_requestHandle", 0);
	if (value != NULL)
		out.requestHandle = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "ResponseHeader_serviceResult", 0);
	if (value != NULL)
		out.serviceResult = XS_unpack_UA_StatusCode(*value);

	value = hv_fetchs(hv, "ResponseHeader_serviceDiagnostics", 0);
	if (value != NULL)
		out.serviceDiagnostics = XS_unpack_UA_DiagnosticInfo(*value);

	/* TODO Implement array conversion for field stringTable */

	value = hv_fetchs(hv, "ResponseHeader_additionalHeader", 0);
	if (value != NULL)
		out.additionalHeader = XS_unpack_UA_ExtensionObject(*value);

	return out;
}

/* ServiceFault */
static void XS_pack_UA_ServiceFault(SV *out, UA_ServiceFault in)  __attribute__((unused));
static void
XS_pack_UA_ServiceFault(SV *out, UA_ServiceFault in)
{
	HV *hash = newHV();

	SV *responseHeaderSV = newSV(0);
	XS_pack_UA_ResponseHeader(responseHeaderSV, in.responseHeader);
	hv_stores(hash, "ServiceFault_responseHeader", responseHeaderSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_ServiceFault XS_unpack_UA_ServiceFault(SV *in)  __attribute__((unused));
static UA_ServiceFault
XS_unpack_UA_ServiceFault(SV *in)
{
	UA_ServiceFault out;
	SV **value;
	HV *hv;

	UA_ServiceFault_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "ServiceFault_responseHeader", 0);
	if (value != NULL)
		out.responseHeader = XS_unpack_UA_ResponseHeader(*value);

	return out;
}

/* FindServersRequest */
static void XS_pack_UA_FindServersRequest(SV *out, UA_FindServersRequest in)  __attribute__((unused));
static void
XS_pack_UA_FindServersRequest(SV *out, UA_FindServersRequest in)
{
	HV *hash = newHV();

	SV *requestHeaderSV = newSV(0);
	XS_pack_UA_RequestHeader(requestHeaderSV, in.requestHeader);
	hv_stores(hash, "FindServersRequest_requestHeader", requestHeaderSV);

	SV *endpointUrlSV = newSV(0);
	XS_pack_UA_String(endpointUrlSV, in.endpointUrl);
	hv_stores(hash, "FindServersRequest_endpointUrl", endpointUrlSV);

	AV *localeIdsArray = (AV*) sv_2mortal((SV*)newAV());
	size_t localeIdsI;
	for(localeIdsI = 0; localeIdsI < in.localeIdsSize; localeIdsI++) {
		SV *element = newSV(0);
		XS_pack_UA_String(element, in.localeIds[localeIdsI]);
		av_push(localeIdsArray, element);
	}
	hv_stores(hash, "FindServersRequest_localeIds", newRV_inc((SV*)localeIdsArray));

	AV *serverUrisArray = (AV*) sv_2mortal((SV*)newAV());
	size_t serverUrisI;
	for(serverUrisI = 0; serverUrisI < in.serverUrisSize; serverUrisI++) {
		SV *element = newSV(0);
		XS_pack_UA_String(element, in.serverUris[serverUrisI]);
		av_push(serverUrisArray, element);
	}
	hv_stores(hash, "FindServersRequest_serverUris", newRV_inc((SV*)serverUrisArray));

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_FindServersRequest XS_unpack_UA_FindServersRequest(SV *in)  __attribute__((unused));
static UA_FindServersRequest
XS_unpack_UA_FindServersRequest(SV *in)
{
	UA_FindServersRequest out;
	SV **value;
	HV *hv;

	UA_FindServersRequest_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "FindServersRequest_requestHeader", 0);
	if (value != NULL)
		out.requestHeader = XS_unpack_UA_RequestHeader(*value);

	value = hv_fetchs(hv, "FindServersRequest_endpointUrl", 0);
	if (value != NULL)
		out.endpointUrl = XS_unpack_UA_String(*value);

	/* TODO Implement array conversion for field localeIds */

	/* TODO Implement array conversion for field serverUris */

	return out;
}

/* FindServersResponse */
static void XS_pack_UA_FindServersResponse(SV *out, UA_FindServersResponse in)  __attribute__((unused));
static void
XS_pack_UA_FindServersResponse(SV *out, UA_FindServersResponse in)
{
	HV *hash = newHV();

	SV *responseHeaderSV = newSV(0);
	XS_pack_UA_ResponseHeader(responseHeaderSV, in.responseHeader);
	hv_stores(hash, "FindServersResponse_responseHeader", responseHeaderSV);

	AV *serversArray = (AV*) sv_2mortal((SV*)newAV());
	size_t serversI;
	for(serversI = 0; serversI < in.serversSize; serversI++) {
		SV *element = newSV(0);
		XS_pack_UA_ApplicationDescription(element, in.servers[serversI]);
		av_push(serversArray, element);
	}
	hv_stores(hash, "FindServersResponse_servers", newRV_inc((SV*)serversArray));

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_FindServersResponse XS_unpack_UA_FindServersResponse(SV *in)  __attribute__((unused));
static UA_FindServersResponse
XS_unpack_UA_FindServersResponse(SV *in)
{
	UA_FindServersResponse out;
	SV **value;
	HV *hv;

	UA_FindServersResponse_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "FindServersResponse_responseHeader", 0);
	if (value != NULL)
		out.responseHeader = XS_unpack_UA_ResponseHeader(*value);

	/* TODO Implement array conversion for field servers */

	return out;
}

/* ServerOnNetwork */
static void XS_pack_UA_ServerOnNetwork(SV *out, UA_ServerOnNetwork in)  __attribute__((unused));
static void
XS_pack_UA_ServerOnNetwork(SV *out, UA_ServerOnNetwork in)
{
	HV *hash = newHV();

	SV *recordIdSV = newSV(0);
	XS_pack_UA_UInt32(recordIdSV, in.recordId);
	hv_stores(hash, "ServerOnNetwork_recordId", recordIdSV);

	SV *serverNameSV = newSV(0);
	XS_pack_UA_String(serverNameSV, in.serverName);
	hv_stores(hash, "ServerOnNetwork_serverName", serverNameSV);

	SV *discoveryUrlSV = newSV(0);
	XS_pack_UA_String(discoveryUrlSV, in.discoveryUrl);
	hv_stores(hash, "ServerOnNetwork_discoveryUrl", discoveryUrlSV);

	AV *serverCapabilitiesArray = (AV*) sv_2mortal((SV*)newAV());
	size_t serverCapabilitiesI;
	for(serverCapabilitiesI = 0; serverCapabilitiesI < in.serverCapabilitiesSize; serverCapabilitiesI++) {
		SV *element = newSV(0);
		XS_pack_UA_String(element, in.serverCapabilities[serverCapabilitiesI]);
		av_push(serverCapabilitiesArray, element);
	}
	hv_stores(hash, "ServerOnNetwork_serverCapabilities", newRV_inc((SV*)serverCapabilitiesArray));

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_ServerOnNetwork XS_unpack_UA_ServerOnNetwork(SV *in)  __attribute__((unused));
static UA_ServerOnNetwork
XS_unpack_UA_ServerOnNetwork(SV *in)
{
	UA_ServerOnNetwork out;
	SV **value;
	HV *hv;

	UA_ServerOnNetwork_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "ServerOnNetwork_recordId", 0);
	if (value != NULL)
		out.recordId = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "ServerOnNetwork_serverName", 0);
	if (value != NULL)
		out.serverName = XS_unpack_UA_String(*value);

	value = hv_fetchs(hv, "ServerOnNetwork_discoveryUrl", 0);
	if (value != NULL)
		out.discoveryUrl = XS_unpack_UA_String(*value);

	/* TODO Implement array conversion for field serverCapabilities */

	return out;
}

/* FindServersOnNetworkRequest */
static void XS_pack_UA_FindServersOnNetworkRequest(SV *out, UA_FindServersOnNetworkRequest in)  __attribute__((unused));
static void
XS_pack_UA_FindServersOnNetworkRequest(SV *out, UA_FindServersOnNetworkRequest in)
{
	HV *hash = newHV();

	SV *requestHeaderSV = newSV(0);
	XS_pack_UA_RequestHeader(requestHeaderSV, in.requestHeader);
	hv_stores(hash, "FindServersOnNetworkRequest_requestHeader", requestHeaderSV);

	SV *startingRecordIdSV = newSV(0);
	XS_pack_UA_UInt32(startingRecordIdSV, in.startingRecordId);
	hv_stores(hash, "FindServersOnNetworkRequest_startingRecordId", startingRecordIdSV);

	SV *maxRecordsToReturnSV = newSV(0);
	XS_pack_UA_UInt32(maxRecordsToReturnSV, in.maxRecordsToReturn);
	hv_stores(hash, "FindServersOnNetworkRequest_maxRecordsToReturn", maxRecordsToReturnSV);

	AV *serverCapabilityFilterArray = (AV*) sv_2mortal((SV*)newAV());
	size_t serverCapabilityFilterI;
	for(serverCapabilityFilterI = 0; serverCapabilityFilterI < in.serverCapabilityFilterSize; serverCapabilityFilterI++) {
		SV *element = newSV(0);
		XS_pack_UA_String(element, in.serverCapabilityFilter[serverCapabilityFilterI]);
		av_push(serverCapabilityFilterArray, element);
	}
	hv_stores(hash, "FindServersOnNetworkRequest_serverCapabilityFilter", newRV_inc((SV*)serverCapabilityFilterArray));

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_FindServersOnNetworkRequest XS_unpack_UA_FindServersOnNetworkRequest(SV *in)  __attribute__((unused));
static UA_FindServersOnNetworkRequest
XS_unpack_UA_FindServersOnNetworkRequest(SV *in)
{
	UA_FindServersOnNetworkRequest out;
	SV **value;
	HV *hv;

	UA_FindServersOnNetworkRequest_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "FindServersOnNetworkRequest_requestHeader", 0);
	if (value != NULL)
		out.requestHeader = XS_unpack_UA_RequestHeader(*value);

	value = hv_fetchs(hv, "FindServersOnNetworkRequest_startingRecordId", 0);
	if (value != NULL)
		out.startingRecordId = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "FindServersOnNetworkRequest_maxRecordsToReturn", 0);
	if (value != NULL)
		out.maxRecordsToReturn = XS_unpack_UA_UInt32(*value);

	/* TODO Implement array conversion for field serverCapabilityFilter */

	return out;
}

/* FindServersOnNetworkResponse */
static void XS_pack_UA_FindServersOnNetworkResponse(SV *out, UA_FindServersOnNetworkResponse in)  __attribute__((unused));
static void
XS_pack_UA_FindServersOnNetworkResponse(SV *out, UA_FindServersOnNetworkResponse in)
{
	HV *hash = newHV();

	SV *responseHeaderSV = newSV(0);
	XS_pack_UA_ResponseHeader(responseHeaderSV, in.responseHeader);
	hv_stores(hash, "FindServersOnNetworkResponse_responseHeader", responseHeaderSV);

	SV *lastCounterResetTimeSV = newSV(0);
	XS_pack_UA_DateTime(lastCounterResetTimeSV, in.lastCounterResetTime);
	hv_stores(hash, "FindServersOnNetworkResponse_lastCounterResetTime", lastCounterResetTimeSV);

	AV *serversArray = (AV*) sv_2mortal((SV*)newAV());
	size_t serversI;
	for(serversI = 0; serversI < in.serversSize; serversI++) {
		SV *element = newSV(0);
		XS_pack_UA_ServerOnNetwork(element, in.servers[serversI]);
		av_push(serversArray, element);
	}
	hv_stores(hash, "FindServersOnNetworkResponse_servers", newRV_inc((SV*)serversArray));

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_FindServersOnNetworkResponse XS_unpack_UA_FindServersOnNetworkResponse(SV *in)  __attribute__((unused));
static UA_FindServersOnNetworkResponse
XS_unpack_UA_FindServersOnNetworkResponse(SV *in)
{
	UA_FindServersOnNetworkResponse out;
	SV **value;
	HV *hv;

	UA_FindServersOnNetworkResponse_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "FindServersOnNetworkResponse_responseHeader", 0);
	if (value != NULL)
		out.responseHeader = XS_unpack_UA_ResponseHeader(*value);

	value = hv_fetchs(hv, "FindServersOnNetworkResponse_lastCounterResetTime", 0);
	if (value != NULL)
		out.lastCounterResetTime = XS_unpack_UA_DateTime(*value);

	/* TODO Implement array conversion for field servers */

	return out;
}

/* MessageSecurityMode */
static void XS_pack_UA_MessageSecurityMode(SV *out, UA_MessageSecurityMode in)  __attribute__((unused));
static void
XS_pack_UA_MessageSecurityMode(SV *out, UA_MessageSecurityMode in)
{
	/* TODO implement EnumerationType conversion */

}

static UA_MessageSecurityMode XS_unpack_UA_MessageSecurityMode(SV *in)  __attribute__((unused));
static UA_MessageSecurityMode
XS_unpack_UA_MessageSecurityMode(SV *in)
{
	/* TODO implement EnumerationType conversion */
}

/* UserTokenType */
static void XS_pack_UA_UserTokenType(SV *out, UA_UserTokenType in)  __attribute__((unused));
static void
XS_pack_UA_UserTokenType(SV *out, UA_UserTokenType in)
{
	/* TODO implement EnumerationType conversion */

}

static UA_UserTokenType XS_unpack_UA_UserTokenType(SV *in)  __attribute__((unused));
static UA_UserTokenType
XS_unpack_UA_UserTokenType(SV *in)
{
	/* TODO implement EnumerationType conversion */
}

/* UserTokenPolicy */
static void XS_pack_UA_UserTokenPolicy(SV *out, UA_UserTokenPolicy in)  __attribute__((unused));
static void
XS_pack_UA_UserTokenPolicy(SV *out, UA_UserTokenPolicy in)
{
	HV *hash = newHV();

	SV *policyIdSV = newSV(0);
	XS_pack_UA_String(policyIdSV, in.policyId);
	hv_stores(hash, "UserTokenPolicy_policyId", policyIdSV);

	SV *tokenTypeSV = newSV(0);
	XS_pack_UA_UserTokenType(tokenTypeSV, in.tokenType);
	hv_stores(hash, "UserTokenPolicy_tokenType", tokenTypeSV);

	SV *issuedTokenTypeSV = newSV(0);
	XS_pack_UA_String(issuedTokenTypeSV, in.issuedTokenType);
	hv_stores(hash, "UserTokenPolicy_issuedTokenType", issuedTokenTypeSV);

	SV *issuerEndpointUrlSV = newSV(0);
	XS_pack_UA_String(issuerEndpointUrlSV, in.issuerEndpointUrl);
	hv_stores(hash, "UserTokenPolicy_issuerEndpointUrl", issuerEndpointUrlSV);

	SV *securityPolicyUriSV = newSV(0);
	XS_pack_UA_String(securityPolicyUriSV, in.securityPolicyUri);
	hv_stores(hash, "UserTokenPolicy_securityPolicyUri", securityPolicyUriSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_UserTokenPolicy XS_unpack_UA_UserTokenPolicy(SV *in)  __attribute__((unused));
static UA_UserTokenPolicy
XS_unpack_UA_UserTokenPolicy(SV *in)
{
	UA_UserTokenPolicy out;
	SV **value;
	HV *hv;

	UA_UserTokenPolicy_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "UserTokenPolicy_policyId", 0);
	if (value != NULL)
		out.policyId = XS_unpack_UA_String(*value);

	value = hv_fetchs(hv, "UserTokenPolicy_tokenType", 0);
	if (value != NULL)
		out.tokenType = XS_unpack_UA_UserTokenType(*value);

	value = hv_fetchs(hv, "UserTokenPolicy_issuedTokenType", 0);
	if (value != NULL)
		out.issuedTokenType = XS_unpack_UA_String(*value);

	value = hv_fetchs(hv, "UserTokenPolicy_issuerEndpointUrl", 0);
	if (value != NULL)
		out.issuerEndpointUrl = XS_unpack_UA_String(*value);

	value = hv_fetchs(hv, "UserTokenPolicy_securityPolicyUri", 0);
	if (value != NULL)
		out.securityPolicyUri = XS_unpack_UA_String(*value);

	return out;
}

/* EndpointDescription */
static void XS_pack_UA_EndpointDescription(SV *out, UA_EndpointDescription in)  __attribute__((unused));
static void
XS_pack_UA_EndpointDescription(SV *out, UA_EndpointDescription in)
{
	HV *hash = newHV();

	SV *endpointUrlSV = newSV(0);
	XS_pack_UA_String(endpointUrlSV, in.endpointUrl);
	hv_stores(hash, "EndpointDescription_endpointUrl", endpointUrlSV);

	SV *serverSV = newSV(0);
	XS_pack_UA_ApplicationDescription(serverSV, in.server);
	hv_stores(hash, "EndpointDescription_server", serverSV);

	SV *serverCertificateSV = newSV(0);
	XS_pack_UA_ByteString(serverCertificateSV, in.serverCertificate);
	hv_stores(hash, "EndpointDescription_serverCertificate", serverCertificateSV);

	SV *securityModeSV = newSV(0);
	XS_pack_UA_MessageSecurityMode(securityModeSV, in.securityMode);
	hv_stores(hash, "EndpointDescription_securityMode", securityModeSV);

	SV *securityPolicyUriSV = newSV(0);
	XS_pack_UA_String(securityPolicyUriSV, in.securityPolicyUri);
	hv_stores(hash, "EndpointDescription_securityPolicyUri", securityPolicyUriSV);

	AV *userIdentityTokensArray = (AV*) sv_2mortal((SV*)newAV());
	size_t userIdentityTokensI;
	for(userIdentityTokensI = 0; userIdentityTokensI < in.userIdentityTokensSize; userIdentityTokensI++) {
		SV *element = newSV(0);
		XS_pack_UA_UserTokenPolicy(element, in.userIdentityTokens[userIdentityTokensI]);
		av_push(userIdentityTokensArray, element);
	}
	hv_stores(hash, "EndpointDescription_userIdentityTokens", newRV_inc((SV*)userIdentityTokensArray));

	SV *transportProfileUriSV = newSV(0);
	XS_pack_UA_String(transportProfileUriSV, in.transportProfileUri);
	hv_stores(hash, "EndpointDescription_transportProfileUri", transportProfileUriSV);

	SV *securityLevelSV = newSV(0);
	XS_pack_UA_Byte(securityLevelSV, in.securityLevel);
	hv_stores(hash, "EndpointDescription_securityLevel", securityLevelSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_EndpointDescription XS_unpack_UA_EndpointDescription(SV *in)  __attribute__((unused));
static UA_EndpointDescription
XS_unpack_UA_EndpointDescription(SV *in)
{
	UA_EndpointDescription out;
	SV **value;
	HV *hv;

	UA_EndpointDescription_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "EndpointDescription_endpointUrl", 0);
	if (value != NULL)
		out.endpointUrl = XS_unpack_UA_String(*value);

	value = hv_fetchs(hv, "EndpointDescription_server", 0);
	if (value != NULL)
		out.server = XS_unpack_UA_ApplicationDescription(*value);

	value = hv_fetchs(hv, "EndpointDescription_serverCertificate", 0);
	if (value != NULL)
		out.serverCertificate = XS_unpack_UA_ByteString(*value);

	value = hv_fetchs(hv, "EndpointDescription_securityMode", 0);
	if (value != NULL)
		out.securityMode = XS_unpack_UA_MessageSecurityMode(*value);

	value = hv_fetchs(hv, "EndpointDescription_securityPolicyUri", 0);
	if (value != NULL)
		out.securityPolicyUri = XS_unpack_UA_String(*value);

	/* TODO Implement array conversion for field userIdentityTokens */

	value = hv_fetchs(hv, "EndpointDescription_transportProfileUri", 0);
	if (value != NULL)
		out.transportProfileUri = XS_unpack_UA_String(*value);

	value = hv_fetchs(hv, "EndpointDescription_securityLevel", 0);
	if (value != NULL)
		out.securityLevel = XS_unpack_UA_Byte(*value);

	return out;
}

/* GetEndpointsRequest */
static void XS_pack_UA_GetEndpointsRequest(SV *out, UA_GetEndpointsRequest in)  __attribute__((unused));
static void
XS_pack_UA_GetEndpointsRequest(SV *out, UA_GetEndpointsRequest in)
{
	HV *hash = newHV();

	SV *requestHeaderSV = newSV(0);
	XS_pack_UA_RequestHeader(requestHeaderSV, in.requestHeader);
	hv_stores(hash, "GetEndpointsRequest_requestHeader", requestHeaderSV);

	SV *endpointUrlSV = newSV(0);
	XS_pack_UA_String(endpointUrlSV, in.endpointUrl);
	hv_stores(hash, "GetEndpointsRequest_endpointUrl", endpointUrlSV);

	AV *localeIdsArray = (AV*) sv_2mortal((SV*)newAV());
	size_t localeIdsI;
	for(localeIdsI = 0; localeIdsI < in.localeIdsSize; localeIdsI++) {
		SV *element = newSV(0);
		XS_pack_UA_String(element, in.localeIds[localeIdsI]);
		av_push(localeIdsArray, element);
	}
	hv_stores(hash, "GetEndpointsRequest_localeIds", newRV_inc((SV*)localeIdsArray));

	AV *profileUrisArray = (AV*) sv_2mortal((SV*)newAV());
	size_t profileUrisI;
	for(profileUrisI = 0; profileUrisI < in.profileUrisSize; profileUrisI++) {
		SV *element = newSV(0);
		XS_pack_UA_String(element, in.profileUris[profileUrisI]);
		av_push(profileUrisArray, element);
	}
	hv_stores(hash, "GetEndpointsRequest_profileUris", newRV_inc((SV*)profileUrisArray));

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_GetEndpointsRequest XS_unpack_UA_GetEndpointsRequest(SV *in)  __attribute__((unused));
static UA_GetEndpointsRequest
XS_unpack_UA_GetEndpointsRequest(SV *in)
{
	UA_GetEndpointsRequest out;
	SV **value;
	HV *hv;

	UA_GetEndpointsRequest_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "GetEndpointsRequest_requestHeader", 0);
	if (value != NULL)
		out.requestHeader = XS_unpack_UA_RequestHeader(*value);

	value = hv_fetchs(hv, "GetEndpointsRequest_endpointUrl", 0);
	if (value != NULL)
		out.endpointUrl = XS_unpack_UA_String(*value);

	/* TODO Implement array conversion for field localeIds */

	/* TODO Implement array conversion for field profileUris */

	return out;
}

/* GetEndpointsResponse */
static void XS_pack_UA_GetEndpointsResponse(SV *out, UA_GetEndpointsResponse in)  __attribute__((unused));
static void
XS_pack_UA_GetEndpointsResponse(SV *out, UA_GetEndpointsResponse in)
{
	HV *hash = newHV();

	SV *responseHeaderSV = newSV(0);
	XS_pack_UA_ResponseHeader(responseHeaderSV, in.responseHeader);
	hv_stores(hash, "GetEndpointsResponse_responseHeader", responseHeaderSV);

	AV *endpointsArray = (AV*) sv_2mortal((SV*)newAV());
	size_t endpointsI;
	for(endpointsI = 0; endpointsI < in.endpointsSize; endpointsI++) {
		SV *element = newSV(0);
		XS_pack_UA_EndpointDescription(element, in.endpoints[endpointsI]);
		av_push(endpointsArray, element);
	}
	hv_stores(hash, "GetEndpointsResponse_endpoints", newRV_inc((SV*)endpointsArray));

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_GetEndpointsResponse XS_unpack_UA_GetEndpointsResponse(SV *in)  __attribute__((unused));
static UA_GetEndpointsResponse
XS_unpack_UA_GetEndpointsResponse(SV *in)
{
	UA_GetEndpointsResponse out;
	SV **value;
	HV *hv;

	UA_GetEndpointsResponse_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "GetEndpointsResponse_responseHeader", 0);
	if (value != NULL)
		out.responseHeader = XS_unpack_UA_ResponseHeader(*value);

	/* TODO Implement array conversion for field endpoints */

	return out;
}

/* RegisteredServer */
static void XS_pack_UA_RegisteredServer(SV *out, UA_RegisteredServer in)  __attribute__((unused));
static void
XS_pack_UA_RegisteredServer(SV *out, UA_RegisteredServer in)
{
	HV *hash = newHV();

	SV *serverUriSV = newSV(0);
	XS_pack_UA_String(serverUriSV, in.serverUri);
	hv_stores(hash, "RegisteredServer_serverUri", serverUriSV);

	SV *productUriSV = newSV(0);
	XS_pack_UA_String(productUriSV, in.productUri);
	hv_stores(hash, "RegisteredServer_productUri", productUriSV);

	AV *serverNamesArray = (AV*) sv_2mortal((SV*)newAV());
	size_t serverNamesI;
	for(serverNamesI = 0; serverNamesI < in.serverNamesSize; serverNamesI++) {
		SV *element = newSV(0);
		XS_pack_UA_LocalizedText(element, in.serverNames[serverNamesI]);
		av_push(serverNamesArray, element);
	}
	hv_stores(hash, "RegisteredServer_serverNames", newRV_inc((SV*)serverNamesArray));

	SV *serverTypeSV = newSV(0);
	XS_pack_UA_ApplicationType(serverTypeSV, in.serverType);
	hv_stores(hash, "RegisteredServer_serverType", serverTypeSV);

	SV *gatewayServerUriSV = newSV(0);
	XS_pack_UA_String(gatewayServerUriSV, in.gatewayServerUri);
	hv_stores(hash, "RegisteredServer_gatewayServerUri", gatewayServerUriSV);

	AV *discoveryUrlsArray = (AV*) sv_2mortal((SV*)newAV());
	size_t discoveryUrlsI;
	for(discoveryUrlsI = 0; discoveryUrlsI < in.discoveryUrlsSize; discoveryUrlsI++) {
		SV *element = newSV(0);
		XS_pack_UA_String(element, in.discoveryUrls[discoveryUrlsI]);
		av_push(discoveryUrlsArray, element);
	}
	hv_stores(hash, "RegisteredServer_discoveryUrls", newRV_inc((SV*)discoveryUrlsArray));

	SV *semaphoreFilePathSV = newSV(0);
	XS_pack_UA_String(semaphoreFilePathSV, in.semaphoreFilePath);
	hv_stores(hash, "RegisteredServer_semaphoreFilePath", semaphoreFilePathSV);

	SV *isOnlineSV = newSV(0);
	XS_pack_UA_Boolean(isOnlineSV, in.isOnline);
	hv_stores(hash, "RegisteredServer_isOnline", isOnlineSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_RegisteredServer XS_unpack_UA_RegisteredServer(SV *in)  __attribute__((unused));
static UA_RegisteredServer
XS_unpack_UA_RegisteredServer(SV *in)
{
	UA_RegisteredServer out;
	SV **value;
	HV *hv;

	UA_RegisteredServer_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "RegisteredServer_serverUri", 0);
	if (value != NULL)
		out.serverUri = XS_unpack_UA_String(*value);

	value = hv_fetchs(hv, "RegisteredServer_productUri", 0);
	if (value != NULL)
		out.productUri = XS_unpack_UA_String(*value);

	/* TODO Implement array conversion for field serverNames */

	value = hv_fetchs(hv, "RegisteredServer_serverType", 0);
	if (value != NULL)
		out.serverType = XS_unpack_UA_ApplicationType(*value);

	value = hv_fetchs(hv, "RegisteredServer_gatewayServerUri", 0);
	if (value != NULL)
		out.gatewayServerUri = XS_unpack_UA_String(*value);

	/* TODO Implement array conversion for field discoveryUrls */

	value = hv_fetchs(hv, "RegisteredServer_semaphoreFilePath", 0);
	if (value != NULL)
		out.semaphoreFilePath = XS_unpack_UA_String(*value);

	value = hv_fetchs(hv, "RegisteredServer_isOnline", 0);
	if (value != NULL)
		out.isOnline = XS_unpack_UA_Boolean(*value);

	return out;
}

/* RegisterServerRequest */
static void XS_pack_UA_RegisterServerRequest(SV *out, UA_RegisterServerRequest in)  __attribute__((unused));
static void
XS_pack_UA_RegisterServerRequest(SV *out, UA_RegisterServerRequest in)
{
	HV *hash = newHV();

	SV *requestHeaderSV = newSV(0);
	XS_pack_UA_RequestHeader(requestHeaderSV, in.requestHeader);
	hv_stores(hash, "RegisterServerRequest_requestHeader", requestHeaderSV);

	SV *serverSV = newSV(0);
	XS_pack_UA_RegisteredServer(serverSV, in.server);
	hv_stores(hash, "RegisterServerRequest_server", serverSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_RegisterServerRequest XS_unpack_UA_RegisterServerRequest(SV *in)  __attribute__((unused));
static UA_RegisterServerRequest
XS_unpack_UA_RegisterServerRequest(SV *in)
{
	UA_RegisterServerRequest out;
	SV **value;
	HV *hv;

	UA_RegisterServerRequest_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "RegisterServerRequest_requestHeader", 0);
	if (value != NULL)
		out.requestHeader = XS_unpack_UA_RequestHeader(*value);

	value = hv_fetchs(hv, "RegisterServerRequest_server", 0);
	if (value != NULL)
		out.server = XS_unpack_UA_RegisteredServer(*value);

	return out;
}

/* RegisterServerResponse */
static void XS_pack_UA_RegisterServerResponse(SV *out, UA_RegisterServerResponse in)  __attribute__((unused));
static void
XS_pack_UA_RegisterServerResponse(SV *out, UA_RegisterServerResponse in)
{
	HV *hash = newHV();

	SV *responseHeaderSV = newSV(0);
	XS_pack_UA_ResponseHeader(responseHeaderSV, in.responseHeader);
	hv_stores(hash, "RegisterServerResponse_responseHeader", responseHeaderSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_RegisterServerResponse XS_unpack_UA_RegisterServerResponse(SV *in)  __attribute__((unused));
static UA_RegisterServerResponse
XS_unpack_UA_RegisterServerResponse(SV *in)
{
	UA_RegisterServerResponse out;
	SV **value;
	HV *hv;

	UA_RegisterServerResponse_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "RegisterServerResponse_responseHeader", 0);
	if (value != NULL)
		out.responseHeader = XS_unpack_UA_ResponseHeader(*value);

	return out;
}

/* DiscoveryConfiguration */
static void XS_pack_UA_DiscoveryConfiguration(SV *out, UA_DiscoveryConfiguration in)  __attribute__((unused));
static void
XS_pack_UA_DiscoveryConfiguration(SV *out, UA_DiscoveryConfiguration in)
{

}

static UA_DiscoveryConfiguration XS_unpack_UA_DiscoveryConfiguration(SV *in)  __attribute__((unused));
static UA_DiscoveryConfiguration
XS_unpack_UA_DiscoveryConfiguration(SV *in)
{
}

/* MdnsDiscoveryConfiguration */
static void XS_pack_UA_MdnsDiscoveryConfiguration(SV *out, UA_MdnsDiscoveryConfiguration in)  __attribute__((unused));
static void
XS_pack_UA_MdnsDiscoveryConfiguration(SV *out, UA_MdnsDiscoveryConfiguration in)
{
	HV *hash = newHV();

	SV *mdnsServerNameSV = newSV(0);
	XS_pack_UA_String(mdnsServerNameSV, in.mdnsServerName);
	hv_stores(hash, "MdnsDiscoveryConfiguration_mdnsServerName", mdnsServerNameSV);

	AV *serverCapabilitiesArray = (AV*) sv_2mortal((SV*)newAV());
	size_t serverCapabilitiesI;
	for(serverCapabilitiesI = 0; serverCapabilitiesI < in.serverCapabilitiesSize; serverCapabilitiesI++) {
		SV *element = newSV(0);
		XS_pack_UA_String(element, in.serverCapabilities[serverCapabilitiesI]);
		av_push(serverCapabilitiesArray, element);
	}
	hv_stores(hash, "MdnsDiscoveryConfiguration_serverCapabilities", newRV_inc((SV*)serverCapabilitiesArray));

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_MdnsDiscoveryConfiguration XS_unpack_UA_MdnsDiscoveryConfiguration(SV *in)  __attribute__((unused));
static UA_MdnsDiscoveryConfiguration
XS_unpack_UA_MdnsDiscoveryConfiguration(SV *in)
{
	UA_MdnsDiscoveryConfiguration out;
	SV **value;
	HV *hv;

	UA_MdnsDiscoveryConfiguration_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "MdnsDiscoveryConfiguration_mdnsServerName", 0);
	if (value != NULL)
		out.mdnsServerName = XS_unpack_UA_String(*value);

	/* TODO Implement array conversion for field serverCapabilities */

	return out;
}

/* RegisterServer2Request */
static void XS_pack_UA_RegisterServer2Request(SV *out, UA_RegisterServer2Request in)  __attribute__((unused));
static void
XS_pack_UA_RegisterServer2Request(SV *out, UA_RegisterServer2Request in)
{
	HV *hash = newHV();

	SV *requestHeaderSV = newSV(0);
	XS_pack_UA_RequestHeader(requestHeaderSV, in.requestHeader);
	hv_stores(hash, "RegisterServer2Request_requestHeader", requestHeaderSV);

	SV *serverSV = newSV(0);
	XS_pack_UA_RegisteredServer(serverSV, in.server);
	hv_stores(hash, "RegisterServer2Request_server", serverSV);

	AV *discoveryConfigurationArray = (AV*) sv_2mortal((SV*)newAV());
	size_t discoveryConfigurationI;
	for(discoveryConfigurationI = 0; discoveryConfigurationI < in.discoveryConfigurationSize; discoveryConfigurationI++) {
		SV *element = newSV(0);
		XS_pack_UA_ExtensionObject(element, in.discoveryConfiguration[discoveryConfigurationI]);
		av_push(discoveryConfigurationArray, element);
	}
	hv_stores(hash, "RegisterServer2Request_discoveryConfiguration", newRV_inc((SV*)discoveryConfigurationArray));

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_RegisterServer2Request XS_unpack_UA_RegisterServer2Request(SV *in)  __attribute__((unused));
static UA_RegisterServer2Request
XS_unpack_UA_RegisterServer2Request(SV *in)
{
	UA_RegisterServer2Request out;
	SV **value;
	HV *hv;

	UA_RegisterServer2Request_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "RegisterServer2Request_requestHeader", 0);
	if (value != NULL)
		out.requestHeader = XS_unpack_UA_RequestHeader(*value);

	value = hv_fetchs(hv, "RegisterServer2Request_server", 0);
	if (value != NULL)
		out.server = XS_unpack_UA_RegisteredServer(*value);

	/* TODO Implement array conversion for field discoveryConfiguration */

	return out;
}

/* RegisterServer2Response */
static void XS_pack_UA_RegisterServer2Response(SV *out, UA_RegisterServer2Response in)  __attribute__((unused));
static void
XS_pack_UA_RegisterServer2Response(SV *out, UA_RegisterServer2Response in)
{
	HV *hash = newHV();

	SV *responseHeaderSV = newSV(0);
	XS_pack_UA_ResponseHeader(responseHeaderSV, in.responseHeader);
	hv_stores(hash, "RegisterServer2Response_responseHeader", responseHeaderSV);

	AV *configurationResultsArray = (AV*) sv_2mortal((SV*)newAV());
	size_t configurationResultsI;
	for(configurationResultsI = 0; configurationResultsI < in.configurationResultsSize; configurationResultsI++) {
		SV *element = newSV(0);
		XS_pack_UA_StatusCode(element, in.configurationResults[configurationResultsI]);
		av_push(configurationResultsArray, element);
	}
	hv_stores(hash, "RegisterServer2Response_configurationResults", newRV_inc((SV*)configurationResultsArray));

	AV *diagnosticInfosArray = (AV*) sv_2mortal((SV*)newAV());
	size_t diagnosticInfosI;
	for(diagnosticInfosI = 0; diagnosticInfosI < in.diagnosticInfosSize; diagnosticInfosI++) {
		SV *element = newSV(0);
		XS_pack_UA_DiagnosticInfo(element, in.diagnosticInfos[diagnosticInfosI]);
		av_push(diagnosticInfosArray, element);
	}
	hv_stores(hash, "RegisterServer2Response_diagnosticInfos", newRV_inc((SV*)diagnosticInfosArray));

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_RegisterServer2Response XS_unpack_UA_RegisterServer2Response(SV *in)  __attribute__((unused));
static UA_RegisterServer2Response
XS_unpack_UA_RegisterServer2Response(SV *in)
{
	UA_RegisterServer2Response out;
	SV **value;
	HV *hv;

	UA_RegisterServer2Response_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "RegisterServer2Response_responseHeader", 0);
	if (value != NULL)
		out.responseHeader = XS_unpack_UA_ResponseHeader(*value);

	/* TODO Implement array conversion for field configurationResults */

	/* TODO Implement array conversion for field diagnosticInfos */

	return out;
}

/* SecurityTokenRequestType */
static void XS_pack_UA_SecurityTokenRequestType(SV *out, UA_SecurityTokenRequestType in)  __attribute__((unused));
static void
XS_pack_UA_SecurityTokenRequestType(SV *out, UA_SecurityTokenRequestType in)
{
	/* TODO implement EnumerationType conversion */

}

static UA_SecurityTokenRequestType XS_unpack_UA_SecurityTokenRequestType(SV *in)  __attribute__((unused));
static UA_SecurityTokenRequestType
XS_unpack_UA_SecurityTokenRequestType(SV *in)
{
	/* TODO implement EnumerationType conversion */
}

/* ChannelSecurityToken */
static void XS_pack_UA_ChannelSecurityToken(SV *out, UA_ChannelSecurityToken in)  __attribute__((unused));
static void
XS_pack_UA_ChannelSecurityToken(SV *out, UA_ChannelSecurityToken in)
{
	HV *hash = newHV();

	SV *channelIdSV = newSV(0);
	XS_pack_UA_UInt32(channelIdSV, in.channelId);
	hv_stores(hash, "ChannelSecurityToken_channelId", channelIdSV);

	SV *tokenIdSV = newSV(0);
	XS_pack_UA_UInt32(tokenIdSV, in.tokenId);
	hv_stores(hash, "ChannelSecurityToken_tokenId", tokenIdSV);

	SV *createdAtSV = newSV(0);
	XS_pack_UA_DateTime(createdAtSV, in.createdAt);
	hv_stores(hash, "ChannelSecurityToken_createdAt", createdAtSV);

	SV *revisedLifetimeSV = newSV(0);
	XS_pack_UA_UInt32(revisedLifetimeSV, in.revisedLifetime);
	hv_stores(hash, "ChannelSecurityToken_revisedLifetime", revisedLifetimeSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_ChannelSecurityToken XS_unpack_UA_ChannelSecurityToken(SV *in)  __attribute__((unused));
static UA_ChannelSecurityToken
XS_unpack_UA_ChannelSecurityToken(SV *in)
{
	UA_ChannelSecurityToken out;
	SV **value;
	HV *hv;

	UA_ChannelSecurityToken_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "ChannelSecurityToken_channelId", 0);
	if (value != NULL)
		out.channelId = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "ChannelSecurityToken_tokenId", 0);
	if (value != NULL)
		out.tokenId = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "ChannelSecurityToken_createdAt", 0);
	if (value != NULL)
		out.createdAt = XS_unpack_UA_DateTime(*value);

	value = hv_fetchs(hv, "ChannelSecurityToken_revisedLifetime", 0);
	if (value != NULL)
		out.revisedLifetime = XS_unpack_UA_UInt32(*value);

	return out;
}

/* OpenSecureChannelRequest */
static void XS_pack_UA_OpenSecureChannelRequest(SV *out, UA_OpenSecureChannelRequest in)  __attribute__((unused));
static void
XS_pack_UA_OpenSecureChannelRequest(SV *out, UA_OpenSecureChannelRequest in)
{
	HV *hash = newHV();

	SV *requestHeaderSV = newSV(0);
	XS_pack_UA_RequestHeader(requestHeaderSV, in.requestHeader);
	hv_stores(hash, "OpenSecureChannelRequest_requestHeader", requestHeaderSV);

	SV *clientProtocolVersionSV = newSV(0);
	XS_pack_UA_UInt32(clientProtocolVersionSV, in.clientProtocolVersion);
	hv_stores(hash, "OpenSecureChannelRequest_clientProtocolVersion", clientProtocolVersionSV);

	SV *requestTypeSV = newSV(0);
	XS_pack_UA_SecurityTokenRequestType(requestTypeSV, in.requestType);
	hv_stores(hash, "OpenSecureChannelRequest_requestType", requestTypeSV);

	SV *securityModeSV = newSV(0);
	XS_pack_UA_MessageSecurityMode(securityModeSV, in.securityMode);
	hv_stores(hash, "OpenSecureChannelRequest_securityMode", securityModeSV);

	SV *clientNonceSV = newSV(0);
	XS_pack_UA_ByteString(clientNonceSV, in.clientNonce);
	hv_stores(hash, "OpenSecureChannelRequest_clientNonce", clientNonceSV);

	SV *requestedLifetimeSV = newSV(0);
	XS_pack_UA_UInt32(requestedLifetimeSV, in.requestedLifetime);
	hv_stores(hash, "OpenSecureChannelRequest_requestedLifetime", requestedLifetimeSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_OpenSecureChannelRequest XS_unpack_UA_OpenSecureChannelRequest(SV *in)  __attribute__((unused));
static UA_OpenSecureChannelRequest
XS_unpack_UA_OpenSecureChannelRequest(SV *in)
{
	UA_OpenSecureChannelRequest out;
	SV **value;
	HV *hv;

	UA_OpenSecureChannelRequest_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "OpenSecureChannelRequest_requestHeader", 0);
	if (value != NULL)
		out.requestHeader = XS_unpack_UA_RequestHeader(*value);

	value = hv_fetchs(hv, "OpenSecureChannelRequest_clientProtocolVersion", 0);
	if (value != NULL)
		out.clientProtocolVersion = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "OpenSecureChannelRequest_requestType", 0);
	if (value != NULL)
		out.requestType = XS_unpack_UA_SecurityTokenRequestType(*value);

	value = hv_fetchs(hv, "OpenSecureChannelRequest_securityMode", 0);
	if (value != NULL)
		out.securityMode = XS_unpack_UA_MessageSecurityMode(*value);

	value = hv_fetchs(hv, "OpenSecureChannelRequest_clientNonce", 0);
	if (value != NULL)
		out.clientNonce = XS_unpack_UA_ByteString(*value);

	value = hv_fetchs(hv, "OpenSecureChannelRequest_requestedLifetime", 0);
	if (value != NULL)
		out.requestedLifetime = XS_unpack_UA_UInt32(*value);

	return out;
}

/* OpenSecureChannelResponse */
static void XS_pack_UA_OpenSecureChannelResponse(SV *out, UA_OpenSecureChannelResponse in)  __attribute__((unused));
static void
XS_pack_UA_OpenSecureChannelResponse(SV *out, UA_OpenSecureChannelResponse in)
{
	HV *hash = newHV();

	SV *responseHeaderSV = newSV(0);
	XS_pack_UA_ResponseHeader(responseHeaderSV, in.responseHeader);
	hv_stores(hash, "OpenSecureChannelResponse_responseHeader", responseHeaderSV);

	SV *serverProtocolVersionSV = newSV(0);
	XS_pack_UA_UInt32(serverProtocolVersionSV, in.serverProtocolVersion);
	hv_stores(hash, "OpenSecureChannelResponse_serverProtocolVersion", serverProtocolVersionSV);

	SV *securityTokenSV = newSV(0);
	XS_pack_UA_ChannelSecurityToken(securityTokenSV, in.securityToken);
	hv_stores(hash, "OpenSecureChannelResponse_securityToken", securityTokenSV);

	SV *serverNonceSV = newSV(0);
	XS_pack_UA_ByteString(serverNonceSV, in.serverNonce);
	hv_stores(hash, "OpenSecureChannelResponse_serverNonce", serverNonceSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_OpenSecureChannelResponse XS_unpack_UA_OpenSecureChannelResponse(SV *in)  __attribute__((unused));
static UA_OpenSecureChannelResponse
XS_unpack_UA_OpenSecureChannelResponse(SV *in)
{
	UA_OpenSecureChannelResponse out;
	SV **value;
	HV *hv;

	UA_OpenSecureChannelResponse_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "OpenSecureChannelResponse_responseHeader", 0);
	if (value != NULL)
		out.responseHeader = XS_unpack_UA_ResponseHeader(*value);

	value = hv_fetchs(hv, "OpenSecureChannelResponse_serverProtocolVersion", 0);
	if (value != NULL)
		out.serverProtocolVersion = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "OpenSecureChannelResponse_securityToken", 0);
	if (value != NULL)
		out.securityToken = XS_unpack_UA_ChannelSecurityToken(*value);

	value = hv_fetchs(hv, "OpenSecureChannelResponse_serverNonce", 0);
	if (value != NULL)
		out.serverNonce = XS_unpack_UA_ByteString(*value);

	return out;
}

/* CloseSecureChannelRequest */
static void XS_pack_UA_CloseSecureChannelRequest(SV *out, UA_CloseSecureChannelRequest in)  __attribute__((unused));
static void
XS_pack_UA_CloseSecureChannelRequest(SV *out, UA_CloseSecureChannelRequest in)
{
	HV *hash = newHV();

	SV *requestHeaderSV = newSV(0);
	XS_pack_UA_RequestHeader(requestHeaderSV, in.requestHeader);
	hv_stores(hash, "CloseSecureChannelRequest_requestHeader", requestHeaderSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_CloseSecureChannelRequest XS_unpack_UA_CloseSecureChannelRequest(SV *in)  __attribute__((unused));
static UA_CloseSecureChannelRequest
XS_unpack_UA_CloseSecureChannelRequest(SV *in)
{
	UA_CloseSecureChannelRequest out;
	SV **value;
	HV *hv;

	UA_CloseSecureChannelRequest_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "CloseSecureChannelRequest_requestHeader", 0);
	if (value != NULL)
		out.requestHeader = XS_unpack_UA_RequestHeader(*value);

	return out;
}

/* CloseSecureChannelResponse */
static void XS_pack_UA_CloseSecureChannelResponse(SV *out, UA_CloseSecureChannelResponse in)  __attribute__((unused));
static void
XS_pack_UA_CloseSecureChannelResponse(SV *out, UA_CloseSecureChannelResponse in)
{
	HV *hash = newHV();

	SV *responseHeaderSV = newSV(0);
	XS_pack_UA_ResponseHeader(responseHeaderSV, in.responseHeader);
	hv_stores(hash, "CloseSecureChannelResponse_responseHeader", responseHeaderSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_CloseSecureChannelResponse XS_unpack_UA_CloseSecureChannelResponse(SV *in)  __attribute__((unused));
static UA_CloseSecureChannelResponse
XS_unpack_UA_CloseSecureChannelResponse(SV *in)
{
	UA_CloseSecureChannelResponse out;
	SV **value;
	HV *hv;

	UA_CloseSecureChannelResponse_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "CloseSecureChannelResponse_responseHeader", 0);
	if (value != NULL)
		out.responseHeader = XS_unpack_UA_ResponseHeader(*value);

	return out;
}

/* SignedSoftwareCertificate */
static void XS_pack_UA_SignedSoftwareCertificate(SV *out, UA_SignedSoftwareCertificate in)  __attribute__((unused));
static void
XS_pack_UA_SignedSoftwareCertificate(SV *out, UA_SignedSoftwareCertificate in)
{
	HV *hash = newHV();

	SV *certificateDataSV = newSV(0);
	XS_pack_UA_ByteString(certificateDataSV, in.certificateData);
	hv_stores(hash, "SignedSoftwareCertificate_certificateData", certificateDataSV);

	SV *signatureSV = newSV(0);
	XS_pack_UA_ByteString(signatureSV, in.signature);
	hv_stores(hash, "SignedSoftwareCertificate_signature", signatureSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_SignedSoftwareCertificate XS_unpack_UA_SignedSoftwareCertificate(SV *in)  __attribute__((unused));
static UA_SignedSoftwareCertificate
XS_unpack_UA_SignedSoftwareCertificate(SV *in)
{
	UA_SignedSoftwareCertificate out;
	SV **value;
	HV *hv;

	UA_SignedSoftwareCertificate_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "SignedSoftwareCertificate_certificateData", 0);
	if (value != NULL)
		out.certificateData = XS_unpack_UA_ByteString(*value);

	value = hv_fetchs(hv, "SignedSoftwareCertificate_signature", 0);
	if (value != NULL)
		out.signature = XS_unpack_UA_ByteString(*value);

	return out;
}

/* SignatureData */
static void XS_pack_UA_SignatureData(SV *out, UA_SignatureData in)  __attribute__((unused));
static void
XS_pack_UA_SignatureData(SV *out, UA_SignatureData in)
{
	HV *hash = newHV();

	SV *algorithmSV = newSV(0);
	XS_pack_UA_String(algorithmSV, in.algorithm);
	hv_stores(hash, "SignatureData_algorithm", algorithmSV);

	SV *signatureSV = newSV(0);
	XS_pack_UA_ByteString(signatureSV, in.signature);
	hv_stores(hash, "SignatureData_signature", signatureSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_SignatureData XS_unpack_UA_SignatureData(SV *in)  __attribute__((unused));
static UA_SignatureData
XS_unpack_UA_SignatureData(SV *in)
{
	UA_SignatureData out;
	SV **value;
	HV *hv;

	UA_SignatureData_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "SignatureData_algorithm", 0);
	if (value != NULL)
		out.algorithm = XS_unpack_UA_String(*value);

	value = hv_fetchs(hv, "SignatureData_signature", 0);
	if (value != NULL)
		out.signature = XS_unpack_UA_ByteString(*value);

	return out;
}

/* CreateSessionRequest */
static void XS_pack_UA_CreateSessionRequest(SV *out, UA_CreateSessionRequest in)  __attribute__((unused));
static void
XS_pack_UA_CreateSessionRequest(SV *out, UA_CreateSessionRequest in)
{
	HV *hash = newHV();

	SV *requestHeaderSV = newSV(0);
	XS_pack_UA_RequestHeader(requestHeaderSV, in.requestHeader);
	hv_stores(hash, "CreateSessionRequest_requestHeader", requestHeaderSV);

	SV *clientDescriptionSV = newSV(0);
	XS_pack_UA_ApplicationDescription(clientDescriptionSV, in.clientDescription);
	hv_stores(hash, "CreateSessionRequest_clientDescription", clientDescriptionSV);

	SV *serverUriSV = newSV(0);
	XS_pack_UA_String(serverUriSV, in.serverUri);
	hv_stores(hash, "CreateSessionRequest_serverUri", serverUriSV);

	SV *endpointUrlSV = newSV(0);
	XS_pack_UA_String(endpointUrlSV, in.endpointUrl);
	hv_stores(hash, "CreateSessionRequest_endpointUrl", endpointUrlSV);

	SV *sessionNameSV = newSV(0);
	XS_pack_UA_String(sessionNameSV, in.sessionName);
	hv_stores(hash, "CreateSessionRequest_sessionName", sessionNameSV);

	SV *clientNonceSV = newSV(0);
	XS_pack_UA_ByteString(clientNonceSV, in.clientNonce);
	hv_stores(hash, "CreateSessionRequest_clientNonce", clientNonceSV);

	SV *clientCertificateSV = newSV(0);
	XS_pack_UA_ByteString(clientCertificateSV, in.clientCertificate);
	hv_stores(hash, "CreateSessionRequest_clientCertificate", clientCertificateSV);

	SV *requestedSessionTimeoutSV = newSV(0);
	XS_pack_UA_Double(requestedSessionTimeoutSV, in.requestedSessionTimeout);
	hv_stores(hash, "CreateSessionRequest_requestedSessionTimeout", requestedSessionTimeoutSV);

	SV *maxResponseMessageSizeSV = newSV(0);
	XS_pack_UA_UInt32(maxResponseMessageSizeSV, in.maxResponseMessageSize);
	hv_stores(hash, "CreateSessionRequest_maxResponseMessageSize", maxResponseMessageSizeSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_CreateSessionRequest XS_unpack_UA_CreateSessionRequest(SV *in)  __attribute__((unused));
static UA_CreateSessionRequest
XS_unpack_UA_CreateSessionRequest(SV *in)
{
	UA_CreateSessionRequest out;
	SV **value;
	HV *hv;

	UA_CreateSessionRequest_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "CreateSessionRequest_requestHeader", 0);
	if (value != NULL)
		out.requestHeader = XS_unpack_UA_RequestHeader(*value);

	value = hv_fetchs(hv, "CreateSessionRequest_clientDescription", 0);
	if (value != NULL)
		out.clientDescription = XS_unpack_UA_ApplicationDescription(*value);

	value = hv_fetchs(hv, "CreateSessionRequest_serverUri", 0);
	if (value != NULL)
		out.serverUri = XS_unpack_UA_String(*value);

	value = hv_fetchs(hv, "CreateSessionRequest_endpointUrl", 0);
	if (value != NULL)
		out.endpointUrl = XS_unpack_UA_String(*value);

	value = hv_fetchs(hv, "CreateSessionRequest_sessionName", 0);
	if (value != NULL)
		out.sessionName = XS_unpack_UA_String(*value);

	value = hv_fetchs(hv, "CreateSessionRequest_clientNonce", 0);
	if (value != NULL)
		out.clientNonce = XS_unpack_UA_ByteString(*value);

	value = hv_fetchs(hv, "CreateSessionRequest_clientCertificate", 0);
	if (value != NULL)
		out.clientCertificate = XS_unpack_UA_ByteString(*value);

	value = hv_fetchs(hv, "CreateSessionRequest_requestedSessionTimeout", 0);
	if (value != NULL)
		out.requestedSessionTimeout = XS_unpack_UA_Double(*value);

	value = hv_fetchs(hv, "CreateSessionRequest_maxResponseMessageSize", 0);
	if (value != NULL)
		out.maxResponseMessageSize = XS_unpack_UA_UInt32(*value);

	return out;
}

/* CreateSessionResponse */
static void XS_pack_UA_CreateSessionResponse(SV *out, UA_CreateSessionResponse in)  __attribute__((unused));
static void
XS_pack_UA_CreateSessionResponse(SV *out, UA_CreateSessionResponse in)
{
	HV *hash = newHV();

	SV *responseHeaderSV = newSV(0);
	XS_pack_UA_ResponseHeader(responseHeaderSV, in.responseHeader);
	hv_stores(hash, "CreateSessionResponse_responseHeader", responseHeaderSV);

	SV *sessionIdSV = newSV(0);
	XS_pack_UA_NodeId(sessionIdSV, in.sessionId);
	hv_stores(hash, "CreateSessionResponse_sessionId", sessionIdSV);

	SV *authenticationTokenSV = newSV(0);
	XS_pack_UA_NodeId(authenticationTokenSV, in.authenticationToken);
	hv_stores(hash, "CreateSessionResponse_authenticationToken", authenticationTokenSV);

	SV *revisedSessionTimeoutSV = newSV(0);
	XS_pack_UA_Double(revisedSessionTimeoutSV, in.revisedSessionTimeout);
	hv_stores(hash, "CreateSessionResponse_revisedSessionTimeout", revisedSessionTimeoutSV);

	SV *serverNonceSV = newSV(0);
	XS_pack_UA_ByteString(serverNonceSV, in.serverNonce);
	hv_stores(hash, "CreateSessionResponse_serverNonce", serverNonceSV);

	SV *serverCertificateSV = newSV(0);
	XS_pack_UA_ByteString(serverCertificateSV, in.serverCertificate);
	hv_stores(hash, "CreateSessionResponse_serverCertificate", serverCertificateSV);

	AV *serverEndpointsArray = (AV*) sv_2mortal((SV*)newAV());
	size_t serverEndpointsI;
	for(serverEndpointsI = 0; serverEndpointsI < in.serverEndpointsSize; serverEndpointsI++) {
		SV *element = newSV(0);
		XS_pack_UA_EndpointDescription(element, in.serverEndpoints[serverEndpointsI]);
		av_push(serverEndpointsArray, element);
	}
	hv_stores(hash, "CreateSessionResponse_serverEndpoints", newRV_inc((SV*)serverEndpointsArray));

	AV *serverSoftwareCertificatesArray = (AV*) sv_2mortal((SV*)newAV());
	size_t serverSoftwareCertificatesI;
	for(serverSoftwareCertificatesI = 0; serverSoftwareCertificatesI < in.serverSoftwareCertificatesSize; serverSoftwareCertificatesI++) {
		SV *element = newSV(0);
		XS_pack_UA_SignedSoftwareCertificate(element, in.serverSoftwareCertificates[serverSoftwareCertificatesI]);
		av_push(serverSoftwareCertificatesArray, element);
	}
	hv_stores(hash, "CreateSessionResponse_serverSoftwareCertificates", newRV_inc((SV*)serverSoftwareCertificatesArray));

	SV *serverSignatureSV = newSV(0);
	XS_pack_UA_SignatureData(serverSignatureSV, in.serverSignature);
	hv_stores(hash, "CreateSessionResponse_serverSignature", serverSignatureSV);

	SV *maxRequestMessageSizeSV = newSV(0);
	XS_pack_UA_UInt32(maxRequestMessageSizeSV, in.maxRequestMessageSize);
	hv_stores(hash, "CreateSessionResponse_maxRequestMessageSize", maxRequestMessageSizeSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_CreateSessionResponse XS_unpack_UA_CreateSessionResponse(SV *in)  __attribute__((unused));
static UA_CreateSessionResponse
XS_unpack_UA_CreateSessionResponse(SV *in)
{
	UA_CreateSessionResponse out;
	SV **value;
	HV *hv;

	UA_CreateSessionResponse_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "CreateSessionResponse_responseHeader", 0);
	if (value != NULL)
		out.responseHeader = XS_unpack_UA_ResponseHeader(*value);

	value = hv_fetchs(hv, "CreateSessionResponse_sessionId", 0);
	if (value != NULL)
		out.sessionId = XS_unpack_UA_NodeId(*value);

	value = hv_fetchs(hv, "CreateSessionResponse_authenticationToken", 0);
	if (value != NULL)
		out.authenticationToken = XS_unpack_UA_NodeId(*value);

	value = hv_fetchs(hv, "CreateSessionResponse_revisedSessionTimeout", 0);
	if (value != NULL)
		out.revisedSessionTimeout = XS_unpack_UA_Double(*value);

	value = hv_fetchs(hv, "CreateSessionResponse_serverNonce", 0);
	if (value != NULL)
		out.serverNonce = XS_unpack_UA_ByteString(*value);

	value = hv_fetchs(hv, "CreateSessionResponse_serverCertificate", 0);
	if (value != NULL)
		out.serverCertificate = XS_unpack_UA_ByteString(*value);

	/* TODO Implement array conversion for field serverEndpoints */

	/* TODO Implement array conversion for field serverSoftwareCertificates */

	value = hv_fetchs(hv, "CreateSessionResponse_serverSignature", 0);
	if (value != NULL)
		out.serverSignature = XS_unpack_UA_SignatureData(*value);

	value = hv_fetchs(hv, "CreateSessionResponse_maxRequestMessageSize", 0);
	if (value != NULL)
		out.maxRequestMessageSize = XS_unpack_UA_UInt32(*value);

	return out;
}

/* UserIdentityToken */
static void XS_pack_UA_UserIdentityToken(SV *out, UA_UserIdentityToken in)  __attribute__((unused));
static void
XS_pack_UA_UserIdentityToken(SV *out, UA_UserIdentityToken in)
{
	HV *hash = newHV();

	SV *policyIdSV = newSV(0);
	XS_pack_UA_String(policyIdSV, in.policyId);
	hv_stores(hash, "UserIdentityToken_policyId", policyIdSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_UserIdentityToken XS_unpack_UA_UserIdentityToken(SV *in)  __attribute__((unused));
static UA_UserIdentityToken
XS_unpack_UA_UserIdentityToken(SV *in)
{
	UA_UserIdentityToken out;
	SV **value;
	HV *hv;

	UA_UserIdentityToken_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "UserIdentityToken_policyId", 0);
	if (value != NULL)
		out.policyId = XS_unpack_UA_String(*value);

	return out;
}

/* AnonymousIdentityToken */
static void XS_pack_UA_AnonymousIdentityToken(SV *out, UA_AnonymousIdentityToken in)  __attribute__((unused));
static void
XS_pack_UA_AnonymousIdentityToken(SV *out, UA_AnonymousIdentityToken in)
{
	HV *hash = newHV();

	SV *policyIdSV = newSV(0);
	XS_pack_UA_String(policyIdSV, in.policyId);
	hv_stores(hash, "AnonymousIdentityToken_policyId", policyIdSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_AnonymousIdentityToken XS_unpack_UA_AnonymousIdentityToken(SV *in)  __attribute__((unused));
static UA_AnonymousIdentityToken
XS_unpack_UA_AnonymousIdentityToken(SV *in)
{
	UA_AnonymousIdentityToken out;
	SV **value;
	HV *hv;

	UA_AnonymousIdentityToken_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "AnonymousIdentityToken_policyId", 0);
	if (value != NULL)
		out.policyId = XS_unpack_UA_String(*value);

	return out;
}

/* UserNameIdentityToken */
static void XS_pack_UA_UserNameIdentityToken(SV *out, UA_UserNameIdentityToken in)  __attribute__((unused));
static void
XS_pack_UA_UserNameIdentityToken(SV *out, UA_UserNameIdentityToken in)
{
	HV *hash = newHV();

	SV *policyIdSV = newSV(0);
	XS_pack_UA_String(policyIdSV, in.policyId);
	hv_stores(hash, "UserNameIdentityToken_policyId", policyIdSV);

	SV *userNameSV = newSV(0);
	XS_pack_UA_String(userNameSV, in.userName);
	hv_stores(hash, "UserNameIdentityToken_userName", userNameSV);

	SV *passwordSV = newSV(0);
	XS_pack_UA_ByteString(passwordSV, in.password);
	hv_stores(hash, "UserNameIdentityToken_password", passwordSV);

	SV *encryptionAlgorithmSV = newSV(0);
	XS_pack_UA_String(encryptionAlgorithmSV, in.encryptionAlgorithm);
	hv_stores(hash, "UserNameIdentityToken_encryptionAlgorithm", encryptionAlgorithmSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_UserNameIdentityToken XS_unpack_UA_UserNameIdentityToken(SV *in)  __attribute__((unused));
static UA_UserNameIdentityToken
XS_unpack_UA_UserNameIdentityToken(SV *in)
{
	UA_UserNameIdentityToken out;
	SV **value;
	HV *hv;

	UA_UserNameIdentityToken_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "UserNameIdentityToken_policyId", 0);
	if (value != NULL)
		out.policyId = XS_unpack_UA_String(*value);

	value = hv_fetchs(hv, "UserNameIdentityToken_userName", 0);
	if (value != NULL)
		out.userName = XS_unpack_UA_String(*value);

	value = hv_fetchs(hv, "UserNameIdentityToken_password", 0);
	if (value != NULL)
		out.password = XS_unpack_UA_ByteString(*value);

	value = hv_fetchs(hv, "UserNameIdentityToken_encryptionAlgorithm", 0);
	if (value != NULL)
		out.encryptionAlgorithm = XS_unpack_UA_String(*value);

	return out;
}

/* X509IdentityToken */
static void XS_pack_UA_X509IdentityToken(SV *out, UA_X509IdentityToken in)  __attribute__((unused));
static void
XS_pack_UA_X509IdentityToken(SV *out, UA_X509IdentityToken in)
{
	HV *hash = newHV();

	SV *policyIdSV = newSV(0);
	XS_pack_UA_String(policyIdSV, in.policyId);
	hv_stores(hash, "X509IdentityToken_policyId", policyIdSV);

	SV *certificateDataSV = newSV(0);
	XS_pack_UA_ByteString(certificateDataSV, in.certificateData);
	hv_stores(hash, "X509IdentityToken_certificateData", certificateDataSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_X509IdentityToken XS_unpack_UA_X509IdentityToken(SV *in)  __attribute__((unused));
static UA_X509IdentityToken
XS_unpack_UA_X509IdentityToken(SV *in)
{
	UA_X509IdentityToken out;
	SV **value;
	HV *hv;

	UA_X509IdentityToken_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "X509IdentityToken_policyId", 0);
	if (value != NULL)
		out.policyId = XS_unpack_UA_String(*value);

	value = hv_fetchs(hv, "X509IdentityToken_certificateData", 0);
	if (value != NULL)
		out.certificateData = XS_unpack_UA_ByteString(*value);

	return out;
}

/* IssuedIdentityToken */
static void XS_pack_UA_IssuedIdentityToken(SV *out, UA_IssuedIdentityToken in)  __attribute__((unused));
static void
XS_pack_UA_IssuedIdentityToken(SV *out, UA_IssuedIdentityToken in)
{
	HV *hash = newHV();

	SV *policyIdSV = newSV(0);
	XS_pack_UA_String(policyIdSV, in.policyId);
	hv_stores(hash, "IssuedIdentityToken_policyId", policyIdSV);

	SV *tokenDataSV = newSV(0);
	XS_pack_UA_ByteString(tokenDataSV, in.tokenData);
	hv_stores(hash, "IssuedIdentityToken_tokenData", tokenDataSV);

	SV *encryptionAlgorithmSV = newSV(0);
	XS_pack_UA_String(encryptionAlgorithmSV, in.encryptionAlgorithm);
	hv_stores(hash, "IssuedIdentityToken_encryptionAlgorithm", encryptionAlgorithmSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_IssuedIdentityToken XS_unpack_UA_IssuedIdentityToken(SV *in)  __attribute__((unused));
static UA_IssuedIdentityToken
XS_unpack_UA_IssuedIdentityToken(SV *in)
{
	UA_IssuedIdentityToken out;
	SV **value;
	HV *hv;

	UA_IssuedIdentityToken_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "IssuedIdentityToken_policyId", 0);
	if (value != NULL)
		out.policyId = XS_unpack_UA_String(*value);

	value = hv_fetchs(hv, "IssuedIdentityToken_tokenData", 0);
	if (value != NULL)
		out.tokenData = XS_unpack_UA_ByteString(*value);

	value = hv_fetchs(hv, "IssuedIdentityToken_encryptionAlgorithm", 0);
	if (value != NULL)
		out.encryptionAlgorithm = XS_unpack_UA_String(*value);

	return out;
}

/* ActivateSessionRequest */
static void XS_pack_UA_ActivateSessionRequest(SV *out, UA_ActivateSessionRequest in)  __attribute__((unused));
static void
XS_pack_UA_ActivateSessionRequest(SV *out, UA_ActivateSessionRequest in)
{
	HV *hash = newHV();

	SV *requestHeaderSV = newSV(0);
	XS_pack_UA_RequestHeader(requestHeaderSV, in.requestHeader);
	hv_stores(hash, "ActivateSessionRequest_requestHeader", requestHeaderSV);

	SV *clientSignatureSV = newSV(0);
	XS_pack_UA_SignatureData(clientSignatureSV, in.clientSignature);
	hv_stores(hash, "ActivateSessionRequest_clientSignature", clientSignatureSV);

	AV *clientSoftwareCertificatesArray = (AV*) sv_2mortal((SV*)newAV());
	size_t clientSoftwareCertificatesI;
	for(clientSoftwareCertificatesI = 0; clientSoftwareCertificatesI < in.clientSoftwareCertificatesSize; clientSoftwareCertificatesI++) {
		SV *element = newSV(0);
		XS_pack_UA_SignedSoftwareCertificate(element, in.clientSoftwareCertificates[clientSoftwareCertificatesI]);
		av_push(clientSoftwareCertificatesArray, element);
	}
	hv_stores(hash, "ActivateSessionRequest_clientSoftwareCertificates", newRV_inc((SV*)clientSoftwareCertificatesArray));

	AV *localeIdsArray = (AV*) sv_2mortal((SV*)newAV());
	size_t localeIdsI;
	for(localeIdsI = 0; localeIdsI < in.localeIdsSize; localeIdsI++) {
		SV *element = newSV(0);
		XS_pack_UA_String(element, in.localeIds[localeIdsI]);
		av_push(localeIdsArray, element);
	}
	hv_stores(hash, "ActivateSessionRequest_localeIds", newRV_inc((SV*)localeIdsArray));

	SV *userIdentityTokenSV = newSV(0);
	XS_pack_UA_ExtensionObject(userIdentityTokenSV, in.userIdentityToken);
	hv_stores(hash, "ActivateSessionRequest_userIdentityToken", userIdentityTokenSV);

	SV *userTokenSignatureSV = newSV(0);
	XS_pack_UA_SignatureData(userTokenSignatureSV, in.userTokenSignature);
	hv_stores(hash, "ActivateSessionRequest_userTokenSignature", userTokenSignatureSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_ActivateSessionRequest XS_unpack_UA_ActivateSessionRequest(SV *in)  __attribute__((unused));
static UA_ActivateSessionRequest
XS_unpack_UA_ActivateSessionRequest(SV *in)
{
	UA_ActivateSessionRequest out;
	SV **value;
	HV *hv;

	UA_ActivateSessionRequest_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "ActivateSessionRequest_requestHeader", 0);
	if (value != NULL)
		out.requestHeader = XS_unpack_UA_RequestHeader(*value);

	value = hv_fetchs(hv, "ActivateSessionRequest_clientSignature", 0);
	if (value != NULL)
		out.clientSignature = XS_unpack_UA_SignatureData(*value);

	/* TODO Implement array conversion for field clientSoftwareCertificates */

	/* TODO Implement array conversion for field localeIds */

	value = hv_fetchs(hv, "ActivateSessionRequest_userIdentityToken", 0);
	if (value != NULL)
		out.userIdentityToken = XS_unpack_UA_ExtensionObject(*value);

	value = hv_fetchs(hv, "ActivateSessionRequest_userTokenSignature", 0);
	if (value != NULL)
		out.userTokenSignature = XS_unpack_UA_SignatureData(*value);

	return out;
}

/* ActivateSessionResponse */
static void XS_pack_UA_ActivateSessionResponse(SV *out, UA_ActivateSessionResponse in)  __attribute__((unused));
static void
XS_pack_UA_ActivateSessionResponse(SV *out, UA_ActivateSessionResponse in)
{
	HV *hash = newHV();

	SV *responseHeaderSV = newSV(0);
	XS_pack_UA_ResponseHeader(responseHeaderSV, in.responseHeader);
	hv_stores(hash, "ActivateSessionResponse_responseHeader", responseHeaderSV);

	SV *serverNonceSV = newSV(0);
	XS_pack_UA_ByteString(serverNonceSV, in.serverNonce);
	hv_stores(hash, "ActivateSessionResponse_serverNonce", serverNonceSV);

	AV *resultsArray = (AV*) sv_2mortal((SV*)newAV());
	size_t resultsI;
	for(resultsI = 0; resultsI < in.resultsSize; resultsI++) {
		SV *element = newSV(0);
		XS_pack_UA_StatusCode(element, in.results[resultsI]);
		av_push(resultsArray, element);
	}
	hv_stores(hash, "ActivateSessionResponse_results", newRV_inc((SV*)resultsArray));

	AV *diagnosticInfosArray = (AV*) sv_2mortal((SV*)newAV());
	size_t diagnosticInfosI;
	for(diagnosticInfosI = 0; diagnosticInfosI < in.diagnosticInfosSize; diagnosticInfosI++) {
		SV *element = newSV(0);
		XS_pack_UA_DiagnosticInfo(element, in.diagnosticInfos[diagnosticInfosI]);
		av_push(diagnosticInfosArray, element);
	}
	hv_stores(hash, "ActivateSessionResponse_diagnosticInfos", newRV_inc((SV*)diagnosticInfosArray));

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_ActivateSessionResponse XS_unpack_UA_ActivateSessionResponse(SV *in)  __attribute__((unused));
static UA_ActivateSessionResponse
XS_unpack_UA_ActivateSessionResponse(SV *in)
{
	UA_ActivateSessionResponse out;
	SV **value;
	HV *hv;

	UA_ActivateSessionResponse_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "ActivateSessionResponse_responseHeader", 0);
	if (value != NULL)
		out.responseHeader = XS_unpack_UA_ResponseHeader(*value);

	value = hv_fetchs(hv, "ActivateSessionResponse_serverNonce", 0);
	if (value != NULL)
		out.serverNonce = XS_unpack_UA_ByteString(*value);

	/* TODO Implement array conversion for field results */

	/* TODO Implement array conversion for field diagnosticInfos */

	return out;
}

/* CloseSessionRequest */
static void XS_pack_UA_CloseSessionRequest(SV *out, UA_CloseSessionRequest in)  __attribute__((unused));
static void
XS_pack_UA_CloseSessionRequest(SV *out, UA_CloseSessionRequest in)
{
	HV *hash = newHV();

	SV *requestHeaderSV = newSV(0);
	XS_pack_UA_RequestHeader(requestHeaderSV, in.requestHeader);
	hv_stores(hash, "CloseSessionRequest_requestHeader", requestHeaderSV);

	SV *deleteSubscriptionsSV = newSV(0);
	XS_pack_UA_Boolean(deleteSubscriptionsSV, in.deleteSubscriptions);
	hv_stores(hash, "CloseSessionRequest_deleteSubscriptions", deleteSubscriptionsSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_CloseSessionRequest XS_unpack_UA_CloseSessionRequest(SV *in)  __attribute__((unused));
static UA_CloseSessionRequest
XS_unpack_UA_CloseSessionRequest(SV *in)
{
	UA_CloseSessionRequest out;
	SV **value;
	HV *hv;

	UA_CloseSessionRequest_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "CloseSessionRequest_requestHeader", 0);
	if (value != NULL)
		out.requestHeader = XS_unpack_UA_RequestHeader(*value);

	value = hv_fetchs(hv, "CloseSessionRequest_deleteSubscriptions", 0);
	if (value != NULL)
		out.deleteSubscriptions = XS_unpack_UA_Boolean(*value);

	return out;
}

/* CloseSessionResponse */
static void XS_pack_UA_CloseSessionResponse(SV *out, UA_CloseSessionResponse in)  __attribute__((unused));
static void
XS_pack_UA_CloseSessionResponse(SV *out, UA_CloseSessionResponse in)
{
	HV *hash = newHV();

	SV *responseHeaderSV = newSV(0);
	XS_pack_UA_ResponseHeader(responseHeaderSV, in.responseHeader);
	hv_stores(hash, "CloseSessionResponse_responseHeader", responseHeaderSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_CloseSessionResponse XS_unpack_UA_CloseSessionResponse(SV *in)  __attribute__((unused));
static UA_CloseSessionResponse
XS_unpack_UA_CloseSessionResponse(SV *in)
{
	UA_CloseSessionResponse out;
	SV **value;
	HV *hv;

	UA_CloseSessionResponse_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "CloseSessionResponse_responseHeader", 0);
	if (value != NULL)
		out.responseHeader = XS_unpack_UA_ResponseHeader(*value);

	return out;
}

/* NodeAttributesMask */
static void XS_pack_UA_NodeAttributesMask(SV *out, UA_NodeAttributesMask in)  __attribute__((unused));
static void
XS_pack_UA_NodeAttributesMask(SV *out, UA_NodeAttributesMask in)
{
	/* TODO implement EnumerationType conversion */

}

static UA_NodeAttributesMask XS_unpack_UA_NodeAttributesMask(SV *in)  __attribute__((unused));
static UA_NodeAttributesMask
XS_unpack_UA_NodeAttributesMask(SV *in)
{
	/* TODO implement EnumerationType conversion */
}

/* NodeAttributes */
static void XS_pack_UA_NodeAttributes(SV *out, UA_NodeAttributes in)  __attribute__((unused));
static void
XS_pack_UA_NodeAttributes(SV *out, UA_NodeAttributes in)
{
	HV *hash = newHV();

	SV *specifiedAttributesSV = newSV(0);
	XS_pack_UA_UInt32(specifiedAttributesSV, in.specifiedAttributes);
	hv_stores(hash, "NodeAttributes_specifiedAttributes", specifiedAttributesSV);

	SV *displayNameSV = newSV(0);
	XS_pack_UA_LocalizedText(displayNameSV, in.displayName);
	hv_stores(hash, "NodeAttributes_displayName", displayNameSV);

	SV *descriptionSV = newSV(0);
	XS_pack_UA_LocalizedText(descriptionSV, in.description);
	hv_stores(hash, "NodeAttributes_description", descriptionSV);

	SV *writeMaskSV = newSV(0);
	XS_pack_UA_UInt32(writeMaskSV, in.writeMask);
	hv_stores(hash, "NodeAttributes_writeMask", writeMaskSV);

	SV *userWriteMaskSV = newSV(0);
	XS_pack_UA_UInt32(userWriteMaskSV, in.userWriteMask);
	hv_stores(hash, "NodeAttributes_userWriteMask", userWriteMaskSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_NodeAttributes XS_unpack_UA_NodeAttributes(SV *in)  __attribute__((unused));
static UA_NodeAttributes
XS_unpack_UA_NodeAttributes(SV *in)
{
	UA_NodeAttributes out;
	SV **value;
	HV *hv;

	UA_NodeAttributes_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "NodeAttributes_specifiedAttributes", 0);
	if (value != NULL)
		out.specifiedAttributes = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "NodeAttributes_displayName", 0);
	if (value != NULL)
		out.displayName = XS_unpack_UA_LocalizedText(*value);

	value = hv_fetchs(hv, "NodeAttributes_description", 0);
	if (value != NULL)
		out.description = XS_unpack_UA_LocalizedText(*value);

	value = hv_fetchs(hv, "NodeAttributes_writeMask", 0);
	if (value != NULL)
		out.writeMask = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "NodeAttributes_userWriteMask", 0);
	if (value != NULL)
		out.userWriteMask = XS_unpack_UA_UInt32(*value);

	return out;
}

/* ObjectAttributes */
static void XS_pack_UA_ObjectAttributes(SV *out, UA_ObjectAttributes in)  __attribute__((unused));
static void
XS_pack_UA_ObjectAttributes(SV *out, UA_ObjectAttributes in)
{
	HV *hash = newHV();

	SV *specifiedAttributesSV = newSV(0);
	XS_pack_UA_UInt32(specifiedAttributesSV, in.specifiedAttributes);
	hv_stores(hash, "ObjectAttributes_specifiedAttributes", specifiedAttributesSV);

	SV *displayNameSV = newSV(0);
	XS_pack_UA_LocalizedText(displayNameSV, in.displayName);
	hv_stores(hash, "ObjectAttributes_displayName", displayNameSV);

	SV *descriptionSV = newSV(0);
	XS_pack_UA_LocalizedText(descriptionSV, in.description);
	hv_stores(hash, "ObjectAttributes_description", descriptionSV);

	SV *writeMaskSV = newSV(0);
	XS_pack_UA_UInt32(writeMaskSV, in.writeMask);
	hv_stores(hash, "ObjectAttributes_writeMask", writeMaskSV);

	SV *userWriteMaskSV = newSV(0);
	XS_pack_UA_UInt32(userWriteMaskSV, in.userWriteMask);
	hv_stores(hash, "ObjectAttributes_userWriteMask", userWriteMaskSV);

	SV *eventNotifierSV = newSV(0);
	XS_pack_UA_Byte(eventNotifierSV, in.eventNotifier);
	hv_stores(hash, "ObjectAttributes_eventNotifier", eventNotifierSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_ObjectAttributes XS_unpack_UA_ObjectAttributes(SV *in)  __attribute__((unused));
static UA_ObjectAttributes
XS_unpack_UA_ObjectAttributes(SV *in)
{
	UA_ObjectAttributes out;
	SV **value;
	HV *hv;

	UA_ObjectAttributes_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "ObjectAttributes_specifiedAttributes", 0);
	if (value != NULL)
		out.specifiedAttributes = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "ObjectAttributes_displayName", 0);
	if (value != NULL)
		out.displayName = XS_unpack_UA_LocalizedText(*value);

	value = hv_fetchs(hv, "ObjectAttributes_description", 0);
	if (value != NULL)
		out.description = XS_unpack_UA_LocalizedText(*value);

	value = hv_fetchs(hv, "ObjectAttributes_writeMask", 0);
	if (value != NULL)
		out.writeMask = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "ObjectAttributes_userWriteMask", 0);
	if (value != NULL)
		out.userWriteMask = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "ObjectAttributes_eventNotifier", 0);
	if (value != NULL)
		out.eventNotifier = XS_unpack_UA_Byte(*value);

	return out;
}

/* VariableAttributes */
static void XS_pack_UA_VariableAttributes(SV *out, UA_VariableAttributes in)  __attribute__((unused));
static void
XS_pack_UA_VariableAttributes(SV *out, UA_VariableAttributes in)
{
	HV *hash = newHV();

	SV *specifiedAttributesSV = newSV(0);
	XS_pack_UA_UInt32(specifiedAttributesSV, in.specifiedAttributes);
	hv_stores(hash, "VariableAttributes_specifiedAttributes", specifiedAttributesSV);

	SV *displayNameSV = newSV(0);
	XS_pack_UA_LocalizedText(displayNameSV, in.displayName);
	hv_stores(hash, "VariableAttributes_displayName", displayNameSV);

	SV *descriptionSV = newSV(0);
	XS_pack_UA_LocalizedText(descriptionSV, in.description);
	hv_stores(hash, "VariableAttributes_description", descriptionSV);

	SV *writeMaskSV = newSV(0);
	XS_pack_UA_UInt32(writeMaskSV, in.writeMask);
	hv_stores(hash, "VariableAttributes_writeMask", writeMaskSV);

	SV *userWriteMaskSV = newSV(0);
	XS_pack_UA_UInt32(userWriteMaskSV, in.userWriteMask);
	hv_stores(hash, "VariableAttributes_userWriteMask", userWriteMaskSV);

	SV *valueSV = newSV(0);
	XS_pack_UA_Variant(valueSV, in.value);
	hv_stores(hash, "VariableAttributes_value", valueSV);

	SV *dataTypeSV = newSV(0);
	XS_pack_UA_NodeId(dataTypeSV, in.dataType);
	hv_stores(hash, "VariableAttributes_dataType", dataTypeSV);

	SV *valueRankSV = newSV(0);
	XS_pack_UA_Int32(valueRankSV, in.valueRank);
	hv_stores(hash, "VariableAttributes_valueRank", valueRankSV);

	AV *arrayDimensionsArray = (AV*) sv_2mortal((SV*)newAV());
	size_t arrayDimensionsI;
	for(arrayDimensionsI = 0; arrayDimensionsI < in.arrayDimensionsSize; arrayDimensionsI++) {
		SV *element = newSV(0);
		XS_pack_UA_UInt32(element, in.arrayDimensions[arrayDimensionsI]);
		av_push(arrayDimensionsArray, element);
	}
	hv_stores(hash, "VariableAttributes_arrayDimensions", newRV_inc((SV*)arrayDimensionsArray));

	SV *accessLevelSV = newSV(0);
	XS_pack_UA_Byte(accessLevelSV, in.accessLevel);
	hv_stores(hash, "VariableAttributes_accessLevel", accessLevelSV);

	SV *userAccessLevelSV = newSV(0);
	XS_pack_UA_Byte(userAccessLevelSV, in.userAccessLevel);
	hv_stores(hash, "VariableAttributes_userAccessLevel", userAccessLevelSV);

	SV *minimumSamplingIntervalSV = newSV(0);
	XS_pack_UA_Double(minimumSamplingIntervalSV, in.minimumSamplingInterval);
	hv_stores(hash, "VariableAttributes_minimumSamplingInterval", minimumSamplingIntervalSV);

	SV *historizingSV = newSV(0);
	XS_pack_UA_Boolean(historizingSV, in.historizing);
	hv_stores(hash, "VariableAttributes_historizing", historizingSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_VariableAttributes XS_unpack_UA_VariableAttributes(SV *in)  __attribute__((unused));
static UA_VariableAttributes
XS_unpack_UA_VariableAttributes(SV *in)
{
	UA_VariableAttributes out;
	SV **value;
	HV *hv;

	UA_VariableAttributes_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "VariableAttributes_specifiedAttributes", 0);
	if (value != NULL)
		out.specifiedAttributes = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "VariableAttributes_displayName", 0);
	if (value != NULL)
		out.displayName = XS_unpack_UA_LocalizedText(*value);

	value = hv_fetchs(hv, "VariableAttributes_description", 0);
	if (value != NULL)
		out.description = XS_unpack_UA_LocalizedText(*value);

	value = hv_fetchs(hv, "VariableAttributes_writeMask", 0);
	if (value != NULL)
		out.writeMask = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "VariableAttributes_userWriteMask", 0);
	if (value != NULL)
		out.userWriteMask = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "VariableAttributes_value", 0);
	if (value != NULL)
		out.value = XS_unpack_UA_Variant(*value);

	value = hv_fetchs(hv, "VariableAttributes_dataType", 0);
	if (value != NULL)
		out.dataType = XS_unpack_UA_NodeId(*value);

	value = hv_fetchs(hv, "VariableAttributes_valueRank", 0);
	if (value != NULL)
		out.valueRank = XS_unpack_UA_Int32(*value);

	/* TODO Implement array conversion for field arrayDimensions */

	value = hv_fetchs(hv, "VariableAttributes_accessLevel", 0);
	if (value != NULL)
		out.accessLevel = XS_unpack_UA_Byte(*value);

	value = hv_fetchs(hv, "VariableAttributes_userAccessLevel", 0);
	if (value != NULL)
		out.userAccessLevel = XS_unpack_UA_Byte(*value);

	value = hv_fetchs(hv, "VariableAttributes_minimumSamplingInterval", 0);
	if (value != NULL)
		out.minimumSamplingInterval = XS_unpack_UA_Double(*value);

	value = hv_fetchs(hv, "VariableAttributes_historizing", 0);
	if (value != NULL)
		out.historizing = XS_unpack_UA_Boolean(*value);

	return out;
}

/* MethodAttributes */
static void XS_pack_UA_MethodAttributes(SV *out, UA_MethodAttributes in)  __attribute__((unused));
static void
XS_pack_UA_MethodAttributes(SV *out, UA_MethodAttributes in)
{
	HV *hash = newHV();

	SV *specifiedAttributesSV = newSV(0);
	XS_pack_UA_UInt32(specifiedAttributesSV, in.specifiedAttributes);
	hv_stores(hash, "MethodAttributes_specifiedAttributes", specifiedAttributesSV);

	SV *displayNameSV = newSV(0);
	XS_pack_UA_LocalizedText(displayNameSV, in.displayName);
	hv_stores(hash, "MethodAttributes_displayName", displayNameSV);

	SV *descriptionSV = newSV(0);
	XS_pack_UA_LocalizedText(descriptionSV, in.description);
	hv_stores(hash, "MethodAttributes_description", descriptionSV);

	SV *writeMaskSV = newSV(0);
	XS_pack_UA_UInt32(writeMaskSV, in.writeMask);
	hv_stores(hash, "MethodAttributes_writeMask", writeMaskSV);

	SV *userWriteMaskSV = newSV(0);
	XS_pack_UA_UInt32(userWriteMaskSV, in.userWriteMask);
	hv_stores(hash, "MethodAttributes_userWriteMask", userWriteMaskSV);

	SV *executableSV = newSV(0);
	XS_pack_UA_Boolean(executableSV, in.executable);
	hv_stores(hash, "MethodAttributes_executable", executableSV);

	SV *userExecutableSV = newSV(0);
	XS_pack_UA_Boolean(userExecutableSV, in.userExecutable);
	hv_stores(hash, "MethodAttributes_userExecutable", userExecutableSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_MethodAttributes XS_unpack_UA_MethodAttributes(SV *in)  __attribute__((unused));
static UA_MethodAttributes
XS_unpack_UA_MethodAttributes(SV *in)
{
	UA_MethodAttributes out;
	SV **value;
	HV *hv;

	UA_MethodAttributes_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "MethodAttributes_specifiedAttributes", 0);
	if (value != NULL)
		out.specifiedAttributes = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "MethodAttributes_displayName", 0);
	if (value != NULL)
		out.displayName = XS_unpack_UA_LocalizedText(*value);

	value = hv_fetchs(hv, "MethodAttributes_description", 0);
	if (value != NULL)
		out.description = XS_unpack_UA_LocalizedText(*value);

	value = hv_fetchs(hv, "MethodAttributes_writeMask", 0);
	if (value != NULL)
		out.writeMask = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "MethodAttributes_userWriteMask", 0);
	if (value != NULL)
		out.userWriteMask = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "MethodAttributes_executable", 0);
	if (value != NULL)
		out.executable = XS_unpack_UA_Boolean(*value);

	value = hv_fetchs(hv, "MethodAttributes_userExecutable", 0);
	if (value != NULL)
		out.userExecutable = XS_unpack_UA_Boolean(*value);

	return out;
}

/* ObjectTypeAttributes */
static void XS_pack_UA_ObjectTypeAttributes(SV *out, UA_ObjectTypeAttributes in)  __attribute__((unused));
static void
XS_pack_UA_ObjectTypeAttributes(SV *out, UA_ObjectTypeAttributes in)
{
	HV *hash = newHV();

	SV *specifiedAttributesSV = newSV(0);
	XS_pack_UA_UInt32(specifiedAttributesSV, in.specifiedAttributes);
	hv_stores(hash, "ObjectTypeAttributes_specifiedAttributes", specifiedAttributesSV);

	SV *displayNameSV = newSV(0);
	XS_pack_UA_LocalizedText(displayNameSV, in.displayName);
	hv_stores(hash, "ObjectTypeAttributes_displayName", displayNameSV);

	SV *descriptionSV = newSV(0);
	XS_pack_UA_LocalizedText(descriptionSV, in.description);
	hv_stores(hash, "ObjectTypeAttributes_description", descriptionSV);

	SV *writeMaskSV = newSV(0);
	XS_pack_UA_UInt32(writeMaskSV, in.writeMask);
	hv_stores(hash, "ObjectTypeAttributes_writeMask", writeMaskSV);

	SV *userWriteMaskSV = newSV(0);
	XS_pack_UA_UInt32(userWriteMaskSV, in.userWriteMask);
	hv_stores(hash, "ObjectTypeAttributes_userWriteMask", userWriteMaskSV);

	SV *isAbstractSV = newSV(0);
	XS_pack_UA_Boolean(isAbstractSV, in.isAbstract);
	hv_stores(hash, "ObjectTypeAttributes_isAbstract", isAbstractSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_ObjectTypeAttributes XS_unpack_UA_ObjectTypeAttributes(SV *in)  __attribute__((unused));
static UA_ObjectTypeAttributes
XS_unpack_UA_ObjectTypeAttributes(SV *in)
{
	UA_ObjectTypeAttributes out;
	SV **value;
	HV *hv;

	UA_ObjectTypeAttributes_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "ObjectTypeAttributes_specifiedAttributes", 0);
	if (value != NULL)
		out.specifiedAttributes = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "ObjectTypeAttributes_displayName", 0);
	if (value != NULL)
		out.displayName = XS_unpack_UA_LocalizedText(*value);

	value = hv_fetchs(hv, "ObjectTypeAttributes_description", 0);
	if (value != NULL)
		out.description = XS_unpack_UA_LocalizedText(*value);

	value = hv_fetchs(hv, "ObjectTypeAttributes_writeMask", 0);
	if (value != NULL)
		out.writeMask = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "ObjectTypeAttributes_userWriteMask", 0);
	if (value != NULL)
		out.userWriteMask = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "ObjectTypeAttributes_isAbstract", 0);
	if (value != NULL)
		out.isAbstract = XS_unpack_UA_Boolean(*value);

	return out;
}

/* VariableTypeAttributes */
static void XS_pack_UA_VariableTypeAttributes(SV *out, UA_VariableTypeAttributes in)  __attribute__((unused));
static void
XS_pack_UA_VariableTypeAttributes(SV *out, UA_VariableTypeAttributes in)
{
	HV *hash = newHV();

	SV *specifiedAttributesSV = newSV(0);
	XS_pack_UA_UInt32(specifiedAttributesSV, in.specifiedAttributes);
	hv_stores(hash, "VariableTypeAttributes_specifiedAttributes", specifiedAttributesSV);

	SV *displayNameSV = newSV(0);
	XS_pack_UA_LocalizedText(displayNameSV, in.displayName);
	hv_stores(hash, "VariableTypeAttributes_displayName", displayNameSV);

	SV *descriptionSV = newSV(0);
	XS_pack_UA_LocalizedText(descriptionSV, in.description);
	hv_stores(hash, "VariableTypeAttributes_description", descriptionSV);

	SV *writeMaskSV = newSV(0);
	XS_pack_UA_UInt32(writeMaskSV, in.writeMask);
	hv_stores(hash, "VariableTypeAttributes_writeMask", writeMaskSV);

	SV *userWriteMaskSV = newSV(0);
	XS_pack_UA_UInt32(userWriteMaskSV, in.userWriteMask);
	hv_stores(hash, "VariableTypeAttributes_userWriteMask", userWriteMaskSV);

	SV *valueSV = newSV(0);
	XS_pack_UA_Variant(valueSV, in.value);
	hv_stores(hash, "VariableTypeAttributes_value", valueSV);

	SV *dataTypeSV = newSV(0);
	XS_pack_UA_NodeId(dataTypeSV, in.dataType);
	hv_stores(hash, "VariableTypeAttributes_dataType", dataTypeSV);

	SV *valueRankSV = newSV(0);
	XS_pack_UA_Int32(valueRankSV, in.valueRank);
	hv_stores(hash, "VariableTypeAttributes_valueRank", valueRankSV);

	AV *arrayDimensionsArray = (AV*) sv_2mortal((SV*)newAV());
	size_t arrayDimensionsI;
	for(arrayDimensionsI = 0; arrayDimensionsI < in.arrayDimensionsSize; arrayDimensionsI++) {
		SV *element = newSV(0);
		XS_pack_UA_UInt32(element, in.arrayDimensions[arrayDimensionsI]);
		av_push(arrayDimensionsArray, element);
	}
	hv_stores(hash, "VariableTypeAttributes_arrayDimensions", newRV_inc((SV*)arrayDimensionsArray));

	SV *isAbstractSV = newSV(0);
	XS_pack_UA_Boolean(isAbstractSV, in.isAbstract);
	hv_stores(hash, "VariableTypeAttributes_isAbstract", isAbstractSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_VariableTypeAttributes XS_unpack_UA_VariableTypeAttributes(SV *in)  __attribute__((unused));
static UA_VariableTypeAttributes
XS_unpack_UA_VariableTypeAttributes(SV *in)
{
	UA_VariableTypeAttributes out;
	SV **value;
	HV *hv;

	UA_VariableTypeAttributes_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "VariableTypeAttributes_specifiedAttributes", 0);
	if (value != NULL)
		out.specifiedAttributes = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "VariableTypeAttributes_displayName", 0);
	if (value != NULL)
		out.displayName = XS_unpack_UA_LocalizedText(*value);

	value = hv_fetchs(hv, "VariableTypeAttributes_description", 0);
	if (value != NULL)
		out.description = XS_unpack_UA_LocalizedText(*value);

	value = hv_fetchs(hv, "VariableTypeAttributes_writeMask", 0);
	if (value != NULL)
		out.writeMask = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "VariableTypeAttributes_userWriteMask", 0);
	if (value != NULL)
		out.userWriteMask = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "VariableTypeAttributes_value", 0);
	if (value != NULL)
		out.value = XS_unpack_UA_Variant(*value);

	value = hv_fetchs(hv, "VariableTypeAttributes_dataType", 0);
	if (value != NULL)
		out.dataType = XS_unpack_UA_NodeId(*value);

	value = hv_fetchs(hv, "VariableTypeAttributes_valueRank", 0);
	if (value != NULL)
		out.valueRank = XS_unpack_UA_Int32(*value);

	/* TODO Implement array conversion for field arrayDimensions */

	value = hv_fetchs(hv, "VariableTypeAttributes_isAbstract", 0);
	if (value != NULL)
		out.isAbstract = XS_unpack_UA_Boolean(*value);

	return out;
}

/* ReferenceTypeAttributes */
static void XS_pack_UA_ReferenceTypeAttributes(SV *out, UA_ReferenceTypeAttributes in)  __attribute__((unused));
static void
XS_pack_UA_ReferenceTypeAttributes(SV *out, UA_ReferenceTypeAttributes in)
{
	HV *hash = newHV();

	SV *specifiedAttributesSV = newSV(0);
	XS_pack_UA_UInt32(specifiedAttributesSV, in.specifiedAttributes);
	hv_stores(hash, "ReferenceTypeAttributes_specifiedAttributes", specifiedAttributesSV);

	SV *displayNameSV = newSV(0);
	XS_pack_UA_LocalizedText(displayNameSV, in.displayName);
	hv_stores(hash, "ReferenceTypeAttributes_displayName", displayNameSV);

	SV *descriptionSV = newSV(0);
	XS_pack_UA_LocalizedText(descriptionSV, in.description);
	hv_stores(hash, "ReferenceTypeAttributes_description", descriptionSV);

	SV *writeMaskSV = newSV(0);
	XS_pack_UA_UInt32(writeMaskSV, in.writeMask);
	hv_stores(hash, "ReferenceTypeAttributes_writeMask", writeMaskSV);

	SV *userWriteMaskSV = newSV(0);
	XS_pack_UA_UInt32(userWriteMaskSV, in.userWriteMask);
	hv_stores(hash, "ReferenceTypeAttributes_userWriteMask", userWriteMaskSV);

	SV *isAbstractSV = newSV(0);
	XS_pack_UA_Boolean(isAbstractSV, in.isAbstract);
	hv_stores(hash, "ReferenceTypeAttributes_isAbstract", isAbstractSV);

	SV *symmetricSV = newSV(0);
	XS_pack_UA_Boolean(symmetricSV, in.symmetric);
	hv_stores(hash, "ReferenceTypeAttributes_symmetric", symmetricSV);

	SV *inverseNameSV = newSV(0);
	XS_pack_UA_LocalizedText(inverseNameSV, in.inverseName);
	hv_stores(hash, "ReferenceTypeAttributes_inverseName", inverseNameSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_ReferenceTypeAttributes XS_unpack_UA_ReferenceTypeAttributes(SV *in)  __attribute__((unused));
static UA_ReferenceTypeAttributes
XS_unpack_UA_ReferenceTypeAttributes(SV *in)
{
	UA_ReferenceTypeAttributes out;
	SV **value;
	HV *hv;

	UA_ReferenceTypeAttributes_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "ReferenceTypeAttributes_specifiedAttributes", 0);
	if (value != NULL)
		out.specifiedAttributes = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "ReferenceTypeAttributes_displayName", 0);
	if (value != NULL)
		out.displayName = XS_unpack_UA_LocalizedText(*value);

	value = hv_fetchs(hv, "ReferenceTypeAttributes_description", 0);
	if (value != NULL)
		out.description = XS_unpack_UA_LocalizedText(*value);

	value = hv_fetchs(hv, "ReferenceTypeAttributes_writeMask", 0);
	if (value != NULL)
		out.writeMask = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "ReferenceTypeAttributes_userWriteMask", 0);
	if (value != NULL)
		out.userWriteMask = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "ReferenceTypeAttributes_isAbstract", 0);
	if (value != NULL)
		out.isAbstract = XS_unpack_UA_Boolean(*value);

	value = hv_fetchs(hv, "ReferenceTypeAttributes_symmetric", 0);
	if (value != NULL)
		out.symmetric = XS_unpack_UA_Boolean(*value);

	value = hv_fetchs(hv, "ReferenceTypeAttributes_inverseName", 0);
	if (value != NULL)
		out.inverseName = XS_unpack_UA_LocalizedText(*value);

	return out;
}

/* DataTypeAttributes */
static void XS_pack_UA_DataTypeAttributes(SV *out, UA_DataTypeAttributes in)  __attribute__((unused));
static void
XS_pack_UA_DataTypeAttributes(SV *out, UA_DataTypeAttributes in)
{
	HV *hash = newHV();

	SV *specifiedAttributesSV = newSV(0);
	XS_pack_UA_UInt32(specifiedAttributesSV, in.specifiedAttributes);
	hv_stores(hash, "DataTypeAttributes_specifiedAttributes", specifiedAttributesSV);

	SV *displayNameSV = newSV(0);
	XS_pack_UA_LocalizedText(displayNameSV, in.displayName);
	hv_stores(hash, "DataTypeAttributes_displayName", displayNameSV);

	SV *descriptionSV = newSV(0);
	XS_pack_UA_LocalizedText(descriptionSV, in.description);
	hv_stores(hash, "DataTypeAttributes_description", descriptionSV);

	SV *writeMaskSV = newSV(0);
	XS_pack_UA_UInt32(writeMaskSV, in.writeMask);
	hv_stores(hash, "DataTypeAttributes_writeMask", writeMaskSV);

	SV *userWriteMaskSV = newSV(0);
	XS_pack_UA_UInt32(userWriteMaskSV, in.userWriteMask);
	hv_stores(hash, "DataTypeAttributes_userWriteMask", userWriteMaskSV);

	SV *isAbstractSV = newSV(0);
	XS_pack_UA_Boolean(isAbstractSV, in.isAbstract);
	hv_stores(hash, "DataTypeAttributes_isAbstract", isAbstractSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_DataTypeAttributes XS_unpack_UA_DataTypeAttributes(SV *in)  __attribute__((unused));
static UA_DataTypeAttributes
XS_unpack_UA_DataTypeAttributes(SV *in)
{
	UA_DataTypeAttributes out;
	SV **value;
	HV *hv;

	UA_DataTypeAttributes_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "DataTypeAttributes_specifiedAttributes", 0);
	if (value != NULL)
		out.specifiedAttributes = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "DataTypeAttributes_displayName", 0);
	if (value != NULL)
		out.displayName = XS_unpack_UA_LocalizedText(*value);

	value = hv_fetchs(hv, "DataTypeAttributes_description", 0);
	if (value != NULL)
		out.description = XS_unpack_UA_LocalizedText(*value);

	value = hv_fetchs(hv, "DataTypeAttributes_writeMask", 0);
	if (value != NULL)
		out.writeMask = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "DataTypeAttributes_userWriteMask", 0);
	if (value != NULL)
		out.userWriteMask = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "DataTypeAttributes_isAbstract", 0);
	if (value != NULL)
		out.isAbstract = XS_unpack_UA_Boolean(*value);

	return out;
}

/* ViewAttributes */
static void XS_pack_UA_ViewAttributes(SV *out, UA_ViewAttributes in)  __attribute__((unused));
static void
XS_pack_UA_ViewAttributes(SV *out, UA_ViewAttributes in)
{
	HV *hash = newHV();

	SV *specifiedAttributesSV = newSV(0);
	XS_pack_UA_UInt32(specifiedAttributesSV, in.specifiedAttributes);
	hv_stores(hash, "ViewAttributes_specifiedAttributes", specifiedAttributesSV);

	SV *displayNameSV = newSV(0);
	XS_pack_UA_LocalizedText(displayNameSV, in.displayName);
	hv_stores(hash, "ViewAttributes_displayName", displayNameSV);

	SV *descriptionSV = newSV(0);
	XS_pack_UA_LocalizedText(descriptionSV, in.description);
	hv_stores(hash, "ViewAttributes_description", descriptionSV);

	SV *writeMaskSV = newSV(0);
	XS_pack_UA_UInt32(writeMaskSV, in.writeMask);
	hv_stores(hash, "ViewAttributes_writeMask", writeMaskSV);

	SV *userWriteMaskSV = newSV(0);
	XS_pack_UA_UInt32(userWriteMaskSV, in.userWriteMask);
	hv_stores(hash, "ViewAttributes_userWriteMask", userWriteMaskSV);

	SV *containsNoLoopsSV = newSV(0);
	XS_pack_UA_Boolean(containsNoLoopsSV, in.containsNoLoops);
	hv_stores(hash, "ViewAttributes_containsNoLoops", containsNoLoopsSV);

	SV *eventNotifierSV = newSV(0);
	XS_pack_UA_Byte(eventNotifierSV, in.eventNotifier);
	hv_stores(hash, "ViewAttributes_eventNotifier", eventNotifierSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_ViewAttributes XS_unpack_UA_ViewAttributes(SV *in)  __attribute__((unused));
static UA_ViewAttributes
XS_unpack_UA_ViewAttributes(SV *in)
{
	UA_ViewAttributes out;
	SV **value;
	HV *hv;

	UA_ViewAttributes_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "ViewAttributes_specifiedAttributes", 0);
	if (value != NULL)
		out.specifiedAttributes = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "ViewAttributes_displayName", 0);
	if (value != NULL)
		out.displayName = XS_unpack_UA_LocalizedText(*value);

	value = hv_fetchs(hv, "ViewAttributes_description", 0);
	if (value != NULL)
		out.description = XS_unpack_UA_LocalizedText(*value);

	value = hv_fetchs(hv, "ViewAttributes_writeMask", 0);
	if (value != NULL)
		out.writeMask = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "ViewAttributes_userWriteMask", 0);
	if (value != NULL)
		out.userWriteMask = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "ViewAttributes_containsNoLoops", 0);
	if (value != NULL)
		out.containsNoLoops = XS_unpack_UA_Boolean(*value);

	value = hv_fetchs(hv, "ViewAttributes_eventNotifier", 0);
	if (value != NULL)
		out.eventNotifier = XS_unpack_UA_Byte(*value);

	return out;
}

/* AddNodesItem */
static void XS_pack_UA_AddNodesItem(SV *out, UA_AddNodesItem in)  __attribute__((unused));
static void
XS_pack_UA_AddNodesItem(SV *out, UA_AddNodesItem in)
{
	HV *hash = newHV();

	SV *parentNodeIdSV = newSV(0);
	XS_pack_UA_ExpandedNodeId(parentNodeIdSV, in.parentNodeId);
	hv_stores(hash, "AddNodesItem_parentNodeId", parentNodeIdSV);

	SV *referenceTypeIdSV = newSV(0);
	XS_pack_UA_NodeId(referenceTypeIdSV, in.referenceTypeId);
	hv_stores(hash, "AddNodesItem_referenceTypeId", referenceTypeIdSV);

	SV *requestedNewNodeIdSV = newSV(0);
	XS_pack_UA_ExpandedNodeId(requestedNewNodeIdSV, in.requestedNewNodeId);
	hv_stores(hash, "AddNodesItem_requestedNewNodeId", requestedNewNodeIdSV);

	SV *browseNameSV = newSV(0);
	XS_pack_UA_QualifiedName(browseNameSV, in.browseName);
	hv_stores(hash, "AddNodesItem_browseName", browseNameSV);

	SV *nodeClassSV = newSV(0);
	XS_pack_UA_NodeClass(nodeClassSV, in.nodeClass);
	hv_stores(hash, "AddNodesItem_nodeClass", nodeClassSV);

	SV *nodeAttributesSV = newSV(0);
	XS_pack_UA_ExtensionObject(nodeAttributesSV, in.nodeAttributes);
	hv_stores(hash, "AddNodesItem_nodeAttributes", nodeAttributesSV);

	SV *typeDefinitionSV = newSV(0);
	XS_pack_UA_ExpandedNodeId(typeDefinitionSV, in.typeDefinition);
	hv_stores(hash, "AddNodesItem_typeDefinition", typeDefinitionSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_AddNodesItem XS_unpack_UA_AddNodesItem(SV *in)  __attribute__((unused));
static UA_AddNodesItem
XS_unpack_UA_AddNodesItem(SV *in)
{
	UA_AddNodesItem out;
	SV **value;
	HV *hv;

	UA_AddNodesItem_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "AddNodesItem_parentNodeId", 0);
	if (value != NULL)
		out.parentNodeId = XS_unpack_UA_ExpandedNodeId(*value);

	value = hv_fetchs(hv, "AddNodesItem_referenceTypeId", 0);
	if (value != NULL)
		out.referenceTypeId = XS_unpack_UA_NodeId(*value);

	value = hv_fetchs(hv, "AddNodesItem_requestedNewNodeId", 0);
	if (value != NULL)
		out.requestedNewNodeId = XS_unpack_UA_ExpandedNodeId(*value);

	value = hv_fetchs(hv, "AddNodesItem_browseName", 0);
	if (value != NULL)
		out.browseName = XS_unpack_UA_QualifiedName(*value);

	value = hv_fetchs(hv, "AddNodesItem_nodeClass", 0);
	if (value != NULL)
		out.nodeClass = XS_unpack_UA_NodeClass(*value);

	value = hv_fetchs(hv, "AddNodesItem_nodeAttributes", 0);
	if (value != NULL)
		out.nodeAttributes = XS_unpack_UA_ExtensionObject(*value);

	value = hv_fetchs(hv, "AddNodesItem_typeDefinition", 0);
	if (value != NULL)
		out.typeDefinition = XS_unpack_UA_ExpandedNodeId(*value);

	return out;
}

/* AddNodesResult */
static void XS_pack_UA_AddNodesResult(SV *out, UA_AddNodesResult in)  __attribute__((unused));
static void
XS_pack_UA_AddNodesResult(SV *out, UA_AddNodesResult in)
{
	HV *hash = newHV();

	SV *statusCodeSV = newSV(0);
	XS_pack_UA_StatusCode(statusCodeSV, in.statusCode);
	hv_stores(hash, "AddNodesResult_statusCode", statusCodeSV);

	SV *addedNodeIdSV = newSV(0);
	XS_pack_UA_NodeId(addedNodeIdSV, in.addedNodeId);
	hv_stores(hash, "AddNodesResult_addedNodeId", addedNodeIdSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_AddNodesResult XS_unpack_UA_AddNodesResult(SV *in)  __attribute__((unused));
static UA_AddNodesResult
XS_unpack_UA_AddNodesResult(SV *in)
{
	UA_AddNodesResult out;
	SV **value;
	HV *hv;

	UA_AddNodesResult_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "AddNodesResult_statusCode", 0);
	if (value != NULL)
		out.statusCode = XS_unpack_UA_StatusCode(*value);

	value = hv_fetchs(hv, "AddNodesResult_addedNodeId", 0);
	if (value != NULL)
		out.addedNodeId = XS_unpack_UA_NodeId(*value);

	return out;
}

/* AddNodesRequest */
static void XS_pack_UA_AddNodesRequest(SV *out, UA_AddNodesRequest in)  __attribute__((unused));
static void
XS_pack_UA_AddNodesRequest(SV *out, UA_AddNodesRequest in)
{
	HV *hash = newHV();

	SV *requestHeaderSV = newSV(0);
	XS_pack_UA_RequestHeader(requestHeaderSV, in.requestHeader);
	hv_stores(hash, "AddNodesRequest_requestHeader", requestHeaderSV);

	AV *nodesToAddArray = (AV*) sv_2mortal((SV*)newAV());
	size_t nodesToAddI;
	for(nodesToAddI = 0; nodesToAddI < in.nodesToAddSize; nodesToAddI++) {
		SV *element = newSV(0);
		XS_pack_UA_AddNodesItem(element, in.nodesToAdd[nodesToAddI]);
		av_push(nodesToAddArray, element);
	}
	hv_stores(hash, "AddNodesRequest_nodesToAdd", newRV_inc((SV*)nodesToAddArray));

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_AddNodesRequest XS_unpack_UA_AddNodesRequest(SV *in)  __attribute__((unused));
static UA_AddNodesRequest
XS_unpack_UA_AddNodesRequest(SV *in)
{
	UA_AddNodesRequest out;
	SV **value;
	HV *hv;

	UA_AddNodesRequest_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "AddNodesRequest_requestHeader", 0);
	if (value != NULL)
		out.requestHeader = XS_unpack_UA_RequestHeader(*value);

	/* TODO Implement array conversion for field nodesToAdd */

	return out;
}

/* AddNodesResponse */
static void XS_pack_UA_AddNodesResponse(SV *out, UA_AddNodesResponse in)  __attribute__((unused));
static void
XS_pack_UA_AddNodesResponse(SV *out, UA_AddNodesResponse in)
{
	HV *hash = newHV();

	SV *responseHeaderSV = newSV(0);
	XS_pack_UA_ResponseHeader(responseHeaderSV, in.responseHeader);
	hv_stores(hash, "AddNodesResponse_responseHeader", responseHeaderSV);

	AV *resultsArray = (AV*) sv_2mortal((SV*)newAV());
	size_t resultsI;
	for(resultsI = 0; resultsI < in.resultsSize; resultsI++) {
		SV *element = newSV(0);
		XS_pack_UA_AddNodesResult(element, in.results[resultsI]);
		av_push(resultsArray, element);
	}
	hv_stores(hash, "AddNodesResponse_results", newRV_inc((SV*)resultsArray));

	AV *diagnosticInfosArray = (AV*) sv_2mortal((SV*)newAV());
	size_t diagnosticInfosI;
	for(diagnosticInfosI = 0; diagnosticInfosI < in.diagnosticInfosSize; diagnosticInfosI++) {
		SV *element = newSV(0);
		XS_pack_UA_DiagnosticInfo(element, in.diagnosticInfos[diagnosticInfosI]);
		av_push(diagnosticInfosArray, element);
	}
	hv_stores(hash, "AddNodesResponse_diagnosticInfos", newRV_inc((SV*)diagnosticInfosArray));

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_AddNodesResponse XS_unpack_UA_AddNodesResponse(SV *in)  __attribute__((unused));
static UA_AddNodesResponse
XS_unpack_UA_AddNodesResponse(SV *in)
{
	UA_AddNodesResponse out;
	SV **value;
	HV *hv;

	UA_AddNodesResponse_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "AddNodesResponse_responseHeader", 0);
	if (value != NULL)
		out.responseHeader = XS_unpack_UA_ResponseHeader(*value);

	/* TODO Implement array conversion for field results */

	/* TODO Implement array conversion for field diagnosticInfos */

	return out;
}

/* AddReferencesItem */
static void XS_pack_UA_AddReferencesItem(SV *out, UA_AddReferencesItem in)  __attribute__((unused));
static void
XS_pack_UA_AddReferencesItem(SV *out, UA_AddReferencesItem in)
{
	HV *hash = newHV();

	SV *sourceNodeIdSV = newSV(0);
	XS_pack_UA_NodeId(sourceNodeIdSV, in.sourceNodeId);
	hv_stores(hash, "AddReferencesItem_sourceNodeId", sourceNodeIdSV);

	SV *referenceTypeIdSV = newSV(0);
	XS_pack_UA_NodeId(referenceTypeIdSV, in.referenceTypeId);
	hv_stores(hash, "AddReferencesItem_referenceTypeId", referenceTypeIdSV);

	SV *isForwardSV = newSV(0);
	XS_pack_UA_Boolean(isForwardSV, in.isForward);
	hv_stores(hash, "AddReferencesItem_isForward", isForwardSV);

	SV *targetServerUriSV = newSV(0);
	XS_pack_UA_String(targetServerUriSV, in.targetServerUri);
	hv_stores(hash, "AddReferencesItem_targetServerUri", targetServerUriSV);

	SV *targetNodeIdSV = newSV(0);
	XS_pack_UA_ExpandedNodeId(targetNodeIdSV, in.targetNodeId);
	hv_stores(hash, "AddReferencesItem_targetNodeId", targetNodeIdSV);

	SV *targetNodeClassSV = newSV(0);
	XS_pack_UA_NodeClass(targetNodeClassSV, in.targetNodeClass);
	hv_stores(hash, "AddReferencesItem_targetNodeClass", targetNodeClassSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_AddReferencesItem XS_unpack_UA_AddReferencesItem(SV *in)  __attribute__((unused));
static UA_AddReferencesItem
XS_unpack_UA_AddReferencesItem(SV *in)
{
	UA_AddReferencesItem out;
	SV **value;
	HV *hv;

	UA_AddReferencesItem_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "AddReferencesItem_sourceNodeId", 0);
	if (value != NULL)
		out.sourceNodeId = XS_unpack_UA_NodeId(*value);

	value = hv_fetchs(hv, "AddReferencesItem_referenceTypeId", 0);
	if (value != NULL)
		out.referenceTypeId = XS_unpack_UA_NodeId(*value);

	value = hv_fetchs(hv, "AddReferencesItem_isForward", 0);
	if (value != NULL)
		out.isForward = XS_unpack_UA_Boolean(*value);

	value = hv_fetchs(hv, "AddReferencesItem_targetServerUri", 0);
	if (value != NULL)
		out.targetServerUri = XS_unpack_UA_String(*value);

	value = hv_fetchs(hv, "AddReferencesItem_targetNodeId", 0);
	if (value != NULL)
		out.targetNodeId = XS_unpack_UA_ExpandedNodeId(*value);

	value = hv_fetchs(hv, "AddReferencesItem_targetNodeClass", 0);
	if (value != NULL)
		out.targetNodeClass = XS_unpack_UA_NodeClass(*value);

	return out;
}

/* AddReferencesRequest */
static void XS_pack_UA_AddReferencesRequest(SV *out, UA_AddReferencesRequest in)  __attribute__((unused));
static void
XS_pack_UA_AddReferencesRequest(SV *out, UA_AddReferencesRequest in)
{
	HV *hash = newHV();

	SV *requestHeaderSV = newSV(0);
	XS_pack_UA_RequestHeader(requestHeaderSV, in.requestHeader);
	hv_stores(hash, "AddReferencesRequest_requestHeader", requestHeaderSV);

	AV *referencesToAddArray = (AV*) sv_2mortal((SV*)newAV());
	size_t referencesToAddI;
	for(referencesToAddI = 0; referencesToAddI < in.referencesToAddSize; referencesToAddI++) {
		SV *element = newSV(0);
		XS_pack_UA_AddReferencesItem(element, in.referencesToAdd[referencesToAddI]);
		av_push(referencesToAddArray, element);
	}
	hv_stores(hash, "AddReferencesRequest_referencesToAdd", newRV_inc((SV*)referencesToAddArray));

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_AddReferencesRequest XS_unpack_UA_AddReferencesRequest(SV *in)  __attribute__((unused));
static UA_AddReferencesRequest
XS_unpack_UA_AddReferencesRequest(SV *in)
{
	UA_AddReferencesRequest out;
	SV **value;
	HV *hv;

	UA_AddReferencesRequest_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "AddReferencesRequest_requestHeader", 0);
	if (value != NULL)
		out.requestHeader = XS_unpack_UA_RequestHeader(*value);

	/* TODO Implement array conversion for field referencesToAdd */

	return out;
}

/* AddReferencesResponse */
static void XS_pack_UA_AddReferencesResponse(SV *out, UA_AddReferencesResponse in)  __attribute__((unused));
static void
XS_pack_UA_AddReferencesResponse(SV *out, UA_AddReferencesResponse in)
{
	HV *hash = newHV();

	SV *responseHeaderSV = newSV(0);
	XS_pack_UA_ResponseHeader(responseHeaderSV, in.responseHeader);
	hv_stores(hash, "AddReferencesResponse_responseHeader", responseHeaderSV);

	AV *resultsArray = (AV*) sv_2mortal((SV*)newAV());
	size_t resultsI;
	for(resultsI = 0; resultsI < in.resultsSize; resultsI++) {
		SV *element = newSV(0);
		XS_pack_UA_StatusCode(element, in.results[resultsI]);
		av_push(resultsArray, element);
	}
	hv_stores(hash, "AddReferencesResponse_results", newRV_inc((SV*)resultsArray));

	AV *diagnosticInfosArray = (AV*) sv_2mortal((SV*)newAV());
	size_t diagnosticInfosI;
	for(diagnosticInfosI = 0; diagnosticInfosI < in.diagnosticInfosSize; diagnosticInfosI++) {
		SV *element = newSV(0);
		XS_pack_UA_DiagnosticInfo(element, in.diagnosticInfos[diagnosticInfosI]);
		av_push(diagnosticInfosArray, element);
	}
	hv_stores(hash, "AddReferencesResponse_diagnosticInfos", newRV_inc((SV*)diagnosticInfosArray));

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_AddReferencesResponse XS_unpack_UA_AddReferencesResponse(SV *in)  __attribute__((unused));
static UA_AddReferencesResponse
XS_unpack_UA_AddReferencesResponse(SV *in)
{
	UA_AddReferencesResponse out;
	SV **value;
	HV *hv;

	UA_AddReferencesResponse_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "AddReferencesResponse_responseHeader", 0);
	if (value != NULL)
		out.responseHeader = XS_unpack_UA_ResponseHeader(*value);

	/* TODO Implement array conversion for field results */

	/* TODO Implement array conversion for field diagnosticInfos */

	return out;
}

/* DeleteNodesItem */
static void XS_pack_UA_DeleteNodesItem(SV *out, UA_DeleteNodesItem in)  __attribute__((unused));
static void
XS_pack_UA_DeleteNodesItem(SV *out, UA_DeleteNodesItem in)
{
	HV *hash = newHV();

	SV *nodeIdSV = newSV(0);
	XS_pack_UA_NodeId(nodeIdSV, in.nodeId);
	hv_stores(hash, "DeleteNodesItem_nodeId", nodeIdSV);

	SV *deleteTargetReferencesSV = newSV(0);
	XS_pack_UA_Boolean(deleteTargetReferencesSV, in.deleteTargetReferences);
	hv_stores(hash, "DeleteNodesItem_deleteTargetReferences", deleteTargetReferencesSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_DeleteNodesItem XS_unpack_UA_DeleteNodesItem(SV *in)  __attribute__((unused));
static UA_DeleteNodesItem
XS_unpack_UA_DeleteNodesItem(SV *in)
{
	UA_DeleteNodesItem out;
	SV **value;
	HV *hv;

	UA_DeleteNodesItem_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "DeleteNodesItem_nodeId", 0);
	if (value != NULL)
		out.nodeId = XS_unpack_UA_NodeId(*value);

	value = hv_fetchs(hv, "DeleteNodesItem_deleteTargetReferences", 0);
	if (value != NULL)
		out.deleteTargetReferences = XS_unpack_UA_Boolean(*value);

	return out;
}

/* DeleteNodesRequest */
static void XS_pack_UA_DeleteNodesRequest(SV *out, UA_DeleteNodesRequest in)  __attribute__((unused));
static void
XS_pack_UA_DeleteNodesRequest(SV *out, UA_DeleteNodesRequest in)
{
	HV *hash = newHV();

	SV *requestHeaderSV = newSV(0);
	XS_pack_UA_RequestHeader(requestHeaderSV, in.requestHeader);
	hv_stores(hash, "DeleteNodesRequest_requestHeader", requestHeaderSV);

	AV *nodesToDeleteArray = (AV*) sv_2mortal((SV*)newAV());
	size_t nodesToDeleteI;
	for(nodesToDeleteI = 0; nodesToDeleteI < in.nodesToDeleteSize; nodesToDeleteI++) {
		SV *element = newSV(0);
		XS_pack_UA_DeleteNodesItem(element, in.nodesToDelete[nodesToDeleteI]);
		av_push(nodesToDeleteArray, element);
	}
	hv_stores(hash, "DeleteNodesRequest_nodesToDelete", newRV_inc((SV*)nodesToDeleteArray));

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_DeleteNodesRequest XS_unpack_UA_DeleteNodesRequest(SV *in)  __attribute__((unused));
static UA_DeleteNodesRequest
XS_unpack_UA_DeleteNodesRequest(SV *in)
{
	UA_DeleteNodesRequest out;
	SV **value;
	HV *hv;

	UA_DeleteNodesRequest_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "DeleteNodesRequest_requestHeader", 0);
	if (value != NULL)
		out.requestHeader = XS_unpack_UA_RequestHeader(*value);

	/* TODO Implement array conversion for field nodesToDelete */

	return out;
}

/* DeleteNodesResponse */
static void XS_pack_UA_DeleteNodesResponse(SV *out, UA_DeleteNodesResponse in)  __attribute__((unused));
static void
XS_pack_UA_DeleteNodesResponse(SV *out, UA_DeleteNodesResponse in)
{
	HV *hash = newHV();

	SV *responseHeaderSV = newSV(0);
	XS_pack_UA_ResponseHeader(responseHeaderSV, in.responseHeader);
	hv_stores(hash, "DeleteNodesResponse_responseHeader", responseHeaderSV);

	AV *resultsArray = (AV*) sv_2mortal((SV*)newAV());
	size_t resultsI;
	for(resultsI = 0; resultsI < in.resultsSize; resultsI++) {
		SV *element = newSV(0);
		XS_pack_UA_StatusCode(element, in.results[resultsI]);
		av_push(resultsArray, element);
	}
	hv_stores(hash, "DeleteNodesResponse_results", newRV_inc((SV*)resultsArray));

	AV *diagnosticInfosArray = (AV*) sv_2mortal((SV*)newAV());
	size_t diagnosticInfosI;
	for(diagnosticInfosI = 0; diagnosticInfosI < in.diagnosticInfosSize; diagnosticInfosI++) {
		SV *element = newSV(0);
		XS_pack_UA_DiagnosticInfo(element, in.diagnosticInfos[diagnosticInfosI]);
		av_push(diagnosticInfosArray, element);
	}
	hv_stores(hash, "DeleteNodesResponse_diagnosticInfos", newRV_inc((SV*)diagnosticInfosArray));

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_DeleteNodesResponse XS_unpack_UA_DeleteNodesResponse(SV *in)  __attribute__((unused));
static UA_DeleteNodesResponse
XS_unpack_UA_DeleteNodesResponse(SV *in)
{
	UA_DeleteNodesResponse out;
	SV **value;
	HV *hv;

	UA_DeleteNodesResponse_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "DeleteNodesResponse_responseHeader", 0);
	if (value != NULL)
		out.responseHeader = XS_unpack_UA_ResponseHeader(*value);

	/* TODO Implement array conversion for field results */

	/* TODO Implement array conversion for field diagnosticInfos */

	return out;
}

/* DeleteReferencesItem */
static void XS_pack_UA_DeleteReferencesItem(SV *out, UA_DeleteReferencesItem in)  __attribute__((unused));
static void
XS_pack_UA_DeleteReferencesItem(SV *out, UA_DeleteReferencesItem in)
{
	HV *hash = newHV();

	SV *sourceNodeIdSV = newSV(0);
	XS_pack_UA_NodeId(sourceNodeIdSV, in.sourceNodeId);
	hv_stores(hash, "DeleteReferencesItem_sourceNodeId", sourceNodeIdSV);

	SV *referenceTypeIdSV = newSV(0);
	XS_pack_UA_NodeId(referenceTypeIdSV, in.referenceTypeId);
	hv_stores(hash, "DeleteReferencesItem_referenceTypeId", referenceTypeIdSV);

	SV *isForwardSV = newSV(0);
	XS_pack_UA_Boolean(isForwardSV, in.isForward);
	hv_stores(hash, "DeleteReferencesItem_isForward", isForwardSV);

	SV *targetNodeIdSV = newSV(0);
	XS_pack_UA_ExpandedNodeId(targetNodeIdSV, in.targetNodeId);
	hv_stores(hash, "DeleteReferencesItem_targetNodeId", targetNodeIdSV);

	SV *deleteBidirectionalSV = newSV(0);
	XS_pack_UA_Boolean(deleteBidirectionalSV, in.deleteBidirectional);
	hv_stores(hash, "DeleteReferencesItem_deleteBidirectional", deleteBidirectionalSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_DeleteReferencesItem XS_unpack_UA_DeleteReferencesItem(SV *in)  __attribute__((unused));
static UA_DeleteReferencesItem
XS_unpack_UA_DeleteReferencesItem(SV *in)
{
	UA_DeleteReferencesItem out;
	SV **value;
	HV *hv;

	UA_DeleteReferencesItem_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "DeleteReferencesItem_sourceNodeId", 0);
	if (value != NULL)
		out.sourceNodeId = XS_unpack_UA_NodeId(*value);

	value = hv_fetchs(hv, "DeleteReferencesItem_referenceTypeId", 0);
	if (value != NULL)
		out.referenceTypeId = XS_unpack_UA_NodeId(*value);

	value = hv_fetchs(hv, "DeleteReferencesItem_isForward", 0);
	if (value != NULL)
		out.isForward = XS_unpack_UA_Boolean(*value);

	value = hv_fetchs(hv, "DeleteReferencesItem_targetNodeId", 0);
	if (value != NULL)
		out.targetNodeId = XS_unpack_UA_ExpandedNodeId(*value);

	value = hv_fetchs(hv, "DeleteReferencesItem_deleteBidirectional", 0);
	if (value != NULL)
		out.deleteBidirectional = XS_unpack_UA_Boolean(*value);

	return out;
}

/* DeleteReferencesRequest */
static void XS_pack_UA_DeleteReferencesRequest(SV *out, UA_DeleteReferencesRequest in)  __attribute__((unused));
static void
XS_pack_UA_DeleteReferencesRequest(SV *out, UA_DeleteReferencesRequest in)
{
	HV *hash = newHV();

	SV *requestHeaderSV = newSV(0);
	XS_pack_UA_RequestHeader(requestHeaderSV, in.requestHeader);
	hv_stores(hash, "DeleteReferencesRequest_requestHeader", requestHeaderSV);

	AV *referencesToDeleteArray = (AV*) sv_2mortal((SV*)newAV());
	size_t referencesToDeleteI;
	for(referencesToDeleteI = 0; referencesToDeleteI < in.referencesToDeleteSize; referencesToDeleteI++) {
		SV *element = newSV(0);
		XS_pack_UA_DeleteReferencesItem(element, in.referencesToDelete[referencesToDeleteI]);
		av_push(referencesToDeleteArray, element);
	}
	hv_stores(hash, "DeleteReferencesRequest_referencesToDelete", newRV_inc((SV*)referencesToDeleteArray));

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_DeleteReferencesRequest XS_unpack_UA_DeleteReferencesRequest(SV *in)  __attribute__((unused));
static UA_DeleteReferencesRequest
XS_unpack_UA_DeleteReferencesRequest(SV *in)
{
	UA_DeleteReferencesRequest out;
	SV **value;
	HV *hv;

	UA_DeleteReferencesRequest_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "DeleteReferencesRequest_requestHeader", 0);
	if (value != NULL)
		out.requestHeader = XS_unpack_UA_RequestHeader(*value);

	/* TODO Implement array conversion for field referencesToDelete */

	return out;
}

/* DeleteReferencesResponse */
static void XS_pack_UA_DeleteReferencesResponse(SV *out, UA_DeleteReferencesResponse in)  __attribute__((unused));
static void
XS_pack_UA_DeleteReferencesResponse(SV *out, UA_DeleteReferencesResponse in)
{
	HV *hash = newHV();

	SV *responseHeaderSV = newSV(0);
	XS_pack_UA_ResponseHeader(responseHeaderSV, in.responseHeader);
	hv_stores(hash, "DeleteReferencesResponse_responseHeader", responseHeaderSV);

	AV *resultsArray = (AV*) sv_2mortal((SV*)newAV());
	size_t resultsI;
	for(resultsI = 0; resultsI < in.resultsSize; resultsI++) {
		SV *element = newSV(0);
		XS_pack_UA_StatusCode(element, in.results[resultsI]);
		av_push(resultsArray, element);
	}
	hv_stores(hash, "DeleteReferencesResponse_results", newRV_inc((SV*)resultsArray));

	AV *diagnosticInfosArray = (AV*) sv_2mortal((SV*)newAV());
	size_t diagnosticInfosI;
	for(diagnosticInfosI = 0; diagnosticInfosI < in.diagnosticInfosSize; diagnosticInfosI++) {
		SV *element = newSV(0);
		XS_pack_UA_DiagnosticInfo(element, in.diagnosticInfos[diagnosticInfosI]);
		av_push(diagnosticInfosArray, element);
	}
	hv_stores(hash, "DeleteReferencesResponse_diagnosticInfos", newRV_inc((SV*)diagnosticInfosArray));

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_DeleteReferencesResponse XS_unpack_UA_DeleteReferencesResponse(SV *in)  __attribute__((unused));
static UA_DeleteReferencesResponse
XS_unpack_UA_DeleteReferencesResponse(SV *in)
{
	UA_DeleteReferencesResponse out;
	SV **value;
	HV *hv;

	UA_DeleteReferencesResponse_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "DeleteReferencesResponse_responseHeader", 0);
	if (value != NULL)
		out.responseHeader = XS_unpack_UA_ResponseHeader(*value);

	/* TODO Implement array conversion for field results */

	/* TODO Implement array conversion for field diagnosticInfos */

	return out;
}

/* BrowseDirection */
static void XS_pack_UA_BrowseDirection(SV *out, UA_BrowseDirection in)  __attribute__((unused));
static void
XS_pack_UA_BrowseDirection(SV *out, UA_BrowseDirection in)
{
	/* TODO implement EnumerationType conversion */

}

static UA_BrowseDirection XS_unpack_UA_BrowseDirection(SV *in)  __attribute__((unused));
static UA_BrowseDirection
XS_unpack_UA_BrowseDirection(SV *in)
{
	/* TODO implement EnumerationType conversion */
}

/* ViewDescription */
static void XS_pack_UA_ViewDescription(SV *out, UA_ViewDescription in)  __attribute__((unused));
static void
XS_pack_UA_ViewDescription(SV *out, UA_ViewDescription in)
{
	HV *hash = newHV();

	SV *viewIdSV = newSV(0);
	XS_pack_UA_NodeId(viewIdSV, in.viewId);
	hv_stores(hash, "ViewDescription_viewId", viewIdSV);

	SV *timestampSV = newSV(0);
	XS_pack_UA_DateTime(timestampSV, in.timestamp);
	hv_stores(hash, "ViewDescription_timestamp", timestampSV);

	SV *viewVersionSV = newSV(0);
	XS_pack_UA_UInt32(viewVersionSV, in.viewVersion);
	hv_stores(hash, "ViewDescription_viewVersion", viewVersionSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_ViewDescription XS_unpack_UA_ViewDescription(SV *in)  __attribute__((unused));
static UA_ViewDescription
XS_unpack_UA_ViewDescription(SV *in)
{
	UA_ViewDescription out;
	SV **value;
	HV *hv;

	UA_ViewDescription_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "ViewDescription_viewId", 0);
	if (value != NULL)
		out.viewId = XS_unpack_UA_NodeId(*value);

	value = hv_fetchs(hv, "ViewDescription_timestamp", 0);
	if (value != NULL)
		out.timestamp = XS_unpack_UA_DateTime(*value);

	value = hv_fetchs(hv, "ViewDescription_viewVersion", 0);
	if (value != NULL)
		out.viewVersion = XS_unpack_UA_UInt32(*value);

	return out;
}

/* BrowseDescription */
static void XS_pack_UA_BrowseDescription(SV *out, UA_BrowseDescription in)  __attribute__((unused));
static void
XS_pack_UA_BrowseDescription(SV *out, UA_BrowseDescription in)
{
	HV *hash = newHV();

	SV *nodeIdSV = newSV(0);
	XS_pack_UA_NodeId(nodeIdSV, in.nodeId);
	hv_stores(hash, "BrowseDescription_nodeId", nodeIdSV);

	SV *browseDirectionSV = newSV(0);
	XS_pack_UA_BrowseDirection(browseDirectionSV, in.browseDirection);
	hv_stores(hash, "BrowseDescription_browseDirection", browseDirectionSV);

	SV *referenceTypeIdSV = newSV(0);
	XS_pack_UA_NodeId(referenceTypeIdSV, in.referenceTypeId);
	hv_stores(hash, "BrowseDescription_referenceTypeId", referenceTypeIdSV);

	SV *includeSubtypesSV = newSV(0);
	XS_pack_UA_Boolean(includeSubtypesSV, in.includeSubtypes);
	hv_stores(hash, "BrowseDescription_includeSubtypes", includeSubtypesSV);

	SV *nodeClassMaskSV = newSV(0);
	XS_pack_UA_UInt32(nodeClassMaskSV, in.nodeClassMask);
	hv_stores(hash, "BrowseDescription_nodeClassMask", nodeClassMaskSV);

	SV *resultMaskSV = newSV(0);
	XS_pack_UA_UInt32(resultMaskSV, in.resultMask);
	hv_stores(hash, "BrowseDescription_resultMask", resultMaskSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_BrowseDescription XS_unpack_UA_BrowseDescription(SV *in)  __attribute__((unused));
static UA_BrowseDescription
XS_unpack_UA_BrowseDescription(SV *in)
{
	UA_BrowseDescription out;
	SV **value;
	HV *hv;

	UA_BrowseDescription_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "BrowseDescription_nodeId", 0);
	if (value != NULL)
		out.nodeId = XS_unpack_UA_NodeId(*value);

	value = hv_fetchs(hv, "BrowseDescription_browseDirection", 0);
	if (value != NULL)
		out.browseDirection = XS_unpack_UA_BrowseDirection(*value);

	value = hv_fetchs(hv, "BrowseDescription_referenceTypeId", 0);
	if (value != NULL)
		out.referenceTypeId = XS_unpack_UA_NodeId(*value);

	value = hv_fetchs(hv, "BrowseDescription_includeSubtypes", 0);
	if (value != NULL)
		out.includeSubtypes = XS_unpack_UA_Boolean(*value);

	value = hv_fetchs(hv, "BrowseDescription_nodeClassMask", 0);
	if (value != NULL)
		out.nodeClassMask = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "BrowseDescription_resultMask", 0);
	if (value != NULL)
		out.resultMask = XS_unpack_UA_UInt32(*value);

	return out;
}

/* BrowseResultMask */
static void XS_pack_UA_BrowseResultMask(SV *out, UA_BrowseResultMask in)  __attribute__((unused));
static void
XS_pack_UA_BrowseResultMask(SV *out, UA_BrowseResultMask in)
{
	/* TODO implement EnumerationType conversion */

}

static UA_BrowseResultMask XS_unpack_UA_BrowseResultMask(SV *in)  __attribute__((unused));
static UA_BrowseResultMask
XS_unpack_UA_BrowseResultMask(SV *in)
{
	/* TODO implement EnumerationType conversion */
}

/* ReferenceDescription */
static void XS_pack_UA_ReferenceDescription(SV *out, UA_ReferenceDescription in)  __attribute__((unused));
static void
XS_pack_UA_ReferenceDescription(SV *out, UA_ReferenceDescription in)
{
	HV *hash = newHV();

	SV *referenceTypeIdSV = newSV(0);
	XS_pack_UA_NodeId(referenceTypeIdSV, in.referenceTypeId);
	hv_stores(hash, "ReferenceDescription_referenceTypeId", referenceTypeIdSV);

	SV *isForwardSV = newSV(0);
	XS_pack_UA_Boolean(isForwardSV, in.isForward);
	hv_stores(hash, "ReferenceDescription_isForward", isForwardSV);

	SV *nodeIdSV = newSV(0);
	XS_pack_UA_ExpandedNodeId(nodeIdSV, in.nodeId);
	hv_stores(hash, "ReferenceDescription_nodeId", nodeIdSV);

	SV *browseNameSV = newSV(0);
	XS_pack_UA_QualifiedName(browseNameSV, in.browseName);
	hv_stores(hash, "ReferenceDescription_browseName", browseNameSV);

	SV *displayNameSV = newSV(0);
	XS_pack_UA_LocalizedText(displayNameSV, in.displayName);
	hv_stores(hash, "ReferenceDescription_displayName", displayNameSV);

	SV *nodeClassSV = newSV(0);
	XS_pack_UA_NodeClass(nodeClassSV, in.nodeClass);
	hv_stores(hash, "ReferenceDescription_nodeClass", nodeClassSV);

	SV *typeDefinitionSV = newSV(0);
	XS_pack_UA_ExpandedNodeId(typeDefinitionSV, in.typeDefinition);
	hv_stores(hash, "ReferenceDescription_typeDefinition", typeDefinitionSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_ReferenceDescription XS_unpack_UA_ReferenceDescription(SV *in)  __attribute__((unused));
static UA_ReferenceDescription
XS_unpack_UA_ReferenceDescription(SV *in)
{
	UA_ReferenceDescription out;
	SV **value;
	HV *hv;

	UA_ReferenceDescription_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "ReferenceDescription_referenceTypeId", 0);
	if (value != NULL)
		out.referenceTypeId = XS_unpack_UA_NodeId(*value);

	value = hv_fetchs(hv, "ReferenceDescription_isForward", 0);
	if (value != NULL)
		out.isForward = XS_unpack_UA_Boolean(*value);

	value = hv_fetchs(hv, "ReferenceDescription_nodeId", 0);
	if (value != NULL)
		out.nodeId = XS_unpack_UA_ExpandedNodeId(*value);

	value = hv_fetchs(hv, "ReferenceDescription_browseName", 0);
	if (value != NULL)
		out.browseName = XS_unpack_UA_QualifiedName(*value);

	value = hv_fetchs(hv, "ReferenceDescription_displayName", 0);
	if (value != NULL)
		out.displayName = XS_unpack_UA_LocalizedText(*value);

	value = hv_fetchs(hv, "ReferenceDescription_nodeClass", 0);
	if (value != NULL)
		out.nodeClass = XS_unpack_UA_NodeClass(*value);

	value = hv_fetchs(hv, "ReferenceDescription_typeDefinition", 0);
	if (value != NULL)
		out.typeDefinition = XS_unpack_UA_ExpandedNodeId(*value);

	return out;
}

/* BrowseResult */
static void XS_pack_UA_BrowseResult(SV *out, UA_BrowseResult in)  __attribute__((unused));
static void
XS_pack_UA_BrowseResult(SV *out, UA_BrowseResult in)
{
	HV *hash = newHV();

	SV *statusCodeSV = newSV(0);
	XS_pack_UA_StatusCode(statusCodeSV, in.statusCode);
	hv_stores(hash, "BrowseResult_statusCode", statusCodeSV);

	SV *continuationPointSV = newSV(0);
	XS_pack_UA_ByteString(continuationPointSV, in.continuationPoint);
	hv_stores(hash, "BrowseResult_continuationPoint", continuationPointSV);

	AV *referencesArray = (AV*) sv_2mortal((SV*)newAV());
	size_t referencesI;
	for(referencesI = 0; referencesI < in.referencesSize; referencesI++) {
		SV *element = newSV(0);
		XS_pack_UA_ReferenceDescription(element, in.references[referencesI]);
		av_push(referencesArray, element);
	}
	hv_stores(hash, "BrowseResult_references", newRV_inc((SV*)referencesArray));

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_BrowseResult XS_unpack_UA_BrowseResult(SV *in)  __attribute__((unused));
static UA_BrowseResult
XS_unpack_UA_BrowseResult(SV *in)
{
	UA_BrowseResult out;
	SV **value;
	HV *hv;

	UA_BrowseResult_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "BrowseResult_statusCode", 0);
	if (value != NULL)
		out.statusCode = XS_unpack_UA_StatusCode(*value);

	value = hv_fetchs(hv, "BrowseResult_continuationPoint", 0);
	if (value != NULL)
		out.continuationPoint = XS_unpack_UA_ByteString(*value);

	/* TODO Implement array conversion for field references */

	return out;
}

/* BrowseRequest */
static void XS_pack_UA_BrowseRequest(SV *out, UA_BrowseRequest in)  __attribute__((unused));
static void
XS_pack_UA_BrowseRequest(SV *out, UA_BrowseRequest in)
{
	HV *hash = newHV();

	SV *requestHeaderSV = newSV(0);
	XS_pack_UA_RequestHeader(requestHeaderSV, in.requestHeader);
	hv_stores(hash, "BrowseRequest_requestHeader", requestHeaderSV);

	SV *viewSV = newSV(0);
	XS_pack_UA_ViewDescription(viewSV, in.view);
	hv_stores(hash, "BrowseRequest_view", viewSV);

	SV *requestedMaxReferencesPerNodeSV = newSV(0);
	XS_pack_UA_UInt32(requestedMaxReferencesPerNodeSV, in.requestedMaxReferencesPerNode);
	hv_stores(hash, "BrowseRequest_requestedMaxReferencesPerNode", requestedMaxReferencesPerNodeSV);

	AV *nodesToBrowseArray = (AV*) sv_2mortal((SV*)newAV());
	size_t nodesToBrowseI;
	for(nodesToBrowseI = 0; nodesToBrowseI < in.nodesToBrowseSize; nodesToBrowseI++) {
		SV *element = newSV(0);
		XS_pack_UA_BrowseDescription(element, in.nodesToBrowse[nodesToBrowseI]);
		av_push(nodesToBrowseArray, element);
	}
	hv_stores(hash, "BrowseRequest_nodesToBrowse", newRV_inc((SV*)nodesToBrowseArray));

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_BrowseRequest XS_unpack_UA_BrowseRequest(SV *in)  __attribute__((unused));
static UA_BrowseRequest
XS_unpack_UA_BrowseRequest(SV *in)
{
	UA_BrowseRequest out;
	SV **value;
	HV *hv;

	UA_BrowseRequest_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "BrowseRequest_requestHeader", 0);
	if (value != NULL)
		out.requestHeader = XS_unpack_UA_RequestHeader(*value);

	value = hv_fetchs(hv, "BrowseRequest_view", 0);
	if (value != NULL)
		out.view = XS_unpack_UA_ViewDescription(*value);

	value = hv_fetchs(hv, "BrowseRequest_requestedMaxReferencesPerNode", 0);
	if (value != NULL)
		out.requestedMaxReferencesPerNode = XS_unpack_UA_UInt32(*value);

	/* TODO Implement array conversion for field nodesToBrowse */

	return out;
}

/* BrowseResponse */
static void XS_pack_UA_BrowseResponse(SV *out, UA_BrowseResponse in)  __attribute__((unused));
static void
XS_pack_UA_BrowseResponse(SV *out, UA_BrowseResponse in)
{
	HV *hash = newHV();

	SV *responseHeaderSV = newSV(0);
	XS_pack_UA_ResponseHeader(responseHeaderSV, in.responseHeader);
	hv_stores(hash, "BrowseResponse_responseHeader", responseHeaderSV);

	AV *resultsArray = (AV*) sv_2mortal((SV*)newAV());
	size_t resultsI;
	for(resultsI = 0; resultsI < in.resultsSize; resultsI++) {
		SV *element = newSV(0);
		XS_pack_UA_BrowseResult(element, in.results[resultsI]);
		av_push(resultsArray, element);
	}
	hv_stores(hash, "BrowseResponse_results", newRV_inc((SV*)resultsArray));

	AV *diagnosticInfosArray = (AV*) sv_2mortal((SV*)newAV());
	size_t diagnosticInfosI;
	for(diagnosticInfosI = 0; diagnosticInfosI < in.diagnosticInfosSize; diagnosticInfosI++) {
		SV *element = newSV(0);
		XS_pack_UA_DiagnosticInfo(element, in.diagnosticInfos[diagnosticInfosI]);
		av_push(diagnosticInfosArray, element);
	}
	hv_stores(hash, "BrowseResponse_diagnosticInfos", newRV_inc((SV*)diagnosticInfosArray));

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_BrowseResponse XS_unpack_UA_BrowseResponse(SV *in)  __attribute__((unused));
static UA_BrowseResponse
XS_unpack_UA_BrowseResponse(SV *in)
{
	UA_BrowseResponse out;
	SV **value;
	HV *hv;

	UA_BrowseResponse_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "BrowseResponse_responseHeader", 0);
	if (value != NULL)
		out.responseHeader = XS_unpack_UA_ResponseHeader(*value);

	/* TODO Implement array conversion for field results */

	/* TODO Implement array conversion for field diagnosticInfos */

	return out;
}

/* BrowseNextRequest */
static void XS_pack_UA_BrowseNextRequest(SV *out, UA_BrowseNextRequest in)  __attribute__((unused));
static void
XS_pack_UA_BrowseNextRequest(SV *out, UA_BrowseNextRequest in)
{
	HV *hash = newHV();

	SV *requestHeaderSV = newSV(0);
	XS_pack_UA_RequestHeader(requestHeaderSV, in.requestHeader);
	hv_stores(hash, "BrowseNextRequest_requestHeader", requestHeaderSV);

	SV *releaseContinuationPointsSV = newSV(0);
	XS_pack_UA_Boolean(releaseContinuationPointsSV, in.releaseContinuationPoints);
	hv_stores(hash, "BrowseNextRequest_releaseContinuationPoints", releaseContinuationPointsSV);

	AV *continuationPointsArray = (AV*) sv_2mortal((SV*)newAV());
	size_t continuationPointsI;
	for(continuationPointsI = 0; continuationPointsI < in.continuationPointsSize; continuationPointsI++) {
		SV *element = newSV(0);
		XS_pack_UA_ByteString(element, in.continuationPoints[continuationPointsI]);
		av_push(continuationPointsArray, element);
	}
	hv_stores(hash, "BrowseNextRequest_continuationPoints", newRV_inc((SV*)continuationPointsArray));

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_BrowseNextRequest XS_unpack_UA_BrowseNextRequest(SV *in)  __attribute__((unused));
static UA_BrowseNextRequest
XS_unpack_UA_BrowseNextRequest(SV *in)
{
	UA_BrowseNextRequest out;
	SV **value;
	HV *hv;

	UA_BrowseNextRequest_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "BrowseNextRequest_requestHeader", 0);
	if (value != NULL)
		out.requestHeader = XS_unpack_UA_RequestHeader(*value);

	value = hv_fetchs(hv, "BrowseNextRequest_releaseContinuationPoints", 0);
	if (value != NULL)
		out.releaseContinuationPoints = XS_unpack_UA_Boolean(*value);

	/* TODO Implement array conversion for field continuationPoints */

	return out;
}

/* BrowseNextResponse */
static void XS_pack_UA_BrowseNextResponse(SV *out, UA_BrowseNextResponse in)  __attribute__((unused));
static void
XS_pack_UA_BrowseNextResponse(SV *out, UA_BrowseNextResponse in)
{
	HV *hash = newHV();

	SV *responseHeaderSV = newSV(0);
	XS_pack_UA_ResponseHeader(responseHeaderSV, in.responseHeader);
	hv_stores(hash, "BrowseNextResponse_responseHeader", responseHeaderSV);

	AV *resultsArray = (AV*) sv_2mortal((SV*)newAV());
	size_t resultsI;
	for(resultsI = 0; resultsI < in.resultsSize; resultsI++) {
		SV *element = newSV(0);
		XS_pack_UA_BrowseResult(element, in.results[resultsI]);
		av_push(resultsArray, element);
	}
	hv_stores(hash, "BrowseNextResponse_results", newRV_inc((SV*)resultsArray));

	AV *diagnosticInfosArray = (AV*) sv_2mortal((SV*)newAV());
	size_t diagnosticInfosI;
	for(diagnosticInfosI = 0; diagnosticInfosI < in.diagnosticInfosSize; diagnosticInfosI++) {
		SV *element = newSV(0);
		XS_pack_UA_DiagnosticInfo(element, in.diagnosticInfos[diagnosticInfosI]);
		av_push(diagnosticInfosArray, element);
	}
	hv_stores(hash, "BrowseNextResponse_diagnosticInfos", newRV_inc((SV*)diagnosticInfosArray));

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_BrowseNextResponse XS_unpack_UA_BrowseNextResponse(SV *in)  __attribute__((unused));
static UA_BrowseNextResponse
XS_unpack_UA_BrowseNextResponse(SV *in)
{
	UA_BrowseNextResponse out;
	SV **value;
	HV *hv;

	UA_BrowseNextResponse_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "BrowseNextResponse_responseHeader", 0);
	if (value != NULL)
		out.responseHeader = XS_unpack_UA_ResponseHeader(*value);

	/* TODO Implement array conversion for field results */

	/* TODO Implement array conversion for field diagnosticInfos */

	return out;
}

/* RelativePathElement */
static void XS_pack_UA_RelativePathElement(SV *out, UA_RelativePathElement in)  __attribute__((unused));
static void
XS_pack_UA_RelativePathElement(SV *out, UA_RelativePathElement in)
{
	HV *hash = newHV();

	SV *referenceTypeIdSV = newSV(0);
	XS_pack_UA_NodeId(referenceTypeIdSV, in.referenceTypeId);
	hv_stores(hash, "RelativePathElement_referenceTypeId", referenceTypeIdSV);

	SV *isInverseSV = newSV(0);
	XS_pack_UA_Boolean(isInverseSV, in.isInverse);
	hv_stores(hash, "RelativePathElement_isInverse", isInverseSV);

	SV *includeSubtypesSV = newSV(0);
	XS_pack_UA_Boolean(includeSubtypesSV, in.includeSubtypes);
	hv_stores(hash, "RelativePathElement_includeSubtypes", includeSubtypesSV);

	SV *targetNameSV = newSV(0);
	XS_pack_UA_QualifiedName(targetNameSV, in.targetName);
	hv_stores(hash, "RelativePathElement_targetName", targetNameSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_RelativePathElement XS_unpack_UA_RelativePathElement(SV *in)  __attribute__((unused));
static UA_RelativePathElement
XS_unpack_UA_RelativePathElement(SV *in)
{
	UA_RelativePathElement out;
	SV **value;
	HV *hv;

	UA_RelativePathElement_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "RelativePathElement_referenceTypeId", 0);
	if (value != NULL)
		out.referenceTypeId = XS_unpack_UA_NodeId(*value);

	value = hv_fetchs(hv, "RelativePathElement_isInverse", 0);
	if (value != NULL)
		out.isInverse = XS_unpack_UA_Boolean(*value);

	value = hv_fetchs(hv, "RelativePathElement_includeSubtypes", 0);
	if (value != NULL)
		out.includeSubtypes = XS_unpack_UA_Boolean(*value);

	value = hv_fetchs(hv, "RelativePathElement_targetName", 0);
	if (value != NULL)
		out.targetName = XS_unpack_UA_QualifiedName(*value);

	return out;
}

/* RelativePath */
static void XS_pack_UA_RelativePath(SV *out, UA_RelativePath in)  __attribute__((unused));
static void
XS_pack_UA_RelativePath(SV *out, UA_RelativePath in)
{
	HV *hash = newHV();

	AV *elementsArray = (AV*) sv_2mortal((SV*)newAV());
	size_t elementsI;
	for(elementsI = 0; elementsI < in.elementsSize; elementsI++) {
		SV *element = newSV(0);
		XS_pack_UA_RelativePathElement(element, in.elements[elementsI]);
		av_push(elementsArray, element);
	}
	hv_stores(hash, "RelativePath_elements", newRV_inc((SV*)elementsArray));

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_RelativePath XS_unpack_UA_RelativePath(SV *in)  __attribute__((unused));
static UA_RelativePath
XS_unpack_UA_RelativePath(SV *in)
{
	UA_RelativePath out;
	SV **value;
	HV *hv;

	UA_RelativePath_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	/* TODO Implement array conversion for field elements */

	return out;
}

/* BrowsePath */
static void XS_pack_UA_BrowsePath(SV *out, UA_BrowsePath in)  __attribute__((unused));
static void
XS_pack_UA_BrowsePath(SV *out, UA_BrowsePath in)
{
	HV *hash = newHV();

	SV *startingNodeSV = newSV(0);
	XS_pack_UA_NodeId(startingNodeSV, in.startingNode);
	hv_stores(hash, "BrowsePath_startingNode", startingNodeSV);

	SV *relativePathSV = newSV(0);
	XS_pack_UA_RelativePath(relativePathSV, in.relativePath);
	hv_stores(hash, "BrowsePath_relativePath", relativePathSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_BrowsePath XS_unpack_UA_BrowsePath(SV *in)  __attribute__((unused));
static UA_BrowsePath
XS_unpack_UA_BrowsePath(SV *in)
{
	UA_BrowsePath out;
	SV **value;
	HV *hv;

	UA_BrowsePath_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "BrowsePath_startingNode", 0);
	if (value != NULL)
		out.startingNode = XS_unpack_UA_NodeId(*value);

	value = hv_fetchs(hv, "BrowsePath_relativePath", 0);
	if (value != NULL)
		out.relativePath = XS_unpack_UA_RelativePath(*value);

	return out;
}

/* BrowsePathTarget */
static void XS_pack_UA_BrowsePathTarget(SV *out, UA_BrowsePathTarget in)  __attribute__((unused));
static void
XS_pack_UA_BrowsePathTarget(SV *out, UA_BrowsePathTarget in)
{
	HV *hash = newHV();

	SV *targetIdSV = newSV(0);
	XS_pack_UA_ExpandedNodeId(targetIdSV, in.targetId);
	hv_stores(hash, "BrowsePathTarget_targetId", targetIdSV);

	SV *remainingPathIndexSV = newSV(0);
	XS_pack_UA_UInt32(remainingPathIndexSV, in.remainingPathIndex);
	hv_stores(hash, "BrowsePathTarget_remainingPathIndex", remainingPathIndexSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_BrowsePathTarget XS_unpack_UA_BrowsePathTarget(SV *in)  __attribute__((unused));
static UA_BrowsePathTarget
XS_unpack_UA_BrowsePathTarget(SV *in)
{
	UA_BrowsePathTarget out;
	SV **value;
	HV *hv;

	UA_BrowsePathTarget_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "BrowsePathTarget_targetId", 0);
	if (value != NULL)
		out.targetId = XS_unpack_UA_ExpandedNodeId(*value);

	value = hv_fetchs(hv, "BrowsePathTarget_remainingPathIndex", 0);
	if (value != NULL)
		out.remainingPathIndex = XS_unpack_UA_UInt32(*value);

	return out;
}

/* BrowsePathResult */
static void XS_pack_UA_BrowsePathResult(SV *out, UA_BrowsePathResult in)  __attribute__((unused));
static void
XS_pack_UA_BrowsePathResult(SV *out, UA_BrowsePathResult in)
{
	HV *hash = newHV();

	SV *statusCodeSV = newSV(0);
	XS_pack_UA_StatusCode(statusCodeSV, in.statusCode);
	hv_stores(hash, "BrowsePathResult_statusCode", statusCodeSV);

	AV *targetsArray = (AV*) sv_2mortal((SV*)newAV());
	size_t targetsI;
	for(targetsI = 0; targetsI < in.targetsSize; targetsI++) {
		SV *element = newSV(0);
		XS_pack_UA_BrowsePathTarget(element, in.targets[targetsI]);
		av_push(targetsArray, element);
	}
	hv_stores(hash, "BrowsePathResult_targets", newRV_inc((SV*)targetsArray));

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_BrowsePathResult XS_unpack_UA_BrowsePathResult(SV *in)  __attribute__((unused));
static UA_BrowsePathResult
XS_unpack_UA_BrowsePathResult(SV *in)
{
	UA_BrowsePathResult out;
	SV **value;
	HV *hv;

	UA_BrowsePathResult_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "BrowsePathResult_statusCode", 0);
	if (value != NULL)
		out.statusCode = XS_unpack_UA_StatusCode(*value);

	/* TODO Implement array conversion for field targets */

	return out;
}

/* TranslateBrowsePathsToNodeIdsRequest */
static void XS_pack_UA_TranslateBrowsePathsToNodeIdsRequest(SV *out, UA_TranslateBrowsePathsToNodeIdsRequest in)  __attribute__((unused));
static void
XS_pack_UA_TranslateBrowsePathsToNodeIdsRequest(SV *out, UA_TranslateBrowsePathsToNodeIdsRequest in)
{
	HV *hash = newHV();

	SV *requestHeaderSV = newSV(0);
	XS_pack_UA_RequestHeader(requestHeaderSV, in.requestHeader);
	hv_stores(hash, "TranslateBrowsePathsToNodeIdsRequest_requestHeader", requestHeaderSV);

	AV *browsePathsArray = (AV*) sv_2mortal((SV*)newAV());
	size_t browsePathsI;
	for(browsePathsI = 0; browsePathsI < in.browsePathsSize; browsePathsI++) {
		SV *element = newSV(0);
		XS_pack_UA_BrowsePath(element, in.browsePaths[browsePathsI]);
		av_push(browsePathsArray, element);
	}
	hv_stores(hash, "TranslateBrowsePathsToNodeIdsRequest_browsePaths", newRV_inc((SV*)browsePathsArray));

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_TranslateBrowsePathsToNodeIdsRequest XS_unpack_UA_TranslateBrowsePathsToNodeIdsRequest(SV *in)  __attribute__((unused));
static UA_TranslateBrowsePathsToNodeIdsRequest
XS_unpack_UA_TranslateBrowsePathsToNodeIdsRequest(SV *in)
{
	UA_TranslateBrowsePathsToNodeIdsRequest out;
	SV **value;
	HV *hv;

	UA_TranslateBrowsePathsToNodeIdsRequest_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "TranslateBrowsePathsToNodeIdsRequest_requestHeader", 0);
	if (value != NULL)
		out.requestHeader = XS_unpack_UA_RequestHeader(*value);

	/* TODO Implement array conversion for field browsePaths */

	return out;
}

/* TranslateBrowsePathsToNodeIdsResponse */
static void XS_pack_UA_TranslateBrowsePathsToNodeIdsResponse(SV *out, UA_TranslateBrowsePathsToNodeIdsResponse in)  __attribute__((unused));
static void
XS_pack_UA_TranslateBrowsePathsToNodeIdsResponse(SV *out, UA_TranslateBrowsePathsToNodeIdsResponse in)
{
	HV *hash = newHV();

	SV *responseHeaderSV = newSV(0);
	XS_pack_UA_ResponseHeader(responseHeaderSV, in.responseHeader);
	hv_stores(hash, "TranslateBrowsePathsToNodeIdsResponse_responseHeader", responseHeaderSV);

	AV *resultsArray = (AV*) sv_2mortal((SV*)newAV());
	size_t resultsI;
	for(resultsI = 0; resultsI < in.resultsSize; resultsI++) {
		SV *element = newSV(0);
		XS_pack_UA_BrowsePathResult(element, in.results[resultsI]);
		av_push(resultsArray, element);
	}
	hv_stores(hash, "TranslateBrowsePathsToNodeIdsResponse_results", newRV_inc((SV*)resultsArray));

	AV *diagnosticInfosArray = (AV*) sv_2mortal((SV*)newAV());
	size_t diagnosticInfosI;
	for(diagnosticInfosI = 0; diagnosticInfosI < in.diagnosticInfosSize; diagnosticInfosI++) {
		SV *element = newSV(0);
		XS_pack_UA_DiagnosticInfo(element, in.diagnosticInfos[diagnosticInfosI]);
		av_push(diagnosticInfosArray, element);
	}
	hv_stores(hash, "TranslateBrowsePathsToNodeIdsResponse_diagnosticInfos", newRV_inc((SV*)diagnosticInfosArray));

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_TranslateBrowsePathsToNodeIdsResponse XS_unpack_UA_TranslateBrowsePathsToNodeIdsResponse(SV *in)  __attribute__((unused));
static UA_TranslateBrowsePathsToNodeIdsResponse
XS_unpack_UA_TranslateBrowsePathsToNodeIdsResponse(SV *in)
{
	UA_TranslateBrowsePathsToNodeIdsResponse out;
	SV **value;
	HV *hv;

	UA_TranslateBrowsePathsToNodeIdsResponse_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "TranslateBrowsePathsToNodeIdsResponse_responseHeader", 0);
	if (value != NULL)
		out.responseHeader = XS_unpack_UA_ResponseHeader(*value);

	/* TODO Implement array conversion for field results */

	/* TODO Implement array conversion for field diagnosticInfos */

	return out;
}

/* RegisterNodesRequest */
static void XS_pack_UA_RegisterNodesRequest(SV *out, UA_RegisterNodesRequest in)  __attribute__((unused));
static void
XS_pack_UA_RegisterNodesRequest(SV *out, UA_RegisterNodesRequest in)
{
	HV *hash = newHV();

	SV *requestHeaderSV = newSV(0);
	XS_pack_UA_RequestHeader(requestHeaderSV, in.requestHeader);
	hv_stores(hash, "RegisterNodesRequest_requestHeader", requestHeaderSV);

	AV *nodesToRegisterArray = (AV*) sv_2mortal((SV*)newAV());
	size_t nodesToRegisterI;
	for(nodesToRegisterI = 0; nodesToRegisterI < in.nodesToRegisterSize; nodesToRegisterI++) {
		SV *element = newSV(0);
		XS_pack_UA_NodeId(element, in.nodesToRegister[nodesToRegisterI]);
		av_push(nodesToRegisterArray, element);
	}
	hv_stores(hash, "RegisterNodesRequest_nodesToRegister", newRV_inc((SV*)nodesToRegisterArray));

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_RegisterNodesRequest XS_unpack_UA_RegisterNodesRequest(SV *in)  __attribute__((unused));
static UA_RegisterNodesRequest
XS_unpack_UA_RegisterNodesRequest(SV *in)
{
	UA_RegisterNodesRequest out;
	SV **value;
	HV *hv;

	UA_RegisterNodesRequest_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "RegisterNodesRequest_requestHeader", 0);
	if (value != NULL)
		out.requestHeader = XS_unpack_UA_RequestHeader(*value);

	/* TODO Implement array conversion for field nodesToRegister */

	return out;
}

/* RegisterNodesResponse */
static void XS_pack_UA_RegisterNodesResponse(SV *out, UA_RegisterNodesResponse in)  __attribute__((unused));
static void
XS_pack_UA_RegisterNodesResponse(SV *out, UA_RegisterNodesResponse in)
{
	HV *hash = newHV();

	SV *responseHeaderSV = newSV(0);
	XS_pack_UA_ResponseHeader(responseHeaderSV, in.responseHeader);
	hv_stores(hash, "RegisterNodesResponse_responseHeader", responseHeaderSV);

	AV *registeredNodeIdsArray = (AV*) sv_2mortal((SV*)newAV());
	size_t registeredNodeIdsI;
	for(registeredNodeIdsI = 0; registeredNodeIdsI < in.registeredNodeIdsSize; registeredNodeIdsI++) {
		SV *element = newSV(0);
		XS_pack_UA_NodeId(element, in.registeredNodeIds[registeredNodeIdsI]);
		av_push(registeredNodeIdsArray, element);
	}
	hv_stores(hash, "RegisterNodesResponse_registeredNodeIds", newRV_inc((SV*)registeredNodeIdsArray));

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_RegisterNodesResponse XS_unpack_UA_RegisterNodesResponse(SV *in)  __attribute__((unused));
static UA_RegisterNodesResponse
XS_unpack_UA_RegisterNodesResponse(SV *in)
{
	UA_RegisterNodesResponse out;
	SV **value;
	HV *hv;

	UA_RegisterNodesResponse_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "RegisterNodesResponse_responseHeader", 0);
	if (value != NULL)
		out.responseHeader = XS_unpack_UA_ResponseHeader(*value);

	/* TODO Implement array conversion for field registeredNodeIds */

	return out;
}

/* UnregisterNodesRequest */
static void XS_pack_UA_UnregisterNodesRequest(SV *out, UA_UnregisterNodesRequest in)  __attribute__((unused));
static void
XS_pack_UA_UnregisterNodesRequest(SV *out, UA_UnregisterNodesRequest in)
{
	HV *hash = newHV();

	SV *requestHeaderSV = newSV(0);
	XS_pack_UA_RequestHeader(requestHeaderSV, in.requestHeader);
	hv_stores(hash, "UnregisterNodesRequest_requestHeader", requestHeaderSV);

	AV *nodesToUnregisterArray = (AV*) sv_2mortal((SV*)newAV());
	size_t nodesToUnregisterI;
	for(nodesToUnregisterI = 0; nodesToUnregisterI < in.nodesToUnregisterSize; nodesToUnregisterI++) {
		SV *element = newSV(0);
		XS_pack_UA_NodeId(element, in.nodesToUnregister[nodesToUnregisterI]);
		av_push(nodesToUnregisterArray, element);
	}
	hv_stores(hash, "UnregisterNodesRequest_nodesToUnregister", newRV_inc((SV*)nodesToUnregisterArray));

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_UnregisterNodesRequest XS_unpack_UA_UnregisterNodesRequest(SV *in)  __attribute__((unused));
static UA_UnregisterNodesRequest
XS_unpack_UA_UnregisterNodesRequest(SV *in)
{
	UA_UnregisterNodesRequest out;
	SV **value;
	HV *hv;

	UA_UnregisterNodesRequest_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "UnregisterNodesRequest_requestHeader", 0);
	if (value != NULL)
		out.requestHeader = XS_unpack_UA_RequestHeader(*value);

	/* TODO Implement array conversion for field nodesToUnregister */

	return out;
}

/* UnregisterNodesResponse */
static void XS_pack_UA_UnregisterNodesResponse(SV *out, UA_UnregisterNodesResponse in)  __attribute__((unused));
static void
XS_pack_UA_UnregisterNodesResponse(SV *out, UA_UnregisterNodesResponse in)
{
	HV *hash = newHV();

	SV *responseHeaderSV = newSV(0);
	XS_pack_UA_ResponseHeader(responseHeaderSV, in.responseHeader);
	hv_stores(hash, "UnregisterNodesResponse_responseHeader", responseHeaderSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_UnregisterNodesResponse XS_unpack_UA_UnregisterNodesResponse(SV *in)  __attribute__((unused));
static UA_UnregisterNodesResponse
XS_unpack_UA_UnregisterNodesResponse(SV *in)
{
	UA_UnregisterNodesResponse out;
	SV **value;
	HV *hv;

	UA_UnregisterNodesResponse_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "UnregisterNodesResponse_responseHeader", 0);
	if (value != NULL)
		out.responseHeader = XS_unpack_UA_ResponseHeader(*value);

	return out;
}

/* FilterOperator */
static void XS_pack_UA_FilterOperator(SV *out, UA_FilterOperator in)  __attribute__((unused));
static void
XS_pack_UA_FilterOperator(SV *out, UA_FilterOperator in)
{
	/* TODO implement EnumerationType conversion */

}

static UA_FilterOperator XS_unpack_UA_FilterOperator(SV *in)  __attribute__((unused));
static UA_FilterOperator
XS_unpack_UA_FilterOperator(SV *in)
{
	/* TODO implement EnumerationType conversion */
}

/* ContentFilterElement */
static void XS_pack_UA_ContentFilterElement(SV *out, UA_ContentFilterElement in)  __attribute__((unused));
static void
XS_pack_UA_ContentFilterElement(SV *out, UA_ContentFilterElement in)
{
	HV *hash = newHV();

	SV *filterOperatorSV = newSV(0);
	XS_pack_UA_FilterOperator(filterOperatorSV, in.filterOperator);
	hv_stores(hash, "ContentFilterElement_filterOperator", filterOperatorSV);

	AV *filterOperandsArray = (AV*) sv_2mortal((SV*)newAV());
	size_t filterOperandsI;
	for(filterOperandsI = 0; filterOperandsI < in.filterOperandsSize; filterOperandsI++) {
		SV *element = newSV(0);
		XS_pack_UA_ExtensionObject(element, in.filterOperands[filterOperandsI]);
		av_push(filterOperandsArray, element);
	}
	hv_stores(hash, "ContentFilterElement_filterOperands", newRV_inc((SV*)filterOperandsArray));

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_ContentFilterElement XS_unpack_UA_ContentFilterElement(SV *in)  __attribute__((unused));
static UA_ContentFilterElement
XS_unpack_UA_ContentFilterElement(SV *in)
{
	UA_ContentFilterElement out;
	SV **value;
	HV *hv;

	UA_ContentFilterElement_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "ContentFilterElement_filterOperator", 0);
	if (value != NULL)
		out.filterOperator = XS_unpack_UA_FilterOperator(*value);

	/* TODO Implement array conversion for field filterOperands */

	return out;
}

/* ContentFilter */
static void XS_pack_UA_ContentFilter(SV *out, UA_ContentFilter in)  __attribute__((unused));
static void
XS_pack_UA_ContentFilter(SV *out, UA_ContentFilter in)
{
	HV *hash = newHV();

	AV *elementsArray = (AV*) sv_2mortal((SV*)newAV());
	size_t elementsI;
	for(elementsI = 0; elementsI < in.elementsSize; elementsI++) {
		SV *element = newSV(0);
		XS_pack_UA_ContentFilterElement(element, in.elements[elementsI]);
		av_push(elementsArray, element);
	}
	hv_stores(hash, "ContentFilter_elements", newRV_inc((SV*)elementsArray));

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_ContentFilter XS_unpack_UA_ContentFilter(SV *in)  __attribute__((unused));
static UA_ContentFilter
XS_unpack_UA_ContentFilter(SV *in)
{
	UA_ContentFilter out;
	SV **value;
	HV *hv;

	UA_ContentFilter_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	/* TODO Implement array conversion for field elements */

	return out;
}

/* FilterOperand */
static void XS_pack_UA_FilterOperand(SV *out, UA_FilterOperand in)  __attribute__((unused));
static void
XS_pack_UA_FilterOperand(SV *out, UA_FilterOperand in)
{

}

static UA_FilterOperand XS_unpack_UA_FilterOperand(SV *in)  __attribute__((unused));
static UA_FilterOperand
XS_unpack_UA_FilterOperand(SV *in)
{
}

/* ElementOperand */
static void XS_pack_UA_ElementOperand(SV *out, UA_ElementOperand in)  __attribute__((unused));
static void
XS_pack_UA_ElementOperand(SV *out, UA_ElementOperand in)
{
	HV *hash = newHV();

	SV *indexSV = newSV(0);
	XS_pack_UA_UInt32(indexSV, in.index);
	hv_stores(hash, "ElementOperand_index", indexSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_ElementOperand XS_unpack_UA_ElementOperand(SV *in)  __attribute__((unused));
static UA_ElementOperand
XS_unpack_UA_ElementOperand(SV *in)
{
	UA_ElementOperand out;
	SV **value;
	HV *hv;

	UA_ElementOperand_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "ElementOperand_index", 0);
	if (value != NULL)
		out.index = XS_unpack_UA_UInt32(*value);

	return out;
}

/* LiteralOperand */
static void XS_pack_UA_LiteralOperand(SV *out, UA_LiteralOperand in)  __attribute__((unused));
static void
XS_pack_UA_LiteralOperand(SV *out, UA_LiteralOperand in)
{
	HV *hash = newHV();

	SV *valueSV = newSV(0);
	XS_pack_UA_Variant(valueSV, in.value);
	hv_stores(hash, "LiteralOperand_value", valueSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_LiteralOperand XS_unpack_UA_LiteralOperand(SV *in)  __attribute__((unused));
static UA_LiteralOperand
XS_unpack_UA_LiteralOperand(SV *in)
{
	UA_LiteralOperand out;
	SV **value;
	HV *hv;

	UA_LiteralOperand_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "LiteralOperand_value", 0);
	if (value != NULL)
		out.value = XS_unpack_UA_Variant(*value);

	return out;
}

/* AttributeOperand */
static void XS_pack_UA_AttributeOperand(SV *out, UA_AttributeOperand in)  __attribute__((unused));
static void
XS_pack_UA_AttributeOperand(SV *out, UA_AttributeOperand in)
{
	HV *hash = newHV();

	SV *nodeIdSV = newSV(0);
	XS_pack_UA_NodeId(nodeIdSV, in.nodeId);
	hv_stores(hash, "AttributeOperand_nodeId", nodeIdSV);

	SV *aliasSV = newSV(0);
	XS_pack_UA_String(aliasSV, in.alias);
	hv_stores(hash, "AttributeOperand_alias", aliasSV);

	SV *browsePathSV = newSV(0);
	XS_pack_UA_RelativePath(browsePathSV, in.browsePath);
	hv_stores(hash, "AttributeOperand_browsePath", browsePathSV);

	SV *attributeIdSV = newSV(0);
	XS_pack_UA_UInt32(attributeIdSV, in.attributeId);
	hv_stores(hash, "AttributeOperand_attributeId", attributeIdSV);

	SV *indexRangeSV = newSV(0);
	XS_pack_UA_String(indexRangeSV, in.indexRange);
	hv_stores(hash, "AttributeOperand_indexRange", indexRangeSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_AttributeOperand XS_unpack_UA_AttributeOperand(SV *in)  __attribute__((unused));
static UA_AttributeOperand
XS_unpack_UA_AttributeOperand(SV *in)
{
	UA_AttributeOperand out;
	SV **value;
	HV *hv;

	UA_AttributeOperand_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "AttributeOperand_nodeId", 0);
	if (value != NULL)
		out.nodeId = XS_unpack_UA_NodeId(*value);

	value = hv_fetchs(hv, "AttributeOperand_alias", 0);
	if (value != NULL)
		out.alias = XS_unpack_UA_String(*value);

	value = hv_fetchs(hv, "AttributeOperand_browsePath", 0);
	if (value != NULL)
		out.browsePath = XS_unpack_UA_RelativePath(*value);

	value = hv_fetchs(hv, "AttributeOperand_attributeId", 0);
	if (value != NULL)
		out.attributeId = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "AttributeOperand_indexRange", 0);
	if (value != NULL)
		out.indexRange = XS_unpack_UA_String(*value);

	return out;
}

/* SimpleAttributeOperand */
static void XS_pack_UA_SimpleAttributeOperand(SV *out, UA_SimpleAttributeOperand in)  __attribute__((unused));
static void
XS_pack_UA_SimpleAttributeOperand(SV *out, UA_SimpleAttributeOperand in)
{
	HV *hash = newHV();

	SV *typeDefinitionIdSV = newSV(0);
	XS_pack_UA_NodeId(typeDefinitionIdSV, in.typeDefinitionId);
	hv_stores(hash, "SimpleAttributeOperand_typeDefinitionId", typeDefinitionIdSV);

	AV *browsePathArray = (AV*) sv_2mortal((SV*)newAV());
	size_t browsePathI;
	for(browsePathI = 0; browsePathI < in.browsePathSize; browsePathI++) {
		SV *element = newSV(0);
		XS_pack_UA_QualifiedName(element, in.browsePath[browsePathI]);
		av_push(browsePathArray, element);
	}
	hv_stores(hash, "SimpleAttributeOperand_browsePath", newRV_inc((SV*)browsePathArray));

	SV *attributeIdSV = newSV(0);
	XS_pack_UA_UInt32(attributeIdSV, in.attributeId);
	hv_stores(hash, "SimpleAttributeOperand_attributeId", attributeIdSV);

	SV *indexRangeSV = newSV(0);
	XS_pack_UA_String(indexRangeSV, in.indexRange);
	hv_stores(hash, "SimpleAttributeOperand_indexRange", indexRangeSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_SimpleAttributeOperand XS_unpack_UA_SimpleAttributeOperand(SV *in)  __attribute__((unused));
static UA_SimpleAttributeOperand
XS_unpack_UA_SimpleAttributeOperand(SV *in)
{
	UA_SimpleAttributeOperand out;
	SV **value;
	HV *hv;

	UA_SimpleAttributeOperand_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "SimpleAttributeOperand_typeDefinitionId", 0);
	if (value != NULL)
		out.typeDefinitionId = XS_unpack_UA_NodeId(*value);

	/* TODO Implement array conversion for field browsePath */

	value = hv_fetchs(hv, "SimpleAttributeOperand_attributeId", 0);
	if (value != NULL)
		out.attributeId = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "SimpleAttributeOperand_indexRange", 0);
	if (value != NULL)
		out.indexRange = XS_unpack_UA_String(*value);

	return out;
}

/* ContentFilterElementResult */
static void XS_pack_UA_ContentFilterElementResult(SV *out, UA_ContentFilterElementResult in)  __attribute__((unused));
static void
XS_pack_UA_ContentFilterElementResult(SV *out, UA_ContentFilterElementResult in)
{
	HV *hash = newHV();

	SV *statusCodeSV = newSV(0);
	XS_pack_UA_StatusCode(statusCodeSV, in.statusCode);
	hv_stores(hash, "ContentFilterElementResult_statusCode", statusCodeSV);

	AV *operandStatusCodesArray = (AV*) sv_2mortal((SV*)newAV());
	size_t operandStatusCodesI;
	for(operandStatusCodesI = 0; operandStatusCodesI < in.operandStatusCodesSize; operandStatusCodesI++) {
		SV *element = newSV(0);
		XS_pack_UA_StatusCode(element, in.operandStatusCodes[operandStatusCodesI]);
		av_push(operandStatusCodesArray, element);
	}
	hv_stores(hash, "ContentFilterElementResult_operandStatusCodes", newRV_inc((SV*)operandStatusCodesArray));

	AV *operandDiagnosticInfosArray = (AV*) sv_2mortal((SV*)newAV());
	size_t operandDiagnosticInfosI;
	for(operandDiagnosticInfosI = 0; operandDiagnosticInfosI < in.operandDiagnosticInfosSize; operandDiagnosticInfosI++) {
		SV *element = newSV(0);
		XS_pack_UA_DiagnosticInfo(element, in.operandDiagnosticInfos[operandDiagnosticInfosI]);
		av_push(operandDiagnosticInfosArray, element);
	}
	hv_stores(hash, "ContentFilterElementResult_operandDiagnosticInfos", newRV_inc((SV*)operandDiagnosticInfosArray));

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_ContentFilterElementResult XS_unpack_UA_ContentFilterElementResult(SV *in)  __attribute__((unused));
static UA_ContentFilterElementResult
XS_unpack_UA_ContentFilterElementResult(SV *in)
{
	UA_ContentFilterElementResult out;
	SV **value;
	HV *hv;

	UA_ContentFilterElementResult_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "ContentFilterElementResult_statusCode", 0);
	if (value != NULL)
		out.statusCode = XS_unpack_UA_StatusCode(*value);

	/* TODO Implement array conversion for field operandStatusCodes */

	/* TODO Implement array conversion for field operandDiagnosticInfos */

	return out;
}

/* ContentFilterResult */
static void XS_pack_UA_ContentFilterResult(SV *out, UA_ContentFilterResult in)  __attribute__((unused));
static void
XS_pack_UA_ContentFilterResult(SV *out, UA_ContentFilterResult in)
{
	HV *hash = newHV();

	AV *elementResultsArray = (AV*) sv_2mortal((SV*)newAV());
	size_t elementResultsI;
	for(elementResultsI = 0; elementResultsI < in.elementResultsSize; elementResultsI++) {
		SV *element = newSV(0);
		XS_pack_UA_ContentFilterElementResult(element, in.elementResults[elementResultsI]);
		av_push(elementResultsArray, element);
	}
	hv_stores(hash, "ContentFilterResult_elementResults", newRV_inc((SV*)elementResultsArray));

	AV *elementDiagnosticInfosArray = (AV*) sv_2mortal((SV*)newAV());
	size_t elementDiagnosticInfosI;
	for(elementDiagnosticInfosI = 0; elementDiagnosticInfosI < in.elementDiagnosticInfosSize; elementDiagnosticInfosI++) {
		SV *element = newSV(0);
		XS_pack_UA_DiagnosticInfo(element, in.elementDiagnosticInfos[elementDiagnosticInfosI]);
		av_push(elementDiagnosticInfosArray, element);
	}
	hv_stores(hash, "ContentFilterResult_elementDiagnosticInfos", newRV_inc((SV*)elementDiagnosticInfosArray));

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_ContentFilterResult XS_unpack_UA_ContentFilterResult(SV *in)  __attribute__((unused));
static UA_ContentFilterResult
XS_unpack_UA_ContentFilterResult(SV *in)
{
	UA_ContentFilterResult out;
	SV **value;
	HV *hv;

	UA_ContentFilterResult_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	/* TODO Implement array conversion for field elementResults */

	/* TODO Implement array conversion for field elementDiagnosticInfos */

	return out;
}

/* TimestampsToReturn */
static void XS_pack_UA_TimestampsToReturn(SV *out, UA_TimestampsToReturn in)  __attribute__((unused));
static void
XS_pack_UA_TimestampsToReturn(SV *out, UA_TimestampsToReturn in)
{
	/* TODO implement EnumerationType conversion */

}

static UA_TimestampsToReturn XS_unpack_UA_TimestampsToReturn(SV *in)  __attribute__((unused));
static UA_TimestampsToReturn
XS_unpack_UA_TimestampsToReturn(SV *in)
{
	/* TODO implement EnumerationType conversion */
}

/* ReadValueId */
static void XS_pack_UA_ReadValueId(SV *out, UA_ReadValueId in)  __attribute__((unused));
static void
XS_pack_UA_ReadValueId(SV *out, UA_ReadValueId in)
{
	HV *hash = newHV();

	SV *nodeIdSV = newSV(0);
	XS_pack_UA_NodeId(nodeIdSV, in.nodeId);
	hv_stores(hash, "ReadValueId_nodeId", nodeIdSV);

	SV *attributeIdSV = newSV(0);
	XS_pack_UA_UInt32(attributeIdSV, in.attributeId);
	hv_stores(hash, "ReadValueId_attributeId", attributeIdSV);

	SV *indexRangeSV = newSV(0);
	XS_pack_UA_String(indexRangeSV, in.indexRange);
	hv_stores(hash, "ReadValueId_indexRange", indexRangeSV);

	SV *dataEncodingSV = newSV(0);
	XS_pack_UA_QualifiedName(dataEncodingSV, in.dataEncoding);
	hv_stores(hash, "ReadValueId_dataEncoding", dataEncodingSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_ReadValueId XS_unpack_UA_ReadValueId(SV *in)  __attribute__((unused));
static UA_ReadValueId
XS_unpack_UA_ReadValueId(SV *in)
{
	UA_ReadValueId out;
	SV **value;
	HV *hv;

	UA_ReadValueId_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "ReadValueId_nodeId", 0);
	if (value != NULL)
		out.nodeId = XS_unpack_UA_NodeId(*value);

	value = hv_fetchs(hv, "ReadValueId_attributeId", 0);
	if (value != NULL)
		out.attributeId = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "ReadValueId_indexRange", 0);
	if (value != NULL)
		out.indexRange = XS_unpack_UA_String(*value);

	value = hv_fetchs(hv, "ReadValueId_dataEncoding", 0);
	if (value != NULL)
		out.dataEncoding = XS_unpack_UA_QualifiedName(*value);

	return out;
}

/* ReadRequest */
static void XS_pack_UA_ReadRequest(SV *out, UA_ReadRequest in)  __attribute__((unused));
static void
XS_pack_UA_ReadRequest(SV *out, UA_ReadRequest in)
{
	HV *hash = newHV();

	SV *requestHeaderSV = newSV(0);
	XS_pack_UA_RequestHeader(requestHeaderSV, in.requestHeader);
	hv_stores(hash, "ReadRequest_requestHeader", requestHeaderSV);

	SV *maxAgeSV = newSV(0);
	XS_pack_UA_Double(maxAgeSV, in.maxAge);
	hv_stores(hash, "ReadRequest_maxAge", maxAgeSV);

	SV *timestampsToReturnSV = newSV(0);
	XS_pack_UA_TimestampsToReturn(timestampsToReturnSV, in.timestampsToReturn);
	hv_stores(hash, "ReadRequest_timestampsToReturn", timestampsToReturnSV);

	AV *nodesToReadArray = (AV*) sv_2mortal((SV*)newAV());
	size_t nodesToReadI;
	for(nodesToReadI = 0; nodesToReadI < in.nodesToReadSize; nodesToReadI++) {
		SV *element = newSV(0);
		XS_pack_UA_ReadValueId(element, in.nodesToRead[nodesToReadI]);
		av_push(nodesToReadArray, element);
	}
	hv_stores(hash, "ReadRequest_nodesToRead", newRV_inc((SV*)nodesToReadArray));

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_ReadRequest XS_unpack_UA_ReadRequest(SV *in)  __attribute__((unused));
static UA_ReadRequest
XS_unpack_UA_ReadRequest(SV *in)
{
	UA_ReadRequest out;
	SV **value;
	HV *hv;

	UA_ReadRequest_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "ReadRequest_requestHeader", 0);
	if (value != NULL)
		out.requestHeader = XS_unpack_UA_RequestHeader(*value);

	value = hv_fetchs(hv, "ReadRequest_maxAge", 0);
	if (value != NULL)
		out.maxAge = XS_unpack_UA_Double(*value);

	value = hv_fetchs(hv, "ReadRequest_timestampsToReturn", 0);
	if (value != NULL)
		out.timestampsToReturn = XS_unpack_UA_TimestampsToReturn(*value);

	/* TODO Implement array conversion for field nodesToRead */

	return out;
}

/* ReadResponse */
static void XS_pack_UA_ReadResponse(SV *out, UA_ReadResponse in)  __attribute__((unused));
static void
XS_pack_UA_ReadResponse(SV *out, UA_ReadResponse in)
{
	HV *hash = newHV();

	SV *responseHeaderSV = newSV(0);
	XS_pack_UA_ResponseHeader(responseHeaderSV, in.responseHeader);
	hv_stores(hash, "ReadResponse_responseHeader", responseHeaderSV);

	AV *resultsArray = (AV*) sv_2mortal((SV*)newAV());
	size_t resultsI;
	for(resultsI = 0; resultsI < in.resultsSize; resultsI++) {
		SV *element = newSV(0);
		XS_pack_UA_DataValue(element, in.results[resultsI]);
		av_push(resultsArray, element);
	}
	hv_stores(hash, "ReadResponse_results", newRV_inc((SV*)resultsArray));

	AV *diagnosticInfosArray = (AV*) sv_2mortal((SV*)newAV());
	size_t diagnosticInfosI;
	for(diagnosticInfosI = 0; diagnosticInfosI < in.diagnosticInfosSize; diagnosticInfosI++) {
		SV *element = newSV(0);
		XS_pack_UA_DiagnosticInfo(element, in.diagnosticInfos[diagnosticInfosI]);
		av_push(diagnosticInfosArray, element);
	}
	hv_stores(hash, "ReadResponse_diagnosticInfos", newRV_inc((SV*)diagnosticInfosArray));

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_ReadResponse XS_unpack_UA_ReadResponse(SV *in)  __attribute__((unused));
static UA_ReadResponse
XS_unpack_UA_ReadResponse(SV *in)
{
	UA_ReadResponse out;
	SV **value;
	HV *hv;

	UA_ReadResponse_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "ReadResponse_responseHeader", 0);
	if (value != NULL)
		out.responseHeader = XS_unpack_UA_ResponseHeader(*value);

	/* TODO Implement array conversion for field results */

	/* TODO Implement array conversion for field diagnosticInfos */

	return out;
}

/* WriteValue */
static void XS_pack_UA_WriteValue(SV *out, UA_WriteValue in)  __attribute__((unused));
static void
XS_pack_UA_WriteValue(SV *out, UA_WriteValue in)
{
	HV *hash = newHV();

	SV *nodeIdSV = newSV(0);
	XS_pack_UA_NodeId(nodeIdSV, in.nodeId);
	hv_stores(hash, "WriteValue_nodeId", nodeIdSV);

	SV *attributeIdSV = newSV(0);
	XS_pack_UA_UInt32(attributeIdSV, in.attributeId);
	hv_stores(hash, "WriteValue_attributeId", attributeIdSV);

	SV *indexRangeSV = newSV(0);
	XS_pack_UA_String(indexRangeSV, in.indexRange);
	hv_stores(hash, "WriteValue_indexRange", indexRangeSV);

	SV *valueSV = newSV(0);
	XS_pack_UA_DataValue(valueSV, in.value);
	hv_stores(hash, "WriteValue_value", valueSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_WriteValue XS_unpack_UA_WriteValue(SV *in)  __attribute__((unused));
static UA_WriteValue
XS_unpack_UA_WriteValue(SV *in)
{
	UA_WriteValue out;
	SV **value;
	HV *hv;

	UA_WriteValue_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "WriteValue_nodeId", 0);
	if (value != NULL)
		out.nodeId = XS_unpack_UA_NodeId(*value);

	value = hv_fetchs(hv, "WriteValue_attributeId", 0);
	if (value != NULL)
		out.attributeId = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "WriteValue_indexRange", 0);
	if (value != NULL)
		out.indexRange = XS_unpack_UA_String(*value);

	value = hv_fetchs(hv, "WriteValue_value", 0);
	if (value != NULL)
		out.value = XS_unpack_UA_DataValue(*value);

	return out;
}

/* WriteRequest */
static void XS_pack_UA_WriteRequest(SV *out, UA_WriteRequest in)  __attribute__((unused));
static void
XS_pack_UA_WriteRequest(SV *out, UA_WriteRequest in)
{
	HV *hash = newHV();

	SV *requestHeaderSV = newSV(0);
	XS_pack_UA_RequestHeader(requestHeaderSV, in.requestHeader);
	hv_stores(hash, "WriteRequest_requestHeader", requestHeaderSV);

	AV *nodesToWriteArray = (AV*) sv_2mortal((SV*)newAV());
	size_t nodesToWriteI;
	for(nodesToWriteI = 0; nodesToWriteI < in.nodesToWriteSize; nodesToWriteI++) {
		SV *element = newSV(0);
		XS_pack_UA_WriteValue(element, in.nodesToWrite[nodesToWriteI]);
		av_push(nodesToWriteArray, element);
	}
	hv_stores(hash, "WriteRequest_nodesToWrite", newRV_inc((SV*)nodesToWriteArray));

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_WriteRequest XS_unpack_UA_WriteRequest(SV *in)  __attribute__((unused));
static UA_WriteRequest
XS_unpack_UA_WriteRequest(SV *in)
{
	UA_WriteRequest out;
	SV **value;
	HV *hv;

	UA_WriteRequest_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "WriteRequest_requestHeader", 0);
	if (value != NULL)
		out.requestHeader = XS_unpack_UA_RequestHeader(*value);

	/* TODO Implement array conversion for field nodesToWrite */

	return out;
}

/* WriteResponse */
static void XS_pack_UA_WriteResponse(SV *out, UA_WriteResponse in)  __attribute__((unused));
static void
XS_pack_UA_WriteResponse(SV *out, UA_WriteResponse in)
{
	HV *hash = newHV();

	SV *responseHeaderSV = newSV(0);
	XS_pack_UA_ResponseHeader(responseHeaderSV, in.responseHeader);
	hv_stores(hash, "WriteResponse_responseHeader", responseHeaderSV);

	AV *resultsArray = (AV*) sv_2mortal((SV*)newAV());
	size_t resultsI;
	for(resultsI = 0; resultsI < in.resultsSize; resultsI++) {
		SV *element = newSV(0);
		XS_pack_UA_StatusCode(element, in.results[resultsI]);
		av_push(resultsArray, element);
	}
	hv_stores(hash, "WriteResponse_results", newRV_inc((SV*)resultsArray));

	AV *diagnosticInfosArray = (AV*) sv_2mortal((SV*)newAV());
	size_t diagnosticInfosI;
	for(diagnosticInfosI = 0; diagnosticInfosI < in.diagnosticInfosSize; diagnosticInfosI++) {
		SV *element = newSV(0);
		XS_pack_UA_DiagnosticInfo(element, in.diagnosticInfos[diagnosticInfosI]);
		av_push(diagnosticInfosArray, element);
	}
	hv_stores(hash, "WriteResponse_diagnosticInfos", newRV_inc((SV*)diagnosticInfosArray));

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_WriteResponse XS_unpack_UA_WriteResponse(SV *in)  __attribute__((unused));
static UA_WriteResponse
XS_unpack_UA_WriteResponse(SV *in)
{
	UA_WriteResponse out;
	SV **value;
	HV *hv;

	UA_WriteResponse_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "WriteResponse_responseHeader", 0);
	if (value != NULL)
		out.responseHeader = XS_unpack_UA_ResponseHeader(*value);

	/* TODO Implement array conversion for field results */

	/* TODO Implement array conversion for field diagnosticInfos */

	return out;
}

/* CallMethodRequest */
static void XS_pack_UA_CallMethodRequest(SV *out, UA_CallMethodRequest in)  __attribute__((unused));
static void
XS_pack_UA_CallMethodRequest(SV *out, UA_CallMethodRequest in)
{
	HV *hash = newHV();

	SV *objectIdSV = newSV(0);
	XS_pack_UA_NodeId(objectIdSV, in.objectId);
	hv_stores(hash, "CallMethodRequest_objectId", objectIdSV);

	SV *methodIdSV = newSV(0);
	XS_pack_UA_NodeId(methodIdSV, in.methodId);
	hv_stores(hash, "CallMethodRequest_methodId", methodIdSV);

	AV *inputArgumentsArray = (AV*) sv_2mortal((SV*)newAV());
	size_t inputArgumentsI;
	for(inputArgumentsI = 0; inputArgumentsI < in.inputArgumentsSize; inputArgumentsI++) {
		SV *element = newSV(0);
		XS_pack_UA_Variant(element, in.inputArguments[inputArgumentsI]);
		av_push(inputArgumentsArray, element);
	}
	hv_stores(hash, "CallMethodRequest_inputArguments", newRV_inc((SV*)inputArgumentsArray));

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_CallMethodRequest XS_unpack_UA_CallMethodRequest(SV *in)  __attribute__((unused));
static UA_CallMethodRequest
XS_unpack_UA_CallMethodRequest(SV *in)
{
	UA_CallMethodRequest out;
	SV **value;
	HV *hv;

	UA_CallMethodRequest_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "CallMethodRequest_objectId", 0);
	if (value != NULL)
		out.objectId = XS_unpack_UA_NodeId(*value);

	value = hv_fetchs(hv, "CallMethodRequest_methodId", 0);
	if (value != NULL)
		out.methodId = XS_unpack_UA_NodeId(*value);

	/* TODO Implement array conversion for field inputArguments */

	return out;
}

/* CallMethodResult */
static void XS_pack_UA_CallMethodResult(SV *out, UA_CallMethodResult in)  __attribute__((unused));
static void
XS_pack_UA_CallMethodResult(SV *out, UA_CallMethodResult in)
{
	HV *hash = newHV();

	SV *statusCodeSV = newSV(0);
	XS_pack_UA_StatusCode(statusCodeSV, in.statusCode);
	hv_stores(hash, "CallMethodResult_statusCode", statusCodeSV);

	AV *inputArgumentResultsArray = (AV*) sv_2mortal((SV*)newAV());
	size_t inputArgumentResultsI;
	for(inputArgumentResultsI = 0; inputArgumentResultsI < in.inputArgumentResultsSize; inputArgumentResultsI++) {
		SV *element = newSV(0);
		XS_pack_UA_StatusCode(element, in.inputArgumentResults[inputArgumentResultsI]);
		av_push(inputArgumentResultsArray, element);
	}
	hv_stores(hash, "CallMethodResult_inputArgumentResults", newRV_inc((SV*)inputArgumentResultsArray));

	AV *inputArgumentDiagnosticInfosArray = (AV*) sv_2mortal((SV*)newAV());
	size_t inputArgumentDiagnosticInfosI;
	for(inputArgumentDiagnosticInfosI = 0; inputArgumentDiagnosticInfosI < in.inputArgumentDiagnosticInfosSize; inputArgumentDiagnosticInfosI++) {
		SV *element = newSV(0);
		XS_pack_UA_DiagnosticInfo(element, in.inputArgumentDiagnosticInfos[inputArgumentDiagnosticInfosI]);
		av_push(inputArgumentDiagnosticInfosArray, element);
	}
	hv_stores(hash, "CallMethodResult_inputArgumentDiagnosticInfos", newRV_inc((SV*)inputArgumentDiagnosticInfosArray));

	AV *outputArgumentsArray = (AV*) sv_2mortal((SV*)newAV());
	size_t outputArgumentsI;
	for(outputArgumentsI = 0; outputArgumentsI < in.outputArgumentsSize; outputArgumentsI++) {
		SV *element = newSV(0);
		XS_pack_UA_Variant(element, in.outputArguments[outputArgumentsI]);
		av_push(outputArgumentsArray, element);
	}
	hv_stores(hash, "CallMethodResult_outputArguments", newRV_inc((SV*)outputArgumentsArray));

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_CallMethodResult XS_unpack_UA_CallMethodResult(SV *in)  __attribute__((unused));
static UA_CallMethodResult
XS_unpack_UA_CallMethodResult(SV *in)
{
	UA_CallMethodResult out;
	SV **value;
	HV *hv;

	UA_CallMethodResult_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "CallMethodResult_statusCode", 0);
	if (value != NULL)
		out.statusCode = XS_unpack_UA_StatusCode(*value);

	/* TODO Implement array conversion for field inputArgumentResults */

	/* TODO Implement array conversion for field inputArgumentDiagnosticInfos */

	/* TODO Implement array conversion for field outputArguments */

	return out;
}

/* CallRequest */
static void XS_pack_UA_CallRequest(SV *out, UA_CallRequest in)  __attribute__((unused));
static void
XS_pack_UA_CallRequest(SV *out, UA_CallRequest in)
{
	HV *hash = newHV();

	SV *requestHeaderSV = newSV(0);
	XS_pack_UA_RequestHeader(requestHeaderSV, in.requestHeader);
	hv_stores(hash, "CallRequest_requestHeader", requestHeaderSV);

	AV *methodsToCallArray = (AV*) sv_2mortal((SV*)newAV());
	size_t methodsToCallI;
	for(methodsToCallI = 0; methodsToCallI < in.methodsToCallSize; methodsToCallI++) {
		SV *element = newSV(0);
		XS_pack_UA_CallMethodRequest(element, in.methodsToCall[methodsToCallI]);
		av_push(methodsToCallArray, element);
	}
	hv_stores(hash, "CallRequest_methodsToCall", newRV_inc((SV*)methodsToCallArray));

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_CallRequest XS_unpack_UA_CallRequest(SV *in)  __attribute__((unused));
static UA_CallRequest
XS_unpack_UA_CallRequest(SV *in)
{
	UA_CallRequest out;
	SV **value;
	HV *hv;

	UA_CallRequest_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "CallRequest_requestHeader", 0);
	if (value != NULL)
		out.requestHeader = XS_unpack_UA_RequestHeader(*value);

	/* TODO Implement array conversion for field methodsToCall */

	return out;
}

/* CallResponse */
static void XS_pack_UA_CallResponse(SV *out, UA_CallResponse in)  __attribute__((unused));
static void
XS_pack_UA_CallResponse(SV *out, UA_CallResponse in)
{
	HV *hash = newHV();

	SV *responseHeaderSV = newSV(0);
	XS_pack_UA_ResponseHeader(responseHeaderSV, in.responseHeader);
	hv_stores(hash, "CallResponse_responseHeader", responseHeaderSV);

	AV *resultsArray = (AV*) sv_2mortal((SV*)newAV());
	size_t resultsI;
	for(resultsI = 0; resultsI < in.resultsSize; resultsI++) {
		SV *element = newSV(0);
		XS_pack_UA_CallMethodResult(element, in.results[resultsI]);
		av_push(resultsArray, element);
	}
	hv_stores(hash, "CallResponse_results", newRV_inc((SV*)resultsArray));

	AV *diagnosticInfosArray = (AV*) sv_2mortal((SV*)newAV());
	size_t diagnosticInfosI;
	for(diagnosticInfosI = 0; diagnosticInfosI < in.diagnosticInfosSize; diagnosticInfosI++) {
		SV *element = newSV(0);
		XS_pack_UA_DiagnosticInfo(element, in.diagnosticInfos[diagnosticInfosI]);
		av_push(diagnosticInfosArray, element);
	}
	hv_stores(hash, "CallResponse_diagnosticInfos", newRV_inc((SV*)diagnosticInfosArray));

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_CallResponse XS_unpack_UA_CallResponse(SV *in)  __attribute__((unused));
static UA_CallResponse
XS_unpack_UA_CallResponse(SV *in)
{
	UA_CallResponse out;
	SV **value;
	HV *hv;

	UA_CallResponse_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "CallResponse_responseHeader", 0);
	if (value != NULL)
		out.responseHeader = XS_unpack_UA_ResponseHeader(*value);

	/* TODO Implement array conversion for field results */

	/* TODO Implement array conversion for field diagnosticInfos */

	return out;
}

/* MonitoringMode */
static void XS_pack_UA_MonitoringMode(SV *out, UA_MonitoringMode in)  __attribute__((unused));
static void
XS_pack_UA_MonitoringMode(SV *out, UA_MonitoringMode in)
{
	/* TODO implement EnumerationType conversion */

}

static UA_MonitoringMode XS_unpack_UA_MonitoringMode(SV *in)  __attribute__((unused));
static UA_MonitoringMode
XS_unpack_UA_MonitoringMode(SV *in)
{
	/* TODO implement EnumerationType conversion */
}

/* DataChangeTrigger */
static void XS_pack_UA_DataChangeTrigger(SV *out, UA_DataChangeTrigger in)  __attribute__((unused));
static void
XS_pack_UA_DataChangeTrigger(SV *out, UA_DataChangeTrigger in)
{
	/* TODO implement EnumerationType conversion */

}

static UA_DataChangeTrigger XS_unpack_UA_DataChangeTrigger(SV *in)  __attribute__((unused));
static UA_DataChangeTrigger
XS_unpack_UA_DataChangeTrigger(SV *in)
{
	/* TODO implement EnumerationType conversion */
}

/* DeadbandType */
static void XS_pack_UA_DeadbandType(SV *out, UA_DeadbandType in)  __attribute__((unused));
static void
XS_pack_UA_DeadbandType(SV *out, UA_DeadbandType in)
{
	/* TODO implement EnumerationType conversion */

}

static UA_DeadbandType XS_unpack_UA_DeadbandType(SV *in)  __attribute__((unused));
static UA_DeadbandType
XS_unpack_UA_DeadbandType(SV *in)
{
	/* TODO implement EnumerationType conversion */
}

/* DataChangeFilter */
static void XS_pack_UA_DataChangeFilter(SV *out, UA_DataChangeFilter in)  __attribute__((unused));
static void
XS_pack_UA_DataChangeFilter(SV *out, UA_DataChangeFilter in)
{
	HV *hash = newHV();

	SV *triggerSV = newSV(0);
	XS_pack_UA_DataChangeTrigger(triggerSV, in.trigger);
	hv_stores(hash, "DataChangeFilter_trigger", triggerSV);

	SV *deadbandTypeSV = newSV(0);
	XS_pack_UA_UInt32(deadbandTypeSV, in.deadbandType);
	hv_stores(hash, "DataChangeFilter_deadbandType", deadbandTypeSV);

	SV *deadbandValueSV = newSV(0);
	XS_pack_UA_Double(deadbandValueSV, in.deadbandValue);
	hv_stores(hash, "DataChangeFilter_deadbandValue", deadbandValueSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_DataChangeFilter XS_unpack_UA_DataChangeFilter(SV *in)  __attribute__((unused));
static UA_DataChangeFilter
XS_unpack_UA_DataChangeFilter(SV *in)
{
	UA_DataChangeFilter out;
	SV **value;
	HV *hv;

	UA_DataChangeFilter_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "DataChangeFilter_trigger", 0);
	if (value != NULL)
		out.trigger = XS_unpack_UA_DataChangeTrigger(*value);

	value = hv_fetchs(hv, "DataChangeFilter_deadbandType", 0);
	if (value != NULL)
		out.deadbandType = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "DataChangeFilter_deadbandValue", 0);
	if (value != NULL)
		out.deadbandValue = XS_unpack_UA_Double(*value);

	return out;
}

/* EventFilter */
static void XS_pack_UA_EventFilter(SV *out, UA_EventFilter in)  __attribute__((unused));
static void
XS_pack_UA_EventFilter(SV *out, UA_EventFilter in)
{
	HV *hash = newHV();

	AV *selectClausesArray = (AV*) sv_2mortal((SV*)newAV());
	size_t selectClausesI;
	for(selectClausesI = 0; selectClausesI < in.selectClausesSize; selectClausesI++) {
		SV *element = newSV(0);
		XS_pack_UA_SimpleAttributeOperand(element, in.selectClauses[selectClausesI]);
		av_push(selectClausesArray, element);
	}
	hv_stores(hash, "EventFilter_selectClauses", newRV_inc((SV*)selectClausesArray));

	SV *whereClauseSV = newSV(0);
	XS_pack_UA_ContentFilter(whereClauseSV, in.whereClause);
	hv_stores(hash, "EventFilter_whereClause", whereClauseSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_EventFilter XS_unpack_UA_EventFilter(SV *in)  __attribute__((unused));
static UA_EventFilter
XS_unpack_UA_EventFilter(SV *in)
{
	UA_EventFilter out;
	SV **value;
	HV *hv;

	UA_EventFilter_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	/* TODO Implement array conversion for field selectClauses */

	value = hv_fetchs(hv, "EventFilter_whereClause", 0);
	if (value != NULL)
		out.whereClause = XS_unpack_UA_ContentFilter(*value);

	return out;
}

/* AggregateConfiguration */
static void XS_pack_UA_AggregateConfiguration(SV *out, UA_AggregateConfiguration in)  __attribute__((unused));
static void
XS_pack_UA_AggregateConfiguration(SV *out, UA_AggregateConfiguration in)
{
	HV *hash = newHV();

	SV *useServerCapabilitiesDefaultsSV = newSV(0);
	XS_pack_UA_Boolean(useServerCapabilitiesDefaultsSV, in.useServerCapabilitiesDefaults);
	hv_stores(hash, "AggregateConfiguration_useServerCapabilitiesDefaults", useServerCapabilitiesDefaultsSV);

	SV *treatUncertainAsBadSV = newSV(0);
	XS_pack_UA_Boolean(treatUncertainAsBadSV, in.treatUncertainAsBad);
	hv_stores(hash, "AggregateConfiguration_treatUncertainAsBad", treatUncertainAsBadSV);

	SV *percentDataBadSV = newSV(0);
	XS_pack_UA_Byte(percentDataBadSV, in.percentDataBad);
	hv_stores(hash, "AggregateConfiguration_percentDataBad", percentDataBadSV);

	SV *percentDataGoodSV = newSV(0);
	XS_pack_UA_Byte(percentDataGoodSV, in.percentDataGood);
	hv_stores(hash, "AggregateConfiguration_percentDataGood", percentDataGoodSV);

	SV *useSlopedExtrapolationSV = newSV(0);
	XS_pack_UA_Boolean(useSlopedExtrapolationSV, in.useSlopedExtrapolation);
	hv_stores(hash, "AggregateConfiguration_useSlopedExtrapolation", useSlopedExtrapolationSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_AggregateConfiguration XS_unpack_UA_AggregateConfiguration(SV *in)  __attribute__((unused));
static UA_AggregateConfiguration
XS_unpack_UA_AggregateConfiguration(SV *in)
{
	UA_AggregateConfiguration out;
	SV **value;
	HV *hv;

	UA_AggregateConfiguration_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "AggregateConfiguration_useServerCapabilitiesDefaults", 0);
	if (value != NULL)
		out.useServerCapabilitiesDefaults = XS_unpack_UA_Boolean(*value);

	value = hv_fetchs(hv, "AggregateConfiguration_treatUncertainAsBad", 0);
	if (value != NULL)
		out.treatUncertainAsBad = XS_unpack_UA_Boolean(*value);

	value = hv_fetchs(hv, "AggregateConfiguration_percentDataBad", 0);
	if (value != NULL)
		out.percentDataBad = XS_unpack_UA_Byte(*value);

	value = hv_fetchs(hv, "AggregateConfiguration_percentDataGood", 0);
	if (value != NULL)
		out.percentDataGood = XS_unpack_UA_Byte(*value);

	value = hv_fetchs(hv, "AggregateConfiguration_useSlopedExtrapolation", 0);
	if (value != NULL)
		out.useSlopedExtrapolation = XS_unpack_UA_Boolean(*value);

	return out;
}

/* AggregateFilter */
static void XS_pack_UA_AggregateFilter(SV *out, UA_AggregateFilter in)  __attribute__((unused));
static void
XS_pack_UA_AggregateFilter(SV *out, UA_AggregateFilter in)
{
	HV *hash = newHV();

	SV *startTimeSV = newSV(0);
	XS_pack_UA_DateTime(startTimeSV, in.startTime);
	hv_stores(hash, "AggregateFilter_startTime", startTimeSV);

	SV *aggregateTypeSV = newSV(0);
	XS_pack_UA_NodeId(aggregateTypeSV, in.aggregateType);
	hv_stores(hash, "AggregateFilter_aggregateType", aggregateTypeSV);

	SV *processingIntervalSV = newSV(0);
	XS_pack_UA_Double(processingIntervalSV, in.processingInterval);
	hv_stores(hash, "AggregateFilter_processingInterval", processingIntervalSV);

	SV *aggregateConfigurationSV = newSV(0);
	XS_pack_UA_AggregateConfiguration(aggregateConfigurationSV, in.aggregateConfiguration);
	hv_stores(hash, "AggregateFilter_aggregateConfiguration", aggregateConfigurationSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_AggregateFilter XS_unpack_UA_AggregateFilter(SV *in)  __attribute__((unused));
static UA_AggregateFilter
XS_unpack_UA_AggregateFilter(SV *in)
{
	UA_AggregateFilter out;
	SV **value;
	HV *hv;

	UA_AggregateFilter_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "AggregateFilter_startTime", 0);
	if (value != NULL)
		out.startTime = XS_unpack_UA_DateTime(*value);

	value = hv_fetchs(hv, "AggregateFilter_aggregateType", 0);
	if (value != NULL)
		out.aggregateType = XS_unpack_UA_NodeId(*value);

	value = hv_fetchs(hv, "AggregateFilter_processingInterval", 0);
	if (value != NULL)
		out.processingInterval = XS_unpack_UA_Double(*value);

	value = hv_fetchs(hv, "AggregateFilter_aggregateConfiguration", 0);
	if (value != NULL)
		out.aggregateConfiguration = XS_unpack_UA_AggregateConfiguration(*value);

	return out;
}

/* EventFilterResult */
static void XS_pack_UA_EventFilterResult(SV *out, UA_EventFilterResult in)  __attribute__((unused));
static void
XS_pack_UA_EventFilterResult(SV *out, UA_EventFilterResult in)
{
	HV *hash = newHV();

	AV *selectClauseResultsArray = (AV*) sv_2mortal((SV*)newAV());
	size_t selectClauseResultsI;
	for(selectClauseResultsI = 0; selectClauseResultsI < in.selectClauseResultsSize; selectClauseResultsI++) {
		SV *element = newSV(0);
		XS_pack_UA_StatusCode(element, in.selectClauseResults[selectClauseResultsI]);
		av_push(selectClauseResultsArray, element);
	}
	hv_stores(hash, "EventFilterResult_selectClauseResults", newRV_inc((SV*)selectClauseResultsArray));

	AV *selectClauseDiagnosticInfosArray = (AV*) sv_2mortal((SV*)newAV());
	size_t selectClauseDiagnosticInfosI;
	for(selectClauseDiagnosticInfosI = 0; selectClauseDiagnosticInfosI < in.selectClauseDiagnosticInfosSize; selectClauseDiagnosticInfosI++) {
		SV *element = newSV(0);
		XS_pack_UA_DiagnosticInfo(element, in.selectClauseDiagnosticInfos[selectClauseDiagnosticInfosI]);
		av_push(selectClauseDiagnosticInfosArray, element);
	}
	hv_stores(hash, "EventFilterResult_selectClauseDiagnosticInfos", newRV_inc((SV*)selectClauseDiagnosticInfosArray));

	SV *whereClauseResultSV = newSV(0);
	XS_pack_UA_ContentFilterResult(whereClauseResultSV, in.whereClauseResult);
	hv_stores(hash, "EventFilterResult_whereClauseResult", whereClauseResultSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_EventFilterResult XS_unpack_UA_EventFilterResult(SV *in)  __attribute__((unused));
static UA_EventFilterResult
XS_unpack_UA_EventFilterResult(SV *in)
{
	UA_EventFilterResult out;
	SV **value;
	HV *hv;

	UA_EventFilterResult_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	/* TODO Implement array conversion for field selectClauseResults */

	/* TODO Implement array conversion for field selectClauseDiagnosticInfos */

	value = hv_fetchs(hv, "EventFilterResult_whereClauseResult", 0);
	if (value != NULL)
		out.whereClauseResult = XS_unpack_UA_ContentFilterResult(*value);

	return out;
}

/* MonitoringParameters */
static void XS_pack_UA_MonitoringParameters(SV *out, UA_MonitoringParameters in)  __attribute__((unused));
static void
XS_pack_UA_MonitoringParameters(SV *out, UA_MonitoringParameters in)
{
	HV *hash = newHV();

	SV *clientHandleSV = newSV(0);
	XS_pack_UA_UInt32(clientHandleSV, in.clientHandle);
	hv_stores(hash, "MonitoringParameters_clientHandle", clientHandleSV);

	SV *samplingIntervalSV = newSV(0);
	XS_pack_UA_Double(samplingIntervalSV, in.samplingInterval);
	hv_stores(hash, "MonitoringParameters_samplingInterval", samplingIntervalSV);

	SV *filterSV = newSV(0);
	XS_pack_UA_ExtensionObject(filterSV, in.filter);
	hv_stores(hash, "MonitoringParameters_filter", filterSV);

	SV *queueSizeSV = newSV(0);
	XS_pack_UA_UInt32(queueSizeSV, in.queueSize);
	hv_stores(hash, "MonitoringParameters_queueSize", queueSizeSV);

	SV *discardOldestSV = newSV(0);
	XS_pack_UA_Boolean(discardOldestSV, in.discardOldest);
	hv_stores(hash, "MonitoringParameters_discardOldest", discardOldestSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_MonitoringParameters XS_unpack_UA_MonitoringParameters(SV *in)  __attribute__((unused));
static UA_MonitoringParameters
XS_unpack_UA_MonitoringParameters(SV *in)
{
	UA_MonitoringParameters out;
	SV **value;
	HV *hv;

	UA_MonitoringParameters_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "MonitoringParameters_clientHandle", 0);
	if (value != NULL)
		out.clientHandle = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "MonitoringParameters_samplingInterval", 0);
	if (value != NULL)
		out.samplingInterval = XS_unpack_UA_Double(*value);

	value = hv_fetchs(hv, "MonitoringParameters_filter", 0);
	if (value != NULL)
		out.filter = XS_unpack_UA_ExtensionObject(*value);

	value = hv_fetchs(hv, "MonitoringParameters_queueSize", 0);
	if (value != NULL)
		out.queueSize = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "MonitoringParameters_discardOldest", 0);
	if (value != NULL)
		out.discardOldest = XS_unpack_UA_Boolean(*value);

	return out;
}

/* MonitoredItemCreateRequest */
static void XS_pack_UA_MonitoredItemCreateRequest(SV *out, UA_MonitoredItemCreateRequest in)  __attribute__((unused));
static void
XS_pack_UA_MonitoredItemCreateRequest(SV *out, UA_MonitoredItemCreateRequest in)
{
	HV *hash = newHV();

	SV *itemToMonitorSV = newSV(0);
	XS_pack_UA_ReadValueId(itemToMonitorSV, in.itemToMonitor);
	hv_stores(hash, "MonitoredItemCreateRequest_itemToMonitor", itemToMonitorSV);

	SV *monitoringModeSV = newSV(0);
	XS_pack_UA_MonitoringMode(monitoringModeSV, in.monitoringMode);
	hv_stores(hash, "MonitoredItemCreateRequest_monitoringMode", monitoringModeSV);

	SV *requestedParametersSV = newSV(0);
	XS_pack_UA_MonitoringParameters(requestedParametersSV, in.requestedParameters);
	hv_stores(hash, "MonitoredItemCreateRequest_requestedParameters", requestedParametersSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_MonitoredItemCreateRequest XS_unpack_UA_MonitoredItemCreateRequest(SV *in)  __attribute__((unused));
static UA_MonitoredItemCreateRequest
XS_unpack_UA_MonitoredItemCreateRequest(SV *in)
{
	UA_MonitoredItemCreateRequest out;
	SV **value;
	HV *hv;

	UA_MonitoredItemCreateRequest_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "MonitoredItemCreateRequest_itemToMonitor", 0);
	if (value != NULL)
		out.itemToMonitor = XS_unpack_UA_ReadValueId(*value);

	value = hv_fetchs(hv, "MonitoredItemCreateRequest_monitoringMode", 0);
	if (value != NULL)
		out.monitoringMode = XS_unpack_UA_MonitoringMode(*value);

	value = hv_fetchs(hv, "MonitoredItemCreateRequest_requestedParameters", 0);
	if (value != NULL)
		out.requestedParameters = XS_unpack_UA_MonitoringParameters(*value);

	return out;
}

/* MonitoredItemCreateResult */
static void XS_pack_UA_MonitoredItemCreateResult(SV *out, UA_MonitoredItemCreateResult in)  __attribute__((unused));
static void
XS_pack_UA_MonitoredItemCreateResult(SV *out, UA_MonitoredItemCreateResult in)
{
	HV *hash = newHV();

	SV *statusCodeSV = newSV(0);
	XS_pack_UA_StatusCode(statusCodeSV, in.statusCode);
	hv_stores(hash, "MonitoredItemCreateResult_statusCode", statusCodeSV);

	SV *monitoredItemIdSV = newSV(0);
	XS_pack_UA_UInt32(monitoredItemIdSV, in.monitoredItemId);
	hv_stores(hash, "MonitoredItemCreateResult_monitoredItemId", monitoredItemIdSV);

	SV *revisedSamplingIntervalSV = newSV(0);
	XS_pack_UA_Double(revisedSamplingIntervalSV, in.revisedSamplingInterval);
	hv_stores(hash, "MonitoredItemCreateResult_revisedSamplingInterval", revisedSamplingIntervalSV);

	SV *revisedQueueSizeSV = newSV(0);
	XS_pack_UA_UInt32(revisedQueueSizeSV, in.revisedQueueSize);
	hv_stores(hash, "MonitoredItemCreateResult_revisedQueueSize", revisedQueueSizeSV);

	SV *filterResultSV = newSV(0);
	XS_pack_UA_ExtensionObject(filterResultSV, in.filterResult);
	hv_stores(hash, "MonitoredItemCreateResult_filterResult", filterResultSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_MonitoredItemCreateResult XS_unpack_UA_MonitoredItemCreateResult(SV *in)  __attribute__((unused));
static UA_MonitoredItemCreateResult
XS_unpack_UA_MonitoredItemCreateResult(SV *in)
{
	UA_MonitoredItemCreateResult out;
	SV **value;
	HV *hv;

	UA_MonitoredItemCreateResult_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "MonitoredItemCreateResult_statusCode", 0);
	if (value != NULL)
		out.statusCode = XS_unpack_UA_StatusCode(*value);

	value = hv_fetchs(hv, "MonitoredItemCreateResult_monitoredItemId", 0);
	if (value != NULL)
		out.monitoredItemId = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "MonitoredItemCreateResult_revisedSamplingInterval", 0);
	if (value != NULL)
		out.revisedSamplingInterval = XS_unpack_UA_Double(*value);

	value = hv_fetchs(hv, "MonitoredItemCreateResult_revisedQueueSize", 0);
	if (value != NULL)
		out.revisedQueueSize = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "MonitoredItemCreateResult_filterResult", 0);
	if (value != NULL)
		out.filterResult = XS_unpack_UA_ExtensionObject(*value);

	return out;
}

/* CreateMonitoredItemsRequest */
static void XS_pack_UA_CreateMonitoredItemsRequest(SV *out, UA_CreateMonitoredItemsRequest in)  __attribute__((unused));
static void
XS_pack_UA_CreateMonitoredItemsRequest(SV *out, UA_CreateMonitoredItemsRequest in)
{
	HV *hash = newHV();

	SV *requestHeaderSV = newSV(0);
	XS_pack_UA_RequestHeader(requestHeaderSV, in.requestHeader);
	hv_stores(hash, "CreateMonitoredItemsRequest_requestHeader", requestHeaderSV);

	SV *subscriptionIdSV = newSV(0);
	XS_pack_UA_UInt32(subscriptionIdSV, in.subscriptionId);
	hv_stores(hash, "CreateMonitoredItemsRequest_subscriptionId", subscriptionIdSV);

	SV *timestampsToReturnSV = newSV(0);
	XS_pack_UA_TimestampsToReturn(timestampsToReturnSV, in.timestampsToReturn);
	hv_stores(hash, "CreateMonitoredItemsRequest_timestampsToReturn", timestampsToReturnSV);

	AV *itemsToCreateArray = (AV*) sv_2mortal((SV*)newAV());
	size_t itemsToCreateI;
	for(itemsToCreateI = 0; itemsToCreateI < in.itemsToCreateSize; itemsToCreateI++) {
		SV *element = newSV(0);
		XS_pack_UA_MonitoredItemCreateRequest(element, in.itemsToCreate[itemsToCreateI]);
		av_push(itemsToCreateArray, element);
	}
	hv_stores(hash, "CreateMonitoredItemsRequest_itemsToCreate", newRV_inc((SV*)itemsToCreateArray));

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_CreateMonitoredItemsRequest XS_unpack_UA_CreateMonitoredItemsRequest(SV *in)  __attribute__((unused));
static UA_CreateMonitoredItemsRequest
XS_unpack_UA_CreateMonitoredItemsRequest(SV *in)
{
	UA_CreateMonitoredItemsRequest out;
	SV **value;
	HV *hv;

	UA_CreateMonitoredItemsRequest_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "CreateMonitoredItemsRequest_requestHeader", 0);
	if (value != NULL)
		out.requestHeader = XS_unpack_UA_RequestHeader(*value);

	value = hv_fetchs(hv, "CreateMonitoredItemsRequest_subscriptionId", 0);
	if (value != NULL)
		out.subscriptionId = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "CreateMonitoredItemsRequest_timestampsToReturn", 0);
	if (value != NULL)
		out.timestampsToReturn = XS_unpack_UA_TimestampsToReturn(*value);

	/* TODO Implement array conversion for field itemsToCreate */

	return out;
}

/* CreateMonitoredItemsResponse */
static void XS_pack_UA_CreateMonitoredItemsResponse(SV *out, UA_CreateMonitoredItemsResponse in)  __attribute__((unused));
static void
XS_pack_UA_CreateMonitoredItemsResponse(SV *out, UA_CreateMonitoredItemsResponse in)
{
	HV *hash = newHV();

	SV *responseHeaderSV = newSV(0);
	XS_pack_UA_ResponseHeader(responseHeaderSV, in.responseHeader);
	hv_stores(hash, "CreateMonitoredItemsResponse_responseHeader", responseHeaderSV);

	AV *resultsArray = (AV*) sv_2mortal((SV*)newAV());
	size_t resultsI;
	for(resultsI = 0; resultsI < in.resultsSize; resultsI++) {
		SV *element = newSV(0);
		XS_pack_UA_MonitoredItemCreateResult(element, in.results[resultsI]);
		av_push(resultsArray, element);
	}
	hv_stores(hash, "CreateMonitoredItemsResponse_results", newRV_inc((SV*)resultsArray));

	AV *diagnosticInfosArray = (AV*) sv_2mortal((SV*)newAV());
	size_t diagnosticInfosI;
	for(diagnosticInfosI = 0; diagnosticInfosI < in.diagnosticInfosSize; diagnosticInfosI++) {
		SV *element = newSV(0);
		XS_pack_UA_DiagnosticInfo(element, in.diagnosticInfos[diagnosticInfosI]);
		av_push(diagnosticInfosArray, element);
	}
	hv_stores(hash, "CreateMonitoredItemsResponse_diagnosticInfos", newRV_inc((SV*)diagnosticInfosArray));

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_CreateMonitoredItemsResponse XS_unpack_UA_CreateMonitoredItemsResponse(SV *in)  __attribute__((unused));
static UA_CreateMonitoredItemsResponse
XS_unpack_UA_CreateMonitoredItemsResponse(SV *in)
{
	UA_CreateMonitoredItemsResponse out;
	SV **value;
	HV *hv;

	UA_CreateMonitoredItemsResponse_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "CreateMonitoredItemsResponse_responseHeader", 0);
	if (value != NULL)
		out.responseHeader = XS_unpack_UA_ResponseHeader(*value);

	/* TODO Implement array conversion for field results */

	/* TODO Implement array conversion for field diagnosticInfos */

	return out;
}

/* MonitoredItemModifyRequest */
static void XS_pack_UA_MonitoredItemModifyRequest(SV *out, UA_MonitoredItemModifyRequest in)  __attribute__((unused));
static void
XS_pack_UA_MonitoredItemModifyRequest(SV *out, UA_MonitoredItemModifyRequest in)
{
	HV *hash = newHV();

	SV *monitoredItemIdSV = newSV(0);
	XS_pack_UA_UInt32(monitoredItemIdSV, in.monitoredItemId);
	hv_stores(hash, "MonitoredItemModifyRequest_monitoredItemId", monitoredItemIdSV);

	SV *requestedParametersSV = newSV(0);
	XS_pack_UA_MonitoringParameters(requestedParametersSV, in.requestedParameters);
	hv_stores(hash, "MonitoredItemModifyRequest_requestedParameters", requestedParametersSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_MonitoredItemModifyRequest XS_unpack_UA_MonitoredItemModifyRequest(SV *in)  __attribute__((unused));
static UA_MonitoredItemModifyRequest
XS_unpack_UA_MonitoredItemModifyRequest(SV *in)
{
	UA_MonitoredItemModifyRequest out;
	SV **value;
	HV *hv;

	UA_MonitoredItemModifyRequest_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "MonitoredItemModifyRequest_monitoredItemId", 0);
	if (value != NULL)
		out.monitoredItemId = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "MonitoredItemModifyRequest_requestedParameters", 0);
	if (value != NULL)
		out.requestedParameters = XS_unpack_UA_MonitoringParameters(*value);

	return out;
}

/* MonitoredItemModifyResult */
static void XS_pack_UA_MonitoredItemModifyResult(SV *out, UA_MonitoredItemModifyResult in)  __attribute__((unused));
static void
XS_pack_UA_MonitoredItemModifyResult(SV *out, UA_MonitoredItemModifyResult in)
{
	HV *hash = newHV();

	SV *statusCodeSV = newSV(0);
	XS_pack_UA_StatusCode(statusCodeSV, in.statusCode);
	hv_stores(hash, "MonitoredItemModifyResult_statusCode", statusCodeSV);

	SV *revisedSamplingIntervalSV = newSV(0);
	XS_pack_UA_Double(revisedSamplingIntervalSV, in.revisedSamplingInterval);
	hv_stores(hash, "MonitoredItemModifyResult_revisedSamplingInterval", revisedSamplingIntervalSV);

	SV *revisedQueueSizeSV = newSV(0);
	XS_pack_UA_UInt32(revisedQueueSizeSV, in.revisedQueueSize);
	hv_stores(hash, "MonitoredItemModifyResult_revisedQueueSize", revisedQueueSizeSV);

	SV *filterResultSV = newSV(0);
	XS_pack_UA_ExtensionObject(filterResultSV, in.filterResult);
	hv_stores(hash, "MonitoredItemModifyResult_filterResult", filterResultSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_MonitoredItemModifyResult XS_unpack_UA_MonitoredItemModifyResult(SV *in)  __attribute__((unused));
static UA_MonitoredItemModifyResult
XS_unpack_UA_MonitoredItemModifyResult(SV *in)
{
	UA_MonitoredItemModifyResult out;
	SV **value;
	HV *hv;

	UA_MonitoredItemModifyResult_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "MonitoredItemModifyResult_statusCode", 0);
	if (value != NULL)
		out.statusCode = XS_unpack_UA_StatusCode(*value);

	value = hv_fetchs(hv, "MonitoredItemModifyResult_revisedSamplingInterval", 0);
	if (value != NULL)
		out.revisedSamplingInterval = XS_unpack_UA_Double(*value);

	value = hv_fetchs(hv, "MonitoredItemModifyResult_revisedQueueSize", 0);
	if (value != NULL)
		out.revisedQueueSize = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "MonitoredItemModifyResult_filterResult", 0);
	if (value != NULL)
		out.filterResult = XS_unpack_UA_ExtensionObject(*value);

	return out;
}

/* ModifyMonitoredItemsRequest */
static void XS_pack_UA_ModifyMonitoredItemsRequest(SV *out, UA_ModifyMonitoredItemsRequest in)  __attribute__((unused));
static void
XS_pack_UA_ModifyMonitoredItemsRequest(SV *out, UA_ModifyMonitoredItemsRequest in)
{
	HV *hash = newHV();

	SV *requestHeaderSV = newSV(0);
	XS_pack_UA_RequestHeader(requestHeaderSV, in.requestHeader);
	hv_stores(hash, "ModifyMonitoredItemsRequest_requestHeader", requestHeaderSV);

	SV *subscriptionIdSV = newSV(0);
	XS_pack_UA_UInt32(subscriptionIdSV, in.subscriptionId);
	hv_stores(hash, "ModifyMonitoredItemsRequest_subscriptionId", subscriptionIdSV);

	SV *timestampsToReturnSV = newSV(0);
	XS_pack_UA_TimestampsToReturn(timestampsToReturnSV, in.timestampsToReturn);
	hv_stores(hash, "ModifyMonitoredItemsRequest_timestampsToReturn", timestampsToReturnSV);

	AV *itemsToModifyArray = (AV*) sv_2mortal((SV*)newAV());
	size_t itemsToModifyI;
	for(itemsToModifyI = 0; itemsToModifyI < in.itemsToModifySize; itemsToModifyI++) {
		SV *element = newSV(0);
		XS_pack_UA_MonitoredItemModifyRequest(element, in.itemsToModify[itemsToModifyI]);
		av_push(itemsToModifyArray, element);
	}
	hv_stores(hash, "ModifyMonitoredItemsRequest_itemsToModify", newRV_inc((SV*)itemsToModifyArray));

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_ModifyMonitoredItemsRequest XS_unpack_UA_ModifyMonitoredItemsRequest(SV *in)  __attribute__((unused));
static UA_ModifyMonitoredItemsRequest
XS_unpack_UA_ModifyMonitoredItemsRequest(SV *in)
{
	UA_ModifyMonitoredItemsRequest out;
	SV **value;
	HV *hv;

	UA_ModifyMonitoredItemsRequest_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "ModifyMonitoredItemsRequest_requestHeader", 0);
	if (value != NULL)
		out.requestHeader = XS_unpack_UA_RequestHeader(*value);

	value = hv_fetchs(hv, "ModifyMonitoredItemsRequest_subscriptionId", 0);
	if (value != NULL)
		out.subscriptionId = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "ModifyMonitoredItemsRequest_timestampsToReturn", 0);
	if (value != NULL)
		out.timestampsToReturn = XS_unpack_UA_TimestampsToReturn(*value);

	/* TODO Implement array conversion for field itemsToModify */

	return out;
}

/* ModifyMonitoredItemsResponse */
static void XS_pack_UA_ModifyMonitoredItemsResponse(SV *out, UA_ModifyMonitoredItemsResponse in)  __attribute__((unused));
static void
XS_pack_UA_ModifyMonitoredItemsResponse(SV *out, UA_ModifyMonitoredItemsResponse in)
{
	HV *hash = newHV();

	SV *responseHeaderSV = newSV(0);
	XS_pack_UA_ResponseHeader(responseHeaderSV, in.responseHeader);
	hv_stores(hash, "ModifyMonitoredItemsResponse_responseHeader", responseHeaderSV);

	AV *resultsArray = (AV*) sv_2mortal((SV*)newAV());
	size_t resultsI;
	for(resultsI = 0; resultsI < in.resultsSize; resultsI++) {
		SV *element = newSV(0);
		XS_pack_UA_MonitoredItemModifyResult(element, in.results[resultsI]);
		av_push(resultsArray, element);
	}
	hv_stores(hash, "ModifyMonitoredItemsResponse_results", newRV_inc((SV*)resultsArray));

	AV *diagnosticInfosArray = (AV*) sv_2mortal((SV*)newAV());
	size_t diagnosticInfosI;
	for(diagnosticInfosI = 0; diagnosticInfosI < in.diagnosticInfosSize; diagnosticInfosI++) {
		SV *element = newSV(0);
		XS_pack_UA_DiagnosticInfo(element, in.diagnosticInfos[diagnosticInfosI]);
		av_push(diagnosticInfosArray, element);
	}
	hv_stores(hash, "ModifyMonitoredItemsResponse_diagnosticInfos", newRV_inc((SV*)diagnosticInfosArray));

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_ModifyMonitoredItemsResponse XS_unpack_UA_ModifyMonitoredItemsResponse(SV *in)  __attribute__((unused));
static UA_ModifyMonitoredItemsResponse
XS_unpack_UA_ModifyMonitoredItemsResponse(SV *in)
{
	UA_ModifyMonitoredItemsResponse out;
	SV **value;
	HV *hv;

	UA_ModifyMonitoredItemsResponse_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "ModifyMonitoredItemsResponse_responseHeader", 0);
	if (value != NULL)
		out.responseHeader = XS_unpack_UA_ResponseHeader(*value);

	/* TODO Implement array conversion for field results */

	/* TODO Implement array conversion for field diagnosticInfos */

	return out;
}

/* SetMonitoringModeRequest */
static void XS_pack_UA_SetMonitoringModeRequest(SV *out, UA_SetMonitoringModeRequest in)  __attribute__((unused));
static void
XS_pack_UA_SetMonitoringModeRequest(SV *out, UA_SetMonitoringModeRequest in)
{
	HV *hash = newHV();

	SV *requestHeaderSV = newSV(0);
	XS_pack_UA_RequestHeader(requestHeaderSV, in.requestHeader);
	hv_stores(hash, "SetMonitoringModeRequest_requestHeader", requestHeaderSV);

	SV *subscriptionIdSV = newSV(0);
	XS_pack_UA_UInt32(subscriptionIdSV, in.subscriptionId);
	hv_stores(hash, "SetMonitoringModeRequest_subscriptionId", subscriptionIdSV);

	SV *monitoringModeSV = newSV(0);
	XS_pack_UA_MonitoringMode(monitoringModeSV, in.monitoringMode);
	hv_stores(hash, "SetMonitoringModeRequest_monitoringMode", monitoringModeSV);

	AV *monitoredItemIdsArray = (AV*) sv_2mortal((SV*)newAV());
	size_t monitoredItemIdsI;
	for(monitoredItemIdsI = 0; monitoredItemIdsI < in.monitoredItemIdsSize; monitoredItemIdsI++) {
		SV *element = newSV(0);
		XS_pack_UA_UInt32(element, in.monitoredItemIds[monitoredItemIdsI]);
		av_push(monitoredItemIdsArray, element);
	}
	hv_stores(hash, "SetMonitoringModeRequest_monitoredItemIds", newRV_inc((SV*)monitoredItemIdsArray));

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_SetMonitoringModeRequest XS_unpack_UA_SetMonitoringModeRequest(SV *in)  __attribute__((unused));
static UA_SetMonitoringModeRequest
XS_unpack_UA_SetMonitoringModeRequest(SV *in)
{
	UA_SetMonitoringModeRequest out;
	SV **value;
	HV *hv;

	UA_SetMonitoringModeRequest_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "SetMonitoringModeRequest_requestHeader", 0);
	if (value != NULL)
		out.requestHeader = XS_unpack_UA_RequestHeader(*value);

	value = hv_fetchs(hv, "SetMonitoringModeRequest_subscriptionId", 0);
	if (value != NULL)
		out.subscriptionId = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "SetMonitoringModeRequest_monitoringMode", 0);
	if (value != NULL)
		out.monitoringMode = XS_unpack_UA_MonitoringMode(*value);

	/* TODO Implement array conversion for field monitoredItemIds */

	return out;
}

/* SetMonitoringModeResponse */
static void XS_pack_UA_SetMonitoringModeResponse(SV *out, UA_SetMonitoringModeResponse in)  __attribute__((unused));
static void
XS_pack_UA_SetMonitoringModeResponse(SV *out, UA_SetMonitoringModeResponse in)
{
	HV *hash = newHV();

	SV *responseHeaderSV = newSV(0);
	XS_pack_UA_ResponseHeader(responseHeaderSV, in.responseHeader);
	hv_stores(hash, "SetMonitoringModeResponse_responseHeader", responseHeaderSV);

	AV *resultsArray = (AV*) sv_2mortal((SV*)newAV());
	size_t resultsI;
	for(resultsI = 0; resultsI < in.resultsSize; resultsI++) {
		SV *element = newSV(0);
		XS_pack_UA_StatusCode(element, in.results[resultsI]);
		av_push(resultsArray, element);
	}
	hv_stores(hash, "SetMonitoringModeResponse_results", newRV_inc((SV*)resultsArray));

	AV *diagnosticInfosArray = (AV*) sv_2mortal((SV*)newAV());
	size_t diagnosticInfosI;
	for(diagnosticInfosI = 0; diagnosticInfosI < in.diagnosticInfosSize; diagnosticInfosI++) {
		SV *element = newSV(0);
		XS_pack_UA_DiagnosticInfo(element, in.diagnosticInfos[diagnosticInfosI]);
		av_push(diagnosticInfosArray, element);
	}
	hv_stores(hash, "SetMonitoringModeResponse_diagnosticInfos", newRV_inc((SV*)diagnosticInfosArray));

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_SetMonitoringModeResponse XS_unpack_UA_SetMonitoringModeResponse(SV *in)  __attribute__((unused));
static UA_SetMonitoringModeResponse
XS_unpack_UA_SetMonitoringModeResponse(SV *in)
{
	UA_SetMonitoringModeResponse out;
	SV **value;
	HV *hv;

	UA_SetMonitoringModeResponse_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "SetMonitoringModeResponse_responseHeader", 0);
	if (value != NULL)
		out.responseHeader = XS_unpack_UA_ResponseHeader(*value);

	/* TODO Implement array conversion for field results */

	/* TODO Implement array conversion for field diagnosticInfos */

	return out;
}

/* SetTriggeringRequest */
static void XS_pack_UA_SetTriggeringRequest(SV *out, UA_SetTriggeringRequest in)  __attribute__((unused));
static void
XS_pack_UA_SetTriggeringRequest(SV *out, UA_SetTriggeringRequest in)
{
	HV *hash = newHV();

	SV *requestHeaderSV = newSV(0);
	XS_pack_UA_RequestHeader(requestHeaderSV, in.requestHeader);
	hv_stores(hash, "SetTriggeringRequest_requestHeader", requestHeaderSV);

	SV *subscriptionIdSV = newSV(0);
	XS_pack_UA_UInt32(subscriptionIdSV, in.subscriptionId);
	hv_stores(hash, "SetTriggeringRequest_subscriptionId", subscriptionIdSV);

	SV *triggeringItemIdSV = newSV(0);
	XS_pack_UA_UInt32(triggeringItemIdSV, in.triggeringItemId);
	hv_stores(hash, "SetTriggeringRequest_triggeringItemId", triggeringItemIdSV);

	AV *linksToAddArray = (AV*) sv_2mortal((SV*)newAV());
	size_t linksToAddI;
	for(linksToAddI = 0; linksToAddI < in.linksToAddSize; linksToAddI++) {
		SV *element = newSV(0);
		XS_pack_UA_UInt32(element, in.linksToAdd[linksToAddI]);
		av_push(linksToAddArray, element);
	}
	hv_stores(hash, "SetTriggeringRequest_linksToAdd", newRV_inc((SV*)linksToAddArray));

	AV *linksToRemoveArray = (AV*) sv_2mortal((SV*)newAV());
	size_t linksToRemoveI;
	for(linksToRemoveI = 0; linksToRemoveI < in.linksToRemoveSize; linksToRemoveI++) {
		SV *element = newSV(0);
		XS_pack_UA_UInt32(element, in.linksToRemove[linksToRemoveI]);
		av_push(linksToRemoveArray, element);
	}
	hv_stores(hash, "SetTriggeringRequest_linksToRemove", newRV_inc((SV*)linksToRemoveArray));

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_SetTriggeringRequest XS_unpack_UA_SetTriggeringRequest(SV *in)  __attribute__((unused));
static UA_SetTriggeringRequest
XS_unpack_UA_SetTriggeringRequest(SV *in)
{
	UA_SetTriggeringRequest out;
	SV **value;
	HV *hv;

	UA_SetTriggeringRequest_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "SetTriggeringRequest_requestHeader", 0);
	if (value != NULL)
		out.requestHeader = XS_unpack_UA_RequestHeader(*value);

	value = hv_fetchs(hv, "SetTriggeringRequest_subscriptionId", 0);
	if (value != NULL)
		out.subscriptionId = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "SetTriggeringRequest_triggeringItemId", 0);
	if (value != NULL)
		out.triggeringItemId = XS_unpack_UA_UInt32(*value);

	/* TODO Implement array conversion for field linksToAdd */

	/* TODO Implement array conversion for field linksToRemove */

	return out;
}

/* SetTriggeringResponse */
static void XS_pack_UA_SetTriggeringResponse(SV *out, UA_SetTriggeringResponse in)  __attribute__((unused));
static void
XS_pack_UA_SetTriggeringResponse(SV *out, UA_SetTriggeringResponse in)
{
	HV *hash = newHV();

	SV *responseHeaderSV = newSV(0);
	XS_pack_UA_ResponseHeader(responseHeaderSV, in.responseHeader);
	hv_stores(hash, "SetTriggeringResponse_responseHeader", responseHeaderSV);

	AV *addResultsArray = (AV*) sv_2mortal((SV*)newAV());
	size_t addResultsI;
	for(addResultsI = 0; addResultsI < in.addResultsSize; addResultsI++) {
		SV *element = newSV(0);
		XS_pack_UA_StatusCode(element, in.addResults[addResultsI]);
		av_push(addResultsArray, element);
	}
	hv_stores(hash, "SetTriggeringResponse_addResults", newRV_inc((SV*)addResultsArray));

	AV *addDiagnosticInfosArray = (AV*) sv_2mortal((SV*)newAV());
	size_t addDiagnosticInfosI;
	for(addDiagnosticInfosI = 0; addDiagnosticInfosI < in.addDiagnosticInfosSize; addDiagnosticInfosI++) {
		SV *element = newSV(0);
		XS_pack_UA_DiagnosticInfo(element, in.addDiagnosticInfos[addDiagnosticInfosI]);
		av_push(addDiagnosticInfosArray, element);
	}
	hv_stores(hash, "SetTriggeringResponse_addDiagnosticInfos", newRV_inc((SV*)addDiagnosticInfosArray));

	AV *removeResultsArray = (AV*) sv_2mortal((SV*)newAV());
	size_t removeResultsI;
	for(removeResultsI = 0; removeResultsI < in.removeResultsSize; removeResultsI++) {
		SV *element = newSV(0);
		XS_pack_UA_StatusCode(element, in.removeResults[removeResultsI]);
		av_push(removeResultsArray, element);
	}
	hv_stores(hash, "SetTriggeringResponse_removeResults", newRV_inc((SV*)removeResultsArray));

	AV *removeDiagnosticInfosArray = (AV*) sv_2mortal((SV*)newAV());
	size_t removeDiagnosticInfosI;
	for(removeDiagnosticInfosI = 0; removeDiagnosticInfosI < in.removeDiagnosticInfosSize; removeDiagnosticInfosI++) {
		SV *element = newSV(0);
		XS_pack_UA_DiagnosticInfo(element, in.removeDiagnosticInfos[removeDiagnosticInfosI]);
		av_push(removeDiagnosticInfosArray, element);
	}
	hv_stores(hash, "SetTriggeringResponse_removeDiagnosticInfos", newRV_inc((SV*)removeDiagnosticInfosArray));

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_SetTriggeringResponse XS_unpack_UA_SetTriggeringResponse(SV *in)  __attribute__((unused));
static UA_SetTriggeringResponse
XS_unpack_UA_SetTriggeringResponse(SV *in)
{
	UA_SetTriggeringResponse out;
	SV **value;
	HV *hv;

	UA_SetTriggeringResponse_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "SetTriggeringResponse_responseHeader", 0);
	if (value != NULL)
		out.responseHeader = XS_unpack_UA_ResponseHeader(*value);

	/* TODO Implement array conversion for field addResults */

	/* TODO Implement array conversion for field addDiagnosticInfos */

	/* TODO Implement array conversion for field removeResults */

	/* TODO Implement array conversion for field removeDiagnosticInfos */

	return out;
}

/* DeleteMonitoredItemsRequest */
static void XS_pack_UA_DeleteMonitoredItemsRequest(SV *out, UA_DeleteMonitoredItemsRequest in)  __attribute__((unused));
static void
XS_pack_UA_DeleteMonitoredItemsRequest(SV *out, UA_DeleteMonitoredItemsRequest in)
{
	HV *hash = newHV();

	SV *requestHeaderSV = newSV(0);
	XS_pack_UA_RequestHeader(requestHeaderSV, in.requestHeader);
	hv_stores(hash, "DeleteMonitoredItemsRequest_requestHeader", requestHeaderSV);

	SV *subscriptionIdSV = newSV(0);
	XS_pack_UA_UInt32(subscriptionIdSV, in.subscriptionId);
	hv_stores(hash, "DeleteMonitoredItemsRequest_subscriptionId", subscriptionIdSV);

	AV *monitoredItemIdsArray = (AV*) sv_2mortal((SV*)newAV());
	size_t monitoredItemIdsI;
	for(monitoredItemIdsI = 0; monitoredItemIdsI < in.monitoredItemIdsSize; monitoredItemIdsI++) {
		SV *element = newSV(0);
		XS_pack_UA_UInt32(element, in.monitoredItemIds[monitoredItemIdsI]);
		av_push(monitoredItemIdsArray, element);
	}
	hv_stores(hash, "DeleteMonitoredItemsRequest_monitoredItemIds", newRV_inc((SV*)monitoredItemIdsArray));

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_DeleteMonitoredItemsRequest XS_unpack_UA_DeleteMonitoredItemsRequest(SV *in)  __attribute__((unused));
static UA_DeleteMonitoredItemsRequest
XS_unpack_UA_DeleteMonitoredItemsRequest(SV *in)
{
	UA_DeleteMonitoredItemsRequest out;
	SV **value;
	HV *hv;

	UA_DeleteMonitoredItemsRequest_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "DeleteMonitoredItemsRequest_requestHeader", 0);
	if (value != NULL)
		out.requestHeader = XS_unpack_UA_RequestHeader(*value);

	value = hv_fetchs(hv, "DeleteMonitoredItemsRequest_subscriptionId", 0);
	if (value != NULL)
		out.subscriptionId = XS_unpack_UA_UInt32(*value);

	/* TODO Implement array conversion for field monitoredItemIds */

	return out;
}

/* DeleteMonitoredItemsResponse */
static void XS_pack_UA_DeleteMonitoredItemsResponse(SV *out, UA_DeleteMonitoredItemsResponse in)  __attribute__((unused));
static void
XS_pack_UA_DeleteMonitoredItemsResponse(SV *out, UA_DeleteMonitoredItemsResponse in)
{
	HV *hash = newHV();

	SV *responseHeaderSV = newSV(0);
	XS_pack_UA_ResponseHeader(responseHeaderSV, in.responseHeader);
	hv_stores(hash, "DeleteMonitoredItemsResponse_responseHeader", responseHeaderSV);

	AV *resultsArray = (AV*) sv_2mortal((SV*)newAV());
	size_t resultsI;
	for(resultsI = 0; resultsI < in.resultsSize; resultsI++) {
		SV *element = newSV(0);
		XS_pack_UA_StatusCode(element, in.results[resultsI]);
		av_push(resultsArray, element);
	}
	hv_stores(hash, "DeleteMonitoredItemsResponse_results", newRV_inc((SV*)resultsArray));

	AV *diagnosticInfosArray = (AV*) sv_2mortal((SV*)newAV());
	size_t diagnosticInfosI;
	for(diagnosticInfosI = 0; diagnosticInfosI < in.diagnosticInfosSize; diagnosticInfosI++) {
		SV *element = newSV(0);
		XS_pack_UA_DiagnosticInfo(element, in.diagnosticInfos[diagnosticInfosI]);
		av_push(diagnosticInfosArray, element);
	}
	hv_stores(hash, "DeleteMonitoredItemsResponse_diagnosticInfos", newRV_inc((SV*)diagnosticInfosArray));

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_DeleteMonitoredItemsResponse XS_unpack_UA_DeleteMonitoredItemsResponse(SV *in)  __attribute__((unused));
static UA_DeleteMonitoredItemsResponse
XS_unpack_UA_DeleteMonitoredItemsResponse(SV *in)
{
	UA_DeleteMonitoredItemsResponse out;
	SV **value;
	HV *hv;

	UA_DeleteMonitoredItemsResponse_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "DeleteMonitoredItemsResponse_responseHeader", 0);
	if (value != NULL)
		out.responseHeader = XS_unpack_UA_ResponseHeader(*value);

	/* TODO Implement array conversion for field results */

	/* TODO Implement array conversion for field diagnosticInfos */

	return out;
}

/* CreateSubscriptionRequest */
static void XS_pack_UA_CreateSubscriptionRequest(SV *out, UA_CreateSubscriptionRequest in)  __attribute__((unused));
static void
XS_pack_UA_CreateSubscriptionRequest(SV *out, UA_CreateSubscriptionRequest in)
{
	HV *hash = newHV();

	SV *requestHeaderSV = newSV(0);
	XS_pack_UA_RequestHeader(requestHeaderSV, in.requestHeader);
	hv_stores(hash, "CreateSubscriptionRequest_requestHeader", requestHeaderSV);

	SV *requestedPublishingIntervalSV = newSV(0);
	XS_pack_UA_Double(requestedPublishingIntervalSV, in.requestedPublishingInterval);
	hv_stores(hash, "CreateSubscriptionRequest_requestedPublishingInterval", requestedPublishingIntervalSV);

	SV *requestedLifetimeCountSV = newSV(0);
	XS_pack_UA_UInt32(requestedLifetimeCountSV, in.requestedLifetimeCount);
	hv_stores(hash, "CreateSubscriptionRequest_requestedLifetimeCount", requestedLifetimeCountSV);

	SV *requestedMaxKeepAliveCountSV = newSV(0);
	XS_pack_UA_UInt32(requestedMaxKeepAliveCountSV, in.requestedMaxKeepAliveCount);
	hv_stores(hash, "CreateSubscriptionRequest_requestedMaxKeepAliveCount", requestedMaxKeepAliveCountSV);

	SV *maxNotificationsPerPublishSV = newSV(0);
	XS_pack_UA_UInt32(maxNotificationsPerPublishSV, in.maxNotificationsPerPublish);
	hv_stores(hash, "CreateSubscriptionRequest_maxNotificationsPerPublish", maxNotificationsPerPublishSV);

	SV *publishingEnabledSV = newSV(0);
	XS_pack_UA_Boolean(publishingEnabledSV, in.publishingEnabled);
	hv_stores(hash, "CreateSubscriptionRequest_publishingEnabled", publishingEnabledSV);

	SV *prioritySV = newSV(0);
	XS_pack_UA_Byte(prioritySV, in.priority);
	hv_stores(hash, "CreateSubscriptionRequest_priority", prioritySV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_CreateSubscriptionRequest XS_unpack_UA_CreateSubscriptionRequest(SV *in)  __attribute__((unused));
static UA_CreateSubscriptionRequest
XS_unpack_UA_CreateSubscriptionRequest(SV *in)
{
	UA_CreateSubscriptionRequest out;
	SV **value;
	HV *hv;

	UA_CreateSubscriptionRequest_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "CreateSubscriptionRequest_requestHeader", 0);
	if (value != NULL)
		out.requestHeader = XS_unpack_UA_RequestHeader(*value);

	value = hv_fetchs(hv, "CreateSubscriptionRequest_requestedPublishingInterval", 0);
	if (value != NULL)
		out.requestedPublishingInterval = XS_unpack_UA_Double(*value);

	value = hv_fetchs(hv, "CreateSubscriptionRequest_requestedLifetimeCount", 0);
	if (value != NULL)
		out.requestedLifetimeCount = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "CreateSubscriptionRequest_requestedMaxKeepAliveCount", 0);
	if (value != NULL)
		out.requestedMaxKeepAliveCount = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "CreateSubscriptionRequest_maxNotificationsPerPublish", 0);
	if (value != NULL)
		out.maxNotificationsPerPublish = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "CreateSubscriptionRequest_publishingEnabled", 0);
	if (value != NULL)
		out.publishingEnabled = XS_unpack_UA_Boolean(*value);

	value = hv_fetchs(hv, "CreateSubscriptionRequest_priority", 0);
	if (value != NULL)
		out.priority = XS_unpack_UA_Byte(*value);

	return out;
}

/* CreateSubscriptionResponse */
static void XS_pack_UA_CreateSubscriptionResponse(SV *out, UA_CreateSubscriptionResponse in)  __attribute__((unused));
static void
XS_pack_UA_CreateSubscriptionResponse(SV *out, UA_CreateSubscriptionResponse in)
{
	HV *hash = newHV();

	SV *responseHeaderSV = newSV(0);
	XS_pack_UA_ResponseHeader(responseHeaderSV, in.responseHeader);
	hv_stores(hash, "CreateSubscriptionResponse_responseHeader", responseHeaderSV);

	SV *subscriptionIdSV = newSV(0);
	XS_pack_UA_UInt32(subscriptionIdSV, in.subscriptionId);
	hv_stores(hash, "CreateSubscriptionResponse_subscriptionId", subscriptionIdSV);

	SV *revisedPublishingIntervalSV = newSV(0);
	XS_pack_UA_Double(revisedPublishingIntervalSV, in.revisedPublishingInterval);
	hv_stores(hash, "CreateSubscriptionResponse_revisedPublishingInterval", revisedPublishingIntervalSV);

	SV *revisedLifetimeCountSV = newSV(0);
	XS_pack_UA_UInt32(revisedLifetimeCountSV, in.revisedLifetimeCount);
	hv_stores(hash, "CreateSubscriptionResponse_revisedLifetimeCount", revisedLifetimeCountSV);

	SV *revisedMaxKeepAliveCountSV = newSV(0);
	XS_pack_UA_UInt32(revisedMaxKeepAliveCountSV, in.revisedMaxKeepAliveCount);
	hv_stores(hash, "CreateSubscriptionResponse_revisedMaxKeepAliveCount", revisedMaxKeepAliveCountSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_CreateSubscriptionResponse XS_unpack_UA_CreateSubscriptionResponse(SV *in)  __attribute__((unused));
static UA_CreateSubscriptionResponse
XS_unpack_UA_CreateSubscriptionResponse(SV *in)
{
	UA_CreateSubscriptionResponse out;
	SV **value;
	HV *hv;

	UA_CreateSubscriptionResponse_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "CreateSubscriptionResponse_responseHeader", 0);
	if (value != NULL)
		out.responseHeader = XS_unpack_UA_ResponseHeader(*value);

	value = hv_fetchs(hv, "CreateSubscriptionResponse_subscriptionId", 0);
	if (value != NULL)
		out.subscriptionId = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "CreateSubscriptionResponse_revisedPublishingInterval", 0);
	if (value != NULL)
		out.revisedPublishingInterval = XS_unpack_UA_Double(*value);

	value = hv_fetchs(hv, "CreateSubscriptionResponse_revisedLifetimeCount", 0);
	if (value != NULL)
		out.revisedLifetimeCount = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "CreateSubscriptionResponse_revisedMaxKeepAliveCount", 0);
	if (value != NULL)
		out.revisedMaxKeepAliveCount = XS_unpack_UA_UInt32(*value);

	return out;
}

/* ModifySubscriptionRequest */
static void XS_pack_UA_ModifySubscriptionRequest(SV *out, UA_ModifySubscriptionRequest in)  __attribute__((unused));
static void
XS_pack_UA_ModifySubscriptionRequest(SV *out, UA_ModifySubscriptionRequest in)
{
	HV *hash = newHV();

	SV *requestHeaderSV = newSV(0);
	XS_pack_UA_RequestHeader(requestHeaderSV, in.requestHeader);
	hv_stores(hash, "ModifySubscriptionRequest_requestHeader", requestHeaderSV);

	SV *subscriptionIdSV = newSV(0);
	XS_pack_UA_UInt32(subscriptionIdSV, in.subscriptionId);
	hv_stores(hash, "ModifySubscriptionRequest_subscriptionId", subscriptionIdSV);

	SV *requestedPublishingIntervalSV = newSV(0);
	XS_pack_UA_Double(requestedPublishingIntervalSV, in.requestedPublishingInterval);
	hv_stores(hash, "ModifySubscriptionRequest_requestedPublishingInterval", requestedPublishingIntervalSV);

	SV *requestedLifetimeCountSV = newSV(0);
	XS_pack_UA_UInt32(requestedLifetimeCountSV, in.requestedLifetimeCount);
	hv_stores(hash, "ModifySubscriptionRequest_requestedLifetimeCount", requestedLifetimeCountSV);

	SV *requestedMaxKeepAliveCountSV = newSV(0);
	XS_pack_UA_UInt32(requestedMaxKeepAliveCountSV, in.requestedMaxKeepAliveCount);
	hv_stores(hash, "ModifySubscriptionRequest_requestedMaxKeepAliveCount", requestedMaxKeepAliveCountSV);

	SV *maxNotificationsPerPublishSV = newSV(0);
	XS_pack_UA_UInt32(maxNotificationsPerPublishSV, in.maxNotificationsPerPublish);
	hv_stores(hash, "ModifySubscriptionRequest_maxNotificationsPerPublish", maxNotificationsPerPublishSV);

	SV *prioritySV = newSV(0);
	XS_pack_UA_Byte(prioritySV, in.priority);
	hv_stores(hash, "ModifySubscriptionRequest_priority", prioritySV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_ModifySubscriptionRequest XS_unpack_UA_ModifySubscriptionRequest(SV *in)  __attribute__((unused));
static UA_ModifySubscriptionRequest
XS_unpack_UA_ModifySubscriptionRequest(SV *in)
{
	UA_ModifySubscriptionRequest out;
	SV **value;
	HV *hv;

	UA_ModifySubscriptionRequest_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "ModifySubscriptionRequest_requestHeader", 0);
	if (value != NULL)
		out.requestHeader = XS_unpack_UA_RequestHeader(*value);

	value = hv_fetchs(hv, "ModifySubscriptionRequest_subscriptionId", 0);
	if (value != NULL)
		out.subscriptionId = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "ModifySubscriptionRequest_requestedPublishingInterval", 0);
	if (value != NULL)
		out.requestedPublishingInterval = XS_unpack_UA_Double(*value);

	value = hv_fetchs(hv, "ModifySubscriptionRequest_requestedLifetimeCount", 0);
	if (value != NULL)
		out.requestedLifetimeCount = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "ModifySubscriptionRequest_requestedMaxKeepAliveCount", 0);
	if (value != NULL)
		out.requestedMaxKeepAliveCount = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "ModifySubscriptionRequest_maxNotificationsPerPublish", 0);
	if (value != NULL)
		out.maxNotificationsPerPublish = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "ModifySubscriptionRequest_priority", 0);
	if (value != NULL)
		out.priority = XS_unpack_UA_Byte(*value);

	return out;
}

/* ModifySubscriptionResponse */
static void XS_pack_UA_ModifySubscriptionResponse(SV *out, UA_ModifySubscriptionResponse in)  __attribute__((unused));
static void
XS_pack_UA_ModifySubscriptionResponse(SV *out, UA_ModifySubscriptionResponse in)
{
	HV *hash = newHV();

	SV *responseHeaderSV = newSV(0);
	XS_pack_UA_ResponseHeader(responseHeaderSV, in.responseHeader);
	hv_stores(hash, "ModifySubscriptionResponse_responseHeader", responseHeaderSV);

	SV *revisedPublishingIntervalSV = newSV(0);
	XS_pack_UA_Double(revisedPublishingIntervalSV, in.revisedPublishingInterval);
	hv_stores(hash, "ModifySubscriptionResponse_revisedPublishingInterval", revisedPublishingIntervalSV);

	SV *revisedLifetimeCountSV = newSV(0);
	XS_pack_UA_UInt32(revisedLifetimeCountSV, in.revisedLifetimeCount);
	hv_stores(hash, "ModifySubscriptionResponse_revisedLifetimeCount", revisedLifetimeCountSV);

	SV *revisedMaxKeepAliveCountSV = newSV(0);
	XS_pack_UA_UInt32(revisedMaxKeepAliveCountSV, in.revisedMaxKeepAliveCount);
	hv_stores(hash, "ModifySubscriptionResponse_revisedMaxKeepAliveCount", revisedMaxKeepAliveCountSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_ModifySubscriptionResponse XS_unpack_UA_ModifySubscriptionResponse(SV *in)  __attribute__((unused));
static UA_ModifySubscriptionResponse
XS_unpack_UA_ModifySubscriptionResponse(SV *in)
{
	UA_ModifySubscriptionResponse out;
	SV **value;
	HV *hv;

	UA_ModifySubscriptionResponse_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "ModifySubscriptionResponse_responseHeader", 0);
	if (value != NULL)
		out.responseHeader = XS_unpack_UA_ResponseHeader(*value);

	value = hv_fetchs(hv, "ModifySubscriptionResponse_revisedPublishingInterval", 0);
	if (value != NULL)
		out.revisedPublishingInterval = XS_unpack_UA_Double(*value);

	value = hv_fetchs(hv, "ModifySubscriptionResponse_revisedLifetimeCount", 0);
	if (value != NULL)
		out.revisedLifetimeCount = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "ModifySubscriptionResponse_revisedMaxKeepAliveCount", 0);
	if (value != NULL)
		out.revisedMaxKeepAliveCount = XS_unpack_UA_UInt32(*value);

	return out;
}

/* SetPublishingModeRequest */
static void XS_pack_UA_SetPublishingModeRequest(SV *out, UA_SetPublishingModeRequest in)  __attribute__((unused));
static void
XS_pack_UA_SetPublishingModeRequest(SV *out, UA_SetPublishingModeRequest in)
{
	HV *hash = newHV();

	SV *requestHeaderSV = newSV(0);
	XS_pack_UA_RequestHeader(requestHeaderSV, in.requestHeader);
	hv_stores(hash, "SetPublishingModeRequest_requestHeader", requestHeaderSV);

	SV *publishingEnabledSV = newSV(0);
	XS_pack_UA_Boolean(publishingEnabledSV, in.publishingEnabled);
	hv_stores(hash, "SetPublishingModeRequest_publishingEnabled", publishingEnabledSV);

	AV *subscriptionIdsArray = (AV*) sv_2mortal((SV*)newAV());
	size_t subscriptionIdsI;
	for(subscriptionIdsI = 0; subscriptionIdsI < in.subscriptionIdsSize; subscriptionIdsI++) {
		SV *element = newSV(0);
		XS_pack_UA_UInt32(element, in.subscriptionIds[subscriptionIdsI]);
		av_push(subscriptionIdsArray, element);
	}
	hv_stores(hash, "SetPublishingModeRequest_subscriptionIds", newRV_inc((SV*)subscriptionIdsArray));

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_SetPublishingModeRequest XS_unpack_UA_SetPublishingModeRequest(SV *in)  __attribute__((unused));
static UA_SetPublishingModeRequest
XS_unpack_UA_SetPublishingModeRequest(SV *in)
{
	UA_SetPublishingModeRequest out;
	SV **value;
	HV *hv;

	UA_SetPublishingModeRequest_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "SetPublishingModeRequest_requestHeader", 0);
	if (value != NULL)
		out.requestHeader = XS_unpack_UA_RequestHeader(*value);

	value = hv_fetchs(hv, "SetPublishingModeRequest_publishingEnabled", 0);
	if (value != NULL)
		out.publishingEnabled = XS_unpack_UA_Boolean(*value);

	/* TODO Implement array conversion for field subscriptionIds */

	return out;
}

/* SetPublishingModeResponse */
static void XS_pack_UA_SetPublishingModeResponse(SV *out, UA_SetPublishingModeResponse in)  __attribute__((unused));
static void
XS_pack_UA_SetPublishingModeResponse(SV *out, UA_SetPublishingModeResponse in)
{
	HV *hash = newHV();

	SV *responseHeaderSV = newSV(0);
	XS_pack_UA_ResponseHeader(responseHeaderSV, in.responseHeader);
	hv_stores(hash, "SetPublishingModeResponse_responseHeader", responseHeaderSV);

	AV *resultsArray = (AV*) sv_2mortal((SV*)newAV());
	size_t resultsI;
	for(resultsI = 0; resultsI < in.resultsSize; resultsI++) {
		SV *element = newSV(0);
		XS_pack_UA_StatusCode(element, in.results[resultsI]);
		av_push(resultsArray, element);
	}
	hv_stores(hash, "SetPublishingModeResponse_results", newRV_inc((SV*)resultsArray));

	AV *diagnosticInfosArray = (AV*) sv_2mortal((SV*)newAV());
	size_t diagnosticInfosI;
	for(diagnosticInfosI = 0; diagnosticInfosI < in.diagnosticInfosSize; diagnosticInfosI++) {
		SV *element = newSV(0);
		XS_pack_UA_DiagnosticInfo(element, in.diagnosticInfos[diagnosticInfosI]);
		av_push(diagnosticInfosArray, element);
	}
	hv_stores(hash, "SetPublishingModeResponse_diagnosticInfos", newRV_inc((SV*)diagnosticInfosArray));

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_SetPublishingModeResponse XS_unpack_UA_SetPublishingModeResponse(SV *in)  __attribute__((unused));
static UA_SetPublishingModeResponse
XS_unpack_UA_SetPublishingModeResponse(SV *in)
{
	UA_SetPublishingModeResponse out;
	SV **value;
	HV *hv;

	UA_SetPublishingModeResponse_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "SetPublishingModeResponse_responseHeader", 0);
	if (value != NULL)
		out.responseHeader = XS_unpack_UA_ResponseHeader(*value);

	/* TODO Implement array conversion for field results */

	/* TODO Implement array conversion for field diagnosticInfos */

	return out;
}

/* NotificationMessage */
static void XS_pack_UA_NotificationMessage(SV *out, UA_NotificationMessage in)  __attribute__((unused));
static void
XS_pack_UA_NotificationMessage(SV *out, UA_NotificationMessage in)
{
	HV *hash = newHV();

	SV *sequenceNumberSV = newSV(0);
	XS_pack_UA_UInt32(sequenceNumberSV, in.sequenceNumber);
	hv_stores(hash, "NotificationMessage_sequenceNumber", sequenceNumberSV);

	SV *publishTimeSV = newSV(0);
	XS_pack_UA_DateTime(publishTimeSV, in.publishTime);
	hv_stores(hash, "NotificationMessage_publishTime", publishTimeSV);

	AV *notificationDataArray = (AV*) sv_2mortal((SV*)newAV());
	size_t notificationDataI;
	for(notificationDataI = 0; notificationDataI < in.notificationDataSize; notificationDataI++) {
		SV *element = newSV(0);
		XS_pack_UA_ExtensionObject(element, in.notificationData[notificationDataI]);
		av_push(notificationDataArray, element);
	}
	hv_stores(hash, "NotificationMessage_notificationData", newRV_inc((SV*)notificationDataArray));

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_NotificationMessage XS_unpack_UA_NotificationMessage(SV *in)  __attribute__((unused));
static UA_NotificationMessage
XS_unpack_UA_NotificationMessage(SV *in)
{
	UA_NotificationMessage out;
	SV **value;
	HV *hv;

	UA_NotificationMessage_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "NotificationMessage_sequenceNumber", 0);
	if (value != NULL)
		out.sequenceNumber = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "NotificationMessage_publishTime", 0);
	if (value != NULL)
		out.publishTime = XS_unpack_UA_DateTime(*value);

	/* TODO Implement array conversion for field notificationData */

	return out;
}

/* MonitoredItemNotification */
static void XS_pack_UA_MonitoredItemNotification(SV *out, UA_MonitoredItemNotification in)  __attribute__((unused));
static void
XS_pack_UA_MonitoredItemNotification(SV *out, UA_MonitoredItemNotification in)
{
	HV *hash = newHV();

	SV *clientHandleSV = newSV(0);
	XS_pack_UA_UInt32(clientHandleSV, in.clientHandle);
	hv_stores(hash, "MonitoredItemNotification_clientHandle", clientHandleSV);

	SV *valueSV = newSV(0);
	XS_pack_UA_DataValue(valueSV, in.value);
	hv_stores(hash, "MonitoredItemNotification_value", valueSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_MonitoredItemNotification XS_unpack_UA_MonitoredItemNotification(SV *in)  __attribute__((unused));
static UA_MonitoredItemNotification
XS_unpack_UA_MonitoredItemNotification(SV *in)
{
	UA_MonitoredItemNotification out;
	SV **value;
	HV *hv;

	UA_MonitoredItemNotification_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "MonitoredItemNotification_clientHandle", 0);
	if (value != NULL)
		out.clientHandle = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "MonitoredItemNotification_value", 0);
	if (value != NULL)
		out.value = XS_unpack_UA_DataValue(*value);

	return out;
}

/* EventFieldList */
static void XS_pack_UA_EventFieldList(SV *out, UA_EventFieldList in)  __attribute__((unused));
static void
XS_pack_UA_EventFieldList(SV *out, UA_EventFieldList in)
{
	HV *hash = newHV();

	SV *clientHandleSV = newSV(0);
	XS_pack_UA_UInt32(clientHandleSV, in.clientHandle);
	hv_stores(hash, "EventFieldList_clientHandle", clientHandleSV);

	AV *eventFieldsArray = (AV*) sv_2mortal((SV*)newAV());
	size_t eventFieldsI;
	for(eventFieldsI = 0; eventFieldsI < in.eventFieldsSize; eventFieldsI++) {
		SV *element = newSV(0);
		XS_pack_UA_Variant(element, in.eventFields[eventFieldsI]);
		av_push(eventFieldsArray, element);
	}
	hv_stores(hash, "EventFieldList_eventFields", newRV_inc((SV*)eventFieldsArray));

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_EventFieldList XS_unpack_UA_EventFieldList(SV *in)  __attribute__((unused));
static UA_EventFieldList
XS_unpack_UA_EventFieldList(SV *in)
{
	UA_EventFieldList out;
	SV **value;
	HV *hv;

	UA_EventFieldList_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "EventFieldList_clientHandle", 0);
	if (value != NULL)
		out.clientHandle = XS_unpack_UA_UInt32(*value);

	/* TODO Implement array conversion for field eventFields */

	return out;
}

/* StatusChangeNotification */
static void XS_pack_UA_StatusChangeNotification(SV *out, UA_StatusChangeNotification in)  __attribute__((unused));
static void
XS_pack_UA_StatusChangeNotification(SV *out, UA_StatusChangeNotification in)
{
	HV *hash = newHV();

	SV *statusSV = newSV(0);
	XS_pack_UA_StatusCode(statusSV, in.status);
	hv_stores(hash, "StatusChangeNotification_status", statusSV);

	SV *diagnosticInfoSV = newSV(0);
	XS_pack_UA_DiagnosticInfo(diagnosticInfoSV, in.diagnosticInfo);
	hv_stores(hash, "StatusChangeNotification_diagnosticInfo", diagnosticInfoSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_StatusChangeNotification XS_unpack_UA_StatusChangeNotification(SV *in)  __attribute__((unused));
static UA_StatusChangeNotification
XS_unpack_UA_StatusChangeNotification(SV *in)
{
	UA_StatusChangeNotification out;
	SV **value;
	HV *hv;

	UA_StatusChangeNotification_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "StatusChangeNotification_status", 0);
	if (value != NULL)
		out.status = XS_unpack_UA_StatusCode(*value);

	value = hv_fetchs(hv, "StatusChangeNotification_diagnosticInfo", 0);
	if (value != NULL)
		out.diagnosticInfo = XS_unpack_UA_DiagnosticInfo(*value);

	return out;
}

/* SubscriptionAcknowledgement */
static void XS_pack_UA_SubscriptionAcknowledgement(SV *out, UA_SubscriptionAcknowledgement in)  __attribute__((unused));
static void
XS_pack_UA_SubscriptionAcknowledgement(SV *out, UA_SubscriptionAcknowledgement in)
{
	HV *hash = newHV();

	SV *subscriptionIdSV = newSV(0);
	XS_pack_UA_UInt32(subscriptionIdSV, in.subscriptionId);
	hv_stores(hash, "SubscriptionAcknowledgement_subscriptionId", subscriptionIdSV);

	SV *sequenceNumberSV = newSV(0);
	XS_pack_UA_UInt32(sequenceNumberSV, in.sequenceNumber);
	hv_stores(hash, "SubscriptionAcknowledgement_sequenceNumber", sequenceNumberSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_SubscriptionAcknowledgement XS_unpack_UA_SubscriptionAcknowledgement(SV *in)  __attribute__((unused));
static UA_SubscriptionAcknowledgement
XS_unpack_UA_SubscriptionAcknowledgement(SV *in)
{
	UA_SubscriptionAcknowledgement out;
	SV **value;
	HV *hv;

	UA_SubscriptionAcknowledgement_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "SubscriptionAcknowledgement_subscriptionId", 0);
	if (value != NULL)
		out.subscriptionId = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "SubscriptionAcknowledgement_sequenceNumber", 0);
	if (value != NULL)
		out.sequenceNumber = XS_unpack_UA_UInt32(*value);

	return out;
}

/* PublishRequest */
static void XS_pack_UA_PublishRequest(SV *out, UA_PublishRequest in)  __attribute__((unused));
static void
XS_pack_UA_PublishRequest(SV *out, UA_PublishRequest in)
{
	HV *hash = newHV();

	SV *requestHeaderSV = newSV(0);
	XS_pack_UA_RequestHeader(requestHeaderSV, in.requestHeader);
	hv_stores(hash, "PublishRequest_requestHeader", requestHeaderSV);

	AV *subscriptionAcknowledgementsArray = (AV*) sv_2mortal((SV*)newAV());
	size_t subscriptionAcknowledgementsI;
	for(subscriptionAcknowledgementsI = 0; subscriptionAcknowledgementsI < in.subscriptionAcknowledgementsSize; subscriptionAcknowledgementsI++) {
		SV *element = newSV(0);
		XS_pack_UA_SubscriptionAcknowledgement(element, in.subscriptionAcknowledgements[subscriptionAcknowledgementsI]);
		av_push(subscriptionAcknowledgementsArray, element);
	}
	hv_stores(hash, "PublishRequest_subscriptionAcknowledgements", newRV_inc((SV*)subscriptionAcknowledgementsArray));

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_PublishRequest XS_unpack_UA_PublishRequest(SV *in)  __attribute__((unused));
static UA_PublishRequest
XS_unpack_UA_PublishRequest(SV *in)
{
	UA_PublishRequest out;
	SV **value;
	HV *hv;

	UA_PublishRequest_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "PublishRequest_requestHeader", 0);
	if (value != NULL)
		out.requestHeader = XS_unpack_UA_RequestHeader(*value);

	/* TODO Implement array conversion for field subscriptionAcknowledgements */

	return out;
}

/* PublishResponse */
static void XS_pack_UA_PublishResponse(SV *out, UA_PublishResponse in)  __attribute__((unused));
static void
XS_pack_UA_PublishResponse(SV *out, UA_PublishResponse in)
{
	HV *hash = newHV();

	SV *responseHeaderSV = newSV(0);
	XS_pack_UA_ResponseHeader(responseHeaderSV, in.responseHeader);
	hv_stores(hash, "PublishResponse_responseHeader", responseHeaderSV);

	SV *subscriptionIdSV = newSV(0);
	XS_pack_UA_UInt32(subscriptionIdSV, in.subscriptionId);
	hv_stores(hash, "PublishResponse_subscriptionId", subscriptionIdSV);

	AV *availableSequenceNumbersArray = (AV*) sv_2mortal((SV*)newAV());
	size_t availableSequenceNumbersI;
	for(availableSequenceNumbersI = 0; availableSequenceNumbersI < in.availableSequenceNumbersSize; availableSequenceNumbersI++) {
		SV *element = newSV(0);
		XS_pack_UA_UInt32(element, in.availableSequenceNumbers[availableSequenceNumbersI]);
		av_push(availableSequenceNumbersArray, element);
	}
	hv_stores(hash, "PublishResponse_availableSequenceNumbers", newRV_inc((SV*)availableSequenceNumbersArray));

	SV *moreNotificationsSV = newSV(0);
	XS_pack_UA_Boolean(moreNotificationsSV, in.moreNotifications);
	hv_stores(hash, "PublishResponse_moreNotifications", moreNotificationsSV);

	SV *notificationMessageSV = newSV(0);
	XS_pack_UA_NotificationMessage(notificationMessageSV, in.notificationMessage);
	hv_stores(hash, "PublishResponse_notificationMessage", notificationMessageSV);

	AV *resultsArray = (AV*) sv_2mortal((SV*)newAV());
	size_t resultsI;
	for(resultsI = 0; resultsI < in.resultsSize; resultsI++) {
		SV *element = newSV(0);
		XS_pack_UA_StatusCode(element, in.results[resultsI]);
		av_push(resultsArray, element);
	}
	hv_stores(hash, "PublishResponse_results", newRV_inc((SV*)resultsArray));

	AV *diagnosticInfosArray = (AV*) sv_2mortal((SV*)newAV());
	size_t diagnosticInfosI;
	for(diagnosticInfosI = 0; diagnosticInfosI < in.diagnosticInfosSize; diagnosticInfosI++) {
		SV *element = newSV(0);
		XS_pack_UA_DiagnosticInfo(element, in.diagnosticInfos[diagnosticInfosI]);
		av_push(diagnosticInfosArray, element);
	}
	hv_stores(hash, "PublishResponse_diagnosticInfos", newRV_inc((SV*)diagnosticInfosArray));

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_PublishResponse XS_unpack_UA_PublishResponse(SV *in)  __attribute__((unused));
static UA_PublishResponse
XS_unpack_UA_PublishResponse(SV *in)
{
	UA_PublishResponse out;
	SV **value;
	HV *hv;

	UA_PublishResponse_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "PublishResponse_responseHeader", 0);
	if (value != NULL)
		out.responseHeader = XS_unpack_UA_ResponseHeader(*value);

	value = hv_fetchs(hv, "PublishResponse_subscriptionId", 0);
	if (value != NULL)
		out.subscriptionId = XS_unpack_UA_UInt32(*value);

	/* TODO Implement array conversion for field availableSequenceNumbers */

	value = hv_fetchs(hv, "PublishResponse_moreNotifications", 0);
	if (value != NULL)
		out.moreNotifications = XS_unpack_UA_Boolean(*value);

	value = hv_fetchs(hv, "PublishResponse_notificationMessage", 0);
	if (value != NULL)
		out.notificationMessage = XS_unpack_UA_NotificationMessage(*value);

	/* TODO Implement array conversion for field results */

	/* TODO Implement array conversion for field diagnosticInfos */

	return out;
}

/* RepublishRequest */
static void XS_pack_UA_RepublishRequest(SV *out, UA_RepublishRequest in)  __attribute__((unused));
static void
XS_pack_UA_RepublishRequest(SV *out, UA_RepublishRequest in)
{
	HV *hash = newHV();

	SV *requestHeaderSV = newSV(0);
	XS_pack_UA_RequestHeader(requestHeaderSV, in.requestHeader);
	hv_stores(hash, "RepublishRequest_requestHeader", requestHeaderSV);

	SV *subscriptionIdSV = newSV(0);
	XS_pack_UA_UInt32(subscriptionIdSV, in.subscriptionId);
	hv_stores(hash, "RepublishRequest_subscriptionId", subscriptionIdSV);

	SV *retransmitSequenceNumberSV = newSV(0);
	XS_pack_UA_UInt32(retransmitSequenceNumberSV, in.retransmitSequenceNumber);
	hv_stores(hash, "RepublishRequest_retransmitSequenceNumber", retransmitSequenceNumberSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_RepublishRequest XS_unpack_UA_RepublishRequest(SV *in)  __attribute__((unused));
static UA_RepublishRequest
XS_unpack_UA_RepublishRequest(SV *in)
{
	UA_RepublishRequest out;
	SV **value;
	HV *hv;

	UA_RepublishRequest_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "RepublishRequest_requestHeader", 0);
	if (value != NULL)
		out.requestHeader = XS_unpack_UA_RequestHeader(*value);

	value = hv_fetchs(hv, "RepublishRequest_subscriptionId", 0);
	if (value != NULL)
		out.subscriptionId = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "RepublishRequest_retransmitSequenceNumber", 0);
	if (value != NULL)
		out.retransmitSequenceNumber = XS_unpack_UA_UInt32(*value);

	return out;
}

/* RepublishResponse */
static void XS_pack_UA_RepublishResponse(SV *out, UA_RepublishResponse in)  __attribute__((unused));
static void
XS_pack_UA_RepublishResponse(SV *out, UA_RepublishResponse in)
{
	HV *hash = newHV();

	SV *responseHeaderSV = newSV(0);
	XS_pack_UA_ResponseHeader(responseHeaderSV, in.responseHeader);
	hv_stores(hash, "RepublishResponse_responseHeader", responseHeaderSV);

	SV *notificationMessageSV = newSV(0);
	XS_pack_UA_NotificationMessage(notificationMessageSV, in.notificationMessage);
	hv_stores(hash, "RepublishResponse_notificationMessage", notificationMessageSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_RepublishResponse XS_unpack_UA_RepublishResponse(SV *in)  __attribute__((unused));
static UA_RepublishResponse
XS_unpack_UA_RepublishResponse(SV *in)
{
	UA_RepublishResponse out;
	SV **value;
	HV *hv;

	UA_RepublishResponse_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "RepublishResponse_responseHeader", 0);
	if (value != NULL)
		out.responseHeader = XS_unpack_UA_ResponseHeader(*value);

	value = hv_fetchs(hv, "RepublishResponse_notificationMessage", 0);
	if (value != NULL)
		out.notificationMessage = XS_unpack_UA_NotificationMessage(*value);

	return out;
}

/* DeleteSubscriptionsRequest */
static void XS_pack_UA_DeleteSubscriptionsRequest(SV *out, UA_DeleteSubscriptionsRequest in)  __attribute__((unused));
static void
XS_pack_UA_DeleteSubscriptionsRequest(SV *out, UA_DeleteSubscriptionsRequest in)
{
	HV *hash = newHV();

	SV *requestHeaderSV = newSV(0);
	XS_pack_UA_RequestHeader(requestHeaderSV, in.requestHeader);
	hv_stores(hash, "DeleteSubscriptionsRequest_requestHeader", requestHeaderSV);

	AV *subscriptionIdsArray = (AV*) sv_2mortal((SV*)newAV());
	size_t subscriptionIdsI;
	for(subscriptionIdsI = 0; subscriptionIdsI < in.subscriptionIdsSize; subscriptionIdsI++) {
		SV *element = newSV(0);
		XS_pack_UA_UInt32(element, in.subscriptionIds[subscriptionIdsI]);
		av_push(subscriptionIdsArray, element);
	}
	hv_stores(hash, "DeleteSubscriptionsRequest_subscriptionIds", newRV_inc((SV*)subscriptionIdsArray));

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_DeleteSubscriptionsRequest XS_unpack_UA_DeleteSubscriptionsRequest(SV *in)  __attribute__((unused));
static UA_DeleteSubscriptionsRequest
XS_unpack_UA_DeleteSubscriptionsRequest(SV *in)
{
	UA_DeleteSubscriptionsRequest out;
	SV **value;
	HV *hv;

	UA_DeleteSubscriptionsRequest_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "DeleteSubscriptionsRequest_requestHeader", 0);
	if (value != NULL)
		out.requestHeader = XS_unpack_UA_RequestHeader(*value);

	/* TODO Implement array conversion for field subscriptionIds */

	return out;
}

/* DeleteSubscriptionsResponse */
static void XS_pack_UA_DeleteSubscriptionsResponse(SV *out, UA_DeleteSubscriptionsResponse in)  __attribute__((unused));
static void
XS_pack_UA_DeleteSubscriptionsResponse(SV *out, UA_DeleteSubscriptionsResponse in)
{
	HV *hash = newHV();

	SV *responseHeaderSV = newSV(0);
	XS_pack_UA_ResponseHeader(responseHeaderSV, in.responseHeader);
	hv_stores(hash, "DeleteSubscriptionsResponse_responseHeader", responseHeaderSV);

	AV *resultsArray = (AV*) sv_2mortal((SV*)newAV());
	size_t resultsI;
	for(resultsI = 0; resultsI < in.resultsSize; resultsI++) {
		SV *element = newSV(0);
		XS_pack_UA_StatusCode(element, in.results[resultsI]);
		av_push(resultsArray, element);
	}
	hv_stores(hash, "DeleteSubscriptionsResponse_results", newRV_inc((SV*)resultsArray));

	AV *diagnosticInfosArray = (AV*) sv_2mortal((SV*)newAV());
	size_t diagnosticInfosI;
	for(diagnosticInfosI = 0; diagnosticInfosI < in.diagnosticInfosSize; diagnosticInfosI++) {
		SV *element = newSV(0);
		XS_pack_UA_DiagnosticInfo(element, in.diagnosticInfos[diagnosticInfosI]);
		av_push(diagnosticInfosArray, element);
	}
	hv_stores(hash, "DeleteSubscriptionsResponse_diagnosticInfos", newRV_inc((SV*)diagnosticInfosArray));

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_DeleteSubscriptionsResponse XS_unpack_UA_DeleteSubscriptionsResponse(SV *in)  __attribute__((unused));
static UA_DeleteSubscriptionsResponse
XS_unpack_UA_DeleteSubscriptionsResponse(SV *in)
{
	UA_DeleteSubscriptionsResponse out;
	SV **value;
	HV *hv;

	UA_DeleteSubscriptionsResponse_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "DeleteSubscriptionsResponse_responseHeader", 0);
	if (value != NULL)
		out.responseHeader = XS_unpack_UA_ResponseHeader(*value);

	/* TODO Implement array conversion for field results */

	/* TODO Implement array conversion for field diagnosticInfos */

	return out;
}

/* BuildInfo */
static void XS_pack_UA_BuildInfo(SV *out, UA_BuildInfo in)  __attribute__((unused));
static void
XS_pack_UA_BuildInfo(SV *out, UA_BuildInfo in)
{
	HV *hash = newHV();

	SV *productUriSV = newSV(0);
	XS_pack_UA_String(productUriSV, in.productUri);
	hv_stores(hash, "BuildInfo_productUri", productUriSV);

	SV *manufacturerNameSV = newSV(0);
	XS_pack_UA_String(manufacturerNameSV, in.manufacturerName);
	hv_stores(hash, "BuildInfo_manufacturerName", manufacturerNameSV);

	SV *productNameSV = newSV(0);
	XS_pack_UA_String(productNameSV, in.productName);
	hv_stores(hash, "BuildInfo_productName", productNameSV);

	SV *softwareVersionSV = newSV(0);
	XS_pack_UA_String(softwareVersionSV, in.softwareVersion);
	hv_stores(hash, "BuildInfo_softwareVersion", softwareVersionSV);

	SV *buildNumberSV = newSV(0);
	XS_pack_UA_String(buildNumberSV, in.buildNumber);
	hv_stores(hash, "BuildInfo_buildNumber", buildNumberSV);

	SV *buildDateSV = newSV(0);
	XS_pack_UA_DateTime(buildDateSV, in.buildDate);
	hv_stores(hash, "BuildInfo_buildDate", buildDateSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_BuildInfo XS_unpack_UA_BuildInfo(SV *in)  __attribute__((unused));
static UA_BuildInfo
XS_unpack_UA_BuildInfo(SV *in)
{
	UA_BuildInfo out;
	SV **value;
	HV *hv;

	UA_BuildInfo_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "BuildInfo_productUri", 0);
	if (value != NULL)
		out.productUri = XS_unpack_UA_String(*value);

	value = hv_fetchs(hv, "BuildInfo_manufacturerName", 0);
	if (value != NULL)
		out.manufacturerName = XS_unpack_UA_String(*value);

	value = hv_fetchs(hv, "BuildInfo_productName", 0);
	if (value != NULL)
		out.productName = XS_unpack_UA_String(*value);

	value = hv_fetchs(hv, "BuildInfo_softwareVersion", 0);
	if (value != NULL)
		out.softwareVersion = XS_unpack_UA_String(*value);

	value = hv_fetchs(hv, "BuildInfo_buildNumber", 0);
	if (value != NULL)
		out.buildNumber = XS_unpack_UA_String(*value);

	value = hv_fetchs(hv, "BuildInfo_buildDate", 0);
	if (value != NULL)
		out.buildDate = XS_unpack_UA_DateTime(*value);

	return out;
}

/* RedundancySupport */
static void XS_pack_UA_RedundancySupport(SV *out, UA_RedundancySupport in)  __attribute__((unused));
static void
XS_pack_UA_RedundancySupport(SV *out, UA_RedundancySupport in)
{
	/* TODO implement EnumerationType conversion */

}

static UA_RedundancySupport XS_unpack_UA_RedundancySupport(SV *in)  __attribute__((unused));
static UA_RedundancySupport
XS_unpack_UA_RedundancySupport(SV *in)
{
	/* TODO implement EnumerationType conversion */
}

/* ServerState */
static void XS_pack_UA_ServerState(SV *out, UA_ServerState in)  __attribute__((unused));
static void
XS_pack_UA_ServerState(SV *out, UA_ServerState in)
{
	/* TODO implement EnumerationType conversion */

}

static UA_ServerState XS_unpack_UA_ServerState(SV *in)  __attribute__((unused));
static UA_ServerState
XS_unpack_UA_ServerState(SV *in)
{
	/* TODO implement EnumerationType conversion */
}

/* ServerDiagnosticsSummaryDataType */
static void XS_pack_UA_ServerDiagnosticsSummaryDataType(SV *out, UA_ServerDiagnosticsSummaryDataType in)  __attribute__((unused));
static void
XS_pack_UA_ServerDiagnosticsSummaryDataType(SV *out, UA_ServerDiagnosticsSummaryDataType in)
{
	HV *hash = newHV();

	SV *serverViewCountSV = newSV(0);
	XS_pack_UA_UInt32(serverViewCountSV, in.serverViewCount);
	hv_stores(hash, "ServerDiagnosticsSummaryDataType_serverViewCount", serverViewCountSV);

	SV *currentSessionCountSV = newSV(0);
	XS_pack_UA_UInt32(currentSessionCountSV, in.currentSessionCount);
	hv_stores(hash, "ServerDiagnosticsSummaryDataType_currentSessionCount", currentSessionCountSV);

	SV *cumulatedSessionCountSV = newSV(0);
	XS_pack_UA_UInt32(cumulatedSessionCountSV, in.cumulatedSessionCount);
	hv_stores(hash, "ServerDiagnosticsSummaryDataType_cumulatedSessionCount", cumulatedSessionCountSV);

	SV *securityRejectedSessionCountSV = newSV(0);
	XS_pack_UA_UInt32(securityRejectedSessionCountSV, in.securityRejectedSessionCount);
	hv_stores(hash, "ServerDiagnosticsSummaryDataType_securityRejectedSessionCount", securityRejectedSessionCountSV);

	SV *rejectedSessionCountSV = newSV(0);
	XS_pack_UA_UInt32(rejectedSessionCountSV, in.rejectedSessionCount);
	hv_stores(hash, "ServerDiagnosticsSummaryDataType_rejectedSessionCount", rejectedSessionCountSV);

	SV *sessionTimeoutCountSV = newSV(0);
	XS_pack_UA_UInt32(sessionTimeoutCountSV, in.sessionTimeoutCount);
	hv_stores(hash, "ServerDiagnosticsSummaryDataType_sessionTimeoutCount", sessionTimeoutCountSV);

	SV *sessionAbortCountSV = newSV(0);
	XS_pack_UA_UInt32(sessionAbortCountSV, in.sessionAbortCount);
	hv_stores(hash, "ServerDiagnosticsSummaryDataType_sessionAbortCount", sessionAbortCountSV);

	SV *currentSubscriptionCountSV = newSV(0);
	XS_pack_UA_UInt32(currentSubscriptionCountSV, in.currentSubscriptionCount);
	hv_stores(hash, "ServerDiagnosticsSummaryDataType_currentSubscriptionCount", currentSubscriptionCountSV);

	SV *cumulatedSubscriptionCountSV = newSV(0);
	XS_pack_UA_UInt32(cumulatedSubscriptionCountSV, in.cumulatedSubscriptionCount);
	hv_stores(hash, "ServerDiagnosticsSummaryDataType_cumulatedSubscriptionCount", cumulatedSubscriptionCountSV);

	SV *publishingIntervalCountSV = newSV(0);
	XS_pack_UA_UInt32(publishingIntervalCountSV, in.publishingIntervalCount);
	hv_stores(hash, "ServerDiagnosticsSummaryDataType_publishingIntervalCount", publishingIntervalCountSV);

	SV *securityRejectedRequestsCountSV = newSV(0);
	XS_pack_UA_UInt32(securityRejectedRequestsCountSV, in.securityRejectedRequestsCount);
	hv_stores(hash, "ServerDiagnosticsSummaryDataType_securityRejectedRequestsCount", securityRejectedRequestsCountSV);

	SV *rejectedRequestsCountSV = newSV(0);
	XS_pack_UA_UInt32(rejectedRequestsCountSV, in.rejectedRequestsCount);
	hv_stores(hash, "ServerDiagnosticsSummaryDataType_rejectedRequestsCount", rejectedRequestsCountSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_ServerDiagnosticsSummaryDataType XS_unpack_UA_ServerDiagnosticsSummaryDataType(SV *in)  __attribute__((unused));
static UA_ServerDiagnosticsSummaryDataType
XS_unpack_UA_ServerDiagnosticsSummaryDataType(SV *in)
{
	UA_ServerDiagnosticsSummaryDataType out;
	SV **value;
	HV *hv;

	UA_ServerDiagnosticsSummaryDataType_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "ServerDiagnosticsSummaryDataType_serverViewCount", 0);
	if (value != NULL)
		out.serverViewCount = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "ServerDiagnosticsSummaryDataType_currentSessionCount", 0);
	if (value != NULL)
		out.currentSessionCount = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "ServerDiagnosticsSummaryDataType_cumulatedSessionCount", 0);
	if (value != NULL)
		out.cumulatedSessionCount = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "ServerDiagnosticsSummaryDataType_securityRejectedSessionCount", 0);
	if (value != NULL)
		out.securityRejectedSessionCount = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "ServerDiagnosticsSummaryDataType_rejectedSessionCount", 0);
	if (value != NULL)
		out.rejectedSessionCount = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "ServerDiagnosticsSummaryDataType_sessionTimeoutCount", 0);
	if (value != NULL)
		out.sessionTimeoutCount = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "ServerDiagnosticsSummaryDataType_sessionAbortCount", 0);
	if (value != NULL)
		out.sessionAbortCount = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "ServerDiagnosticsSummaryDataType_currentSubscriptionCount", 0);
	if (value != NULL)
		out.currentSubscriptionCount = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "ServerDiagnosticsSummaryDataType_cumulatedSubscriptionCount", 0);
	if (value != NULL)
		out.cumulatedSubscriptionCount = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "ServerDiagnosticsSummaryDataType_publishingIntervalCount", 0);
	if (value != NULL)
		out.publishingIntervalCount = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "ServerDiagnosticsSummaryDataType_securityRejectedRequestsCount", 0);
	if (value != NULL)
		out.securityRejectedRequestsCount = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "ServerDiagnosticsSummaryDataType_rejectedRequestsCount", 0);
	if (value != NULL)
		out.rejectedRequestsCount = XS_unpack_UA_UInt32(*value);

	return out;
}

/* ServerStatusDataType */
static void XS_pack_UA_ServerStatusDataType(SV *out, UA_ServerStatusDataType in)  __attribute__((unused));
static void
XS_pack_UA_ServerStatusDataType(SV *out, UA_ServerStatusDataType in)
{
	HV *hash = newHV();

	SV *startTimeSV = newSV(0);
	XS_pack_UA_DateTime(startTimeSV, in.startTime);
	hv_stores(hash, "ServerStatusDataType_startTime", startTimeSV);

	SV *currentTimeSV = newSV(0);
	XS_pack_UA_DateTime(currentTimeSV, in.currentTime);
	hv_stores(hash, "ServerStatusDataType_currentTime", currentTimeSV);

	SV *stateSV = newSV(0);
	XS_pack_UA_ServerState(stateSV, in.state);
	hv_stores(hash, "ServerStatusDataType_state", stateSV);

	SV *buildInfoSV = newSV(0);
	XS_pack_UA_BuildInfo(buildInfoSV, in.buildInfo);
	hv_stores(hash, "ServerStatusDataType_buildInfo", buildInfoSV);

	SV *secondsTillShutdownSV = newSV(0);
	XS_pack_UA_UInt32(secondsTillShutdownSV, in.secondsTillShutdown);
	hv_stores(hash, "ServerStatusDataType_secondsTillShutdown", secondsTillShutdownSV);

	SV *shutdownReasonSV = newSV(0);
	XS_pack_UA_LocalizedText(shutdownReasonSV, in.shutdownReason);
	hv_stores(hash, "ServerStatusDataType_shutdownReason", shutdownReasonSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_ServerStatusDataType XS_unpack_UA_ServerStatusDataType(SV *in)  __attribute__((unused));
static UA_ServerStatusDataType
XS_unpack_UA_ServerStatusDataType(SV *in)
{
	UA_ServerStatusDataType out;
	SV **value;
	HV *hv;

	UA_ServerStatusDataType_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "ServerStatusDataType_startTime", 0);
	if (value != NULL)
		out.startTime = XS_unpack_UA_DateTime(*value);

	value = hv_fetchs(hv, "ServerStatusDataType_currentTime", 0);
	if (value != NULL)
		out.currentTime = XS_unpack_UA_DateTime(*value);

	value = hv_fetchs(hv, "ServerStatusDataType_state", 0);
	if (value != NULL)
		out.state = XS_unpack_UA_ServerState(*value);

	value = hv_fetchs(hv, "ServerStatusDataType_buildInfo", 0);
	if (value != NULL)
		out.buildInfo = XS_unpack_UA_BuildInfo(*value);

	value = hv_fetchs(hv, "ServerStatusDataType_secondsTillShutdown", 0);
	if (value != NULL)
		out.secondsTillShutdown = XS_unpack_UA_UInt32(*value);

	value = hv_fetchs(hv, "ServerStatusDataType_shutdownReason", 0);
	if (value != NULL)
		out.shutdownReason = XS_unpack_UA_LocalizedText(*value);

	return out;
}

/* Range */
static void XS_pack_UA_Range(SV *out, UA_Range in)  __attribute__((unused));
static void
XS_pack_UA_Range(SV *out, UA_Range in)
{
	HV *hash = newHV();

	SV *lowSV = newSV(0);
	XS_pack_UA_Double(lowSV, in.low);
	hv_stores(hash, "Range_low", lowSV);

	SV *highSV = newSV(0);
	XS_pack_UA_Double(highSV, in.high);
	hv_stores(hash, "Range_high", highSV);

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_Range XS_unpack_UA_Range(SV *in)  __attribute__((unused));
static UA_Range
XS_unpack_UA_Range(SV *in)
{
	UA_Range out;
	SV **value;
	HV *hv;

	UA_Range_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	value = hv_fetchs(hv, "Range_low", 0);
	if (value != NULL)
		out.low = XS_unpack_UA_Double(*value);

	value = hv_fetchs(hv, "Range_high", 0);
	if (value != NULL)
		out.high = XS_unpack_UA_Double(*value);

	return out;
}

/* DataChangeNotification */
static void XS_pack_UA_DataChangeNotification(SV *out, UA_DataChangeNotification in)  __attribute__((unused));
static void
XS_pack_UA_DataChangeNotification(SV *out, UA_DataChangeNotification in)
{
	HV *hash = newHV();

	AV *monitoredItemsArray = (AV*) sv_2mortal((SV*)newAV());
	size_t monitoredItemsI;
	for(monitoredItemsI = 0; monitoredItemsI < in.monitoredItemsSize; monitoredItemsI++) {
		SV *element = newSV(0);
		XS_pack_UA_MonitoredItemNotification(element, in.monitoredItems[monitoredItemsI]);
		av_push(monitoredItemsArray, element);
	}
	hv_stores(hash, "DataChangeNotification_monitoredItems", newRV_inc((SV*)monitoredItemsArray));

	AV *diagnosticInfosArray = (AV*) sv_2mortal((SV*)newAV());
	size_t diagnosticInfosI;
	for(diagnosticInfosI = 0; diagnosticInfosI < in.diagnosticInfosSize; diagnosticInfosI++) {
		SV *element = newSV(0);
		XS_pack_UA_DiagnosticInfo(element, in.diagnosticInfos[diagnosticInfosI]);
		av_push(diagnosticInfosArray, element);
	}
	hv_stores(hash, "DataChangeNotification_diagnosticInfos", newRV_inc((SV*)diagnosticInfosArray));

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_DataChangeNotification XS_unpack_UA_DataChangeNotification(SV *in)  __attribute__((unused));
static UA_DataChangeNotification
XS_unpack_UA_DataChangeNotification(SV *in)
{
	UA_DataChangeNotification out;
	SV **value;
	HV *hv;

	UA_DataChangeNotification_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	/* TODO Implement array conversion for field monitoredItems */

	/* TODO Implement array conversion for field diagnosticInfos */

	return out;
}

/* EventNotificationList */
static void XS_pack_UA_EventNotificationList(SV *out, UA_EventNotificationList in)  __attribute__((unused));
static void
XS_pack_UA_EventNotificationList(SV *out, UA_EventNotificationList in)
{
	HV *hash = newHV();

	AV *eventsArray = (AV*) sv_2mortal((SV*)newAV());
	size_t eventsI;
	for(eventsI = 0; eventsI < in.eventsSize; eventsI++) {
		SV *element = newSV(0);
		XS_pack_UA_EventFieldList(element, in.events[eventsI]);
		av_push(eventsArray, element);
	}
	hv_stores(hash, "EventNotificationList_events", newRV_inc((SV*)eventsArray));

	sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
}

static UA_EventNotificationList XS_unpack_UA_EventNotificationList(SV *in)  __attribute__((unused));
static UA_EventNotificationList
XS_unpack_UA_EventNotificationList(SV *in)
{
	UA_EventNotificationList out;
	SV **value;
	HV *hv;

	UA_EventNotificationList_init(&out);

	SvGETMAGIC(in);
	if (!SvROK(in) || SvTYPE(SvRV(in)) != SVt_PVHV) {
		croak("is not a HASH reference");
	}
	hv = (HV*)SvRV(in);

	/* TODO Implement array conversion for field events */

	return out;
}
